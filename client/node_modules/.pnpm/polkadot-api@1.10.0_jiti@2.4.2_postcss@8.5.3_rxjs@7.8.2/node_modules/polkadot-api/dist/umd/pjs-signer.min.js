(function(H,W){typeof exports=="object"&&typeof module<"u"?W(exports):typeof define=="function"&&define.amd?define(["exports"],W):(H=typeof globalThis<"u"?globalThis:H||self,W(H.papiPjsSigner={}))})(this,function(H){"use strict";var W=Object.defineProperty,dt=(e,t,n)=>t in e?W(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,me=(e,t,n)=>(dt(e,typeof t!="symbol"?t+"":t,n),n),se={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function ft(e){const t=e.length%2,n=(e[1]==="x"?2:0)+t,r=(e.length-n)/2+t,s=new Uint8Array(r);t&&(s[0]=0|se[e[2]]);for(let o=0;o<r;){const i=n+o*2,c=se[e[i]],h=se[e[i+1]];s[t+o++]=c<<4|h}return s}var we=class extends Uint8Array{constructor(e){super(e),me(this,"i",0),me(this,"v"),this.v=new DataView(e)}},C=e=>t=>e(t instanceof we?t:new we(t instanceof Uint8Array?t.buffer:typeof t=="string"?ft(t).buffer:t)),L=e=>{const t=e.length;let n=0;for(let s=0;s<t;s++)n+=e[s].length;const r=new Uint8Array(n);for(let s=0,o=0;s<t;s++){const i=e[s];r.set(i,o),o+=i.byteLength}return r};function Q(e,t){const n=Object.keys(e),r=n.length,s={};for(let o=0;o<r;o++){const i=n[o];s[i]=t(e[i],i)}return s}var B=(e,t)=>{const n=[e,t];return n.enc=e,n.dec=t,n},oe=(e,t)=>n=>e(t(n)),be=(e,t)=>n=>t(e(n)),Z=([e,t],n,r)=>B(oe(e,n),be(t,r));function pt(e,t){return C(n=>{const r=n.v[t](n.i,!0);return n.i+=e,r})}function vt(e,t){return n=>{const r=new Uint8Array(e);return new DataView(r.buffer)[t](0,n,!0),r}}function j(e,t,n){return B(vt(e,n),pt(e,t))}var k=j(1,"getUint8","setUint8"),ee=j(2,"getUint16","setUint16"),M=j(4,"getUint32","setUint32"),xe=j(8,"getBigUint64","setBigUint64");j(1,"getInt8","setInt8"),j(2,"getInt16","setInt16"),j(4,"getInt32","setInt32"),j(8,"getBigInt64","setBigInt64");var Ee=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigInt64(0,e,!0),n.setBigInt64(8,e>>64n,!0),t},Ae=e=>C(t=>{const{v:n,i:r}=t,s=n.getBigUint64(r,!0),o=n[e](r+8,!0);return t.i+=16,o<<64n|s});B(Ee,Ae("getBigUint64")),B(Ee,Ae("getBigInt64"));var Be=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigInt64(0,e,!0),n.setBigInt64(8,e>>64n,!0),n.setBigInt64(16,e>>128n,!0),n.setBigInt64(24,e>>192n,!0),t},ke=e=>C(t=>{let n=t.v.getBigUint64(t.i,!0);return t.i+=8,n|=t.v.getBigUint64(t.i,!0)<<64n,t.i+=8,n|=t.v.getBigUint64(t.i,!0)<<128n,t.i+=8,n|=t.v[e](t.i,!0)<<192n,t.i+=8,n});B(Be,ke("getBigUint64")),B(Be,ke("getBigInt64")),Z(k,e=>e?1:0,Boolean);var gt=[k[1],ee[1],M[1]],yt=C(e=>{const t=e[e.i],n=t&3;if(n<3)return gt[n](e)>>>2;const r=(t>>>2)+4;e.i++;let s=0n;const o=r/8|0;let i=0n;for(let h=0;h<o;h++)s=xe[1](e)<<i|s,i+=64n;let c=r%8;return c>3&&(s=BigInt(M[1](e))<<i|s,i+=32n,c-=4),c>1&&(s=BigInt(ee[1](e))<<i|s,i+=16n,c-=2),c&&(s=BigInt(k[1](e))<<i|s),s}),mt=1n<<56n,wt=1<<24,bt=256,xt=4294967295n,Et=64,At=16384,Bt=1<<30,kt=e=>{if(e<0)throw new Error(`Wrong compact input (${e})`);const t=Number(e)<<2;if(e<Et)return k[0](t);if(e<At)return ee[0](t|1);if(e<Bt)return M[0](t|2);let n=[new Uint8Array(1)],r=BigInt(e);for(;r>=mt;)n.push(xe[0](r)),r>>=64n;r>=wt&&(n.push(M[0](Number(r&xt))),r>>=32n);let s=Number(r);s>=bt&&(n.push(ee[0](s)),s>>=16),s&&n.push(k[0](s));const o=L(n);return o[0]=o.length-5<<2|3,o},T=B(kt,yt),It=new TextEncoder,Ut=e=>{const t=It.encode(e);return L([T.enc(t.length),t])},Tt=new TextDecoder,_t=C(e=>{let t=T.dec(e);const n=new DataView(e.buffer,e.i,t);return e.i+=t,Tt.decode(n)}),I=B(Ut,_t),Ct=()=>{},Ot=new Uint8Array(0),x=B(()=>Ot,Ct),Ie=e=>e===void 0?t=>L([T.enc(t.length),t]):t=>t.length===e?t:t.slice(0,e),Ue=e=>C(t=>{const n=e===void 0?T.dec(t):e!==1/0?e:t.byteLength-t.i,r=new Uint8Array(t.buffer.slice(t.i,t.i+n));return t.i+=n,r}),R=e=>B(Ie(e),Ue(e));R.enc=Ie,R.dec=Ue;var Te=(e,t)=>{const n=Object.keys(e),r=new Map(t?.map((o,i)=>[n[i],o])??n.map((o,i)=>[o,i])),s=o=>r.get(o);return({tag:o,value:i})=>L([k.enc(s(o)),e[o](i)])},_e=(e,t)=>{const n=Object.keys(e),r=new Map(t?.map((s,o)=>[s,n[o]])??n.map((s,o)=>[o,s]));return C(s=>{const o=k.dec(s),i=r.get(o),c=e[i];return{tag:i,value:c(s)}})},K=(e,...t)=>B(Te(Q(e,([n])=>n),...t),_e(Q(e,([,n])=>n),...t));K.enc=Te,K.dec=_e;var Ce=e=>C(t=>k[1](t)>0?e(t):void 0),Oe=e=>t=>{const n=new Uint8Array(1);return t===void 0?n:(n[0]=1,L([n,e(t)]))},_=e=>B(Oe(e[0]),Ce(e[1]));_.enc=Oe,_.dec=Ce;var Le=(...e)=>C(t=>e.map(n=>n(t))),De=(...e)=>t=>L(e.map((n,r)=>n(t[r]))),q=(...e)=>B(De(...e.map(([t])=>t)),Le(...e.map(([,t])=>t)));q.enc=De,q.dec=Le;var Se=e=>{const t=Object.keys(e);return oe(q.enc(...Object.values(e)),n=>t.map(r=>n[r]))},je=e=>{const t=Object.keys(e);return be(q.dec(...Object.values(e)),n=>Object.fromEntries(n.map((r,s)=>[t[s],r])))},m=e=>B(Se(Q(e,t=>t[0])),je(Q(e,t=>t[1])));m.enc=Se,m.dec=je;var Me=(e,t)=>t>=0?n=>L(n.map(e)):n=>L([T.enc(n.length),L(n.map(e))]),Pe=(e,t)=>C(n=>{const r=t>=0?t:T.dec(n),s=new Array(r);for(let o=0;o<r;o++)s[o]=e(n);return s}),E=(e,t)=>B(Me(e[0],t),Pe(e[1],t));E.enc=Me,E.dec=Pe;/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Lt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ve(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(n=>typeof n=="string"):t.every(n=>Number.isSafeInteger(n)):!1}function ie(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function Ne(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function ce(e){if(!Array.isArray(e))throw new Error("array expected")}function $e(e,t){if(!Ve(!0,t))throw new Error(`${e}: array of strings expected`)}function Dt(e,t){if(!Ve(!1,t))throw new Error(`${e}: array of numbers expected`)}function St(...e){const t=o=>o,n=(o,i)=>c=>o(i(c)),r=e.map(o=>o.encode).reduceRight(n,t),s=e.map(o=>o.decode).reduce(n,t);return{encode:r,decode:s}}function jt(e){const t=typeof e=="string"?e.split(""):e,n=t.length;$e("alphabet",t);const r=new Map(t.map((s,o)=>[s,o]));return{encode:s=>(ce(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${e}`);return t[o]})),decode:s=>(ce(s),s.map(o=>{ie("alphabet.decode",o);const i=r.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${e}`);return i}))}}function Mt(e=""){return ie("join",e),{encode:t=>($e("join.decode",t),t.join(e)),decode:t=>(ie("join.decode",t),t.split(e))}}function He(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(ce(e),!e.length)return[];let r=0;const s=[],o=Array.from(e,c=>{if(Ne(c),c<0||c>=t)throw new Error(`invalid integer: ${c}`);return c}),i=o.length;for(;;){let c=0,h=!0;for(let v=r;v<i;v++){const d=o[v],l=t*c,a=l+d;if(!Number.isSafeInteger(a)||l/t!==c||a-d!==l)throw new Error("convertRadix: carry overflow");const y=a/n;c=a%n;const p=Math.floor(y);if(o[v]=p,!Number.isSafeInteger(p)||p*n+c!==a)throw new Error("convertRadix: carry overflow");if(h)p?h=!1:r=v;else continue}if(s.push(c),h)break}for(let c=0;c<e.length-1&&e[c]===0;c++)s.push(0);return s.reverse()}function Pt(e){Ne(e);const t=2**8;return{encode:n=>{if(!Lt(n))throw new Error("radix.encode input should be Uint8Array");return He(Array.from(n),t,e)},decode:n=>(Dt("radix.decode",n),Uint8Array.from(He(n,e,t)))}}const Re=(e=>St(Pt(58),jt(e),Mt("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Vt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function ae(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function ue(e,...t){if(!Vt(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Ke(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Nt(e,t){ue(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function te(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function le(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const qe=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Fe(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}const D=qe?e=>e:e=>Fe(e);function $t(e){for(let t=0;t<e.length;t++)e[t]=Fe(e[t]);return e}const F=qe?e=>e:$t;function Ht(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function z(e){return typeof e=="string"&&(e=Ht(e)),ue(e),e}class Rt{}function Kt(e){const t=(r,s)=>e(s).update(z(r)).digest(),n=e({});return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=r=>e(r),t}const qt=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9]),ne=BigInt(2**32-1),Xe=BigInt(32);function Ft(e,t=!1){return t?{h:Number(e&ne),l:Number(e>>Xe&ne)}:{h:Number(e>>Xe&ne)|0,l:Number(e&ne)|0}}const Ge=(e,t,n)=>e>>>n|t<<32-n,We=(e,t,n)=>e<<32-n|t>>>n,Xt=(e,t,n)=>e<<64-n|t>>>n-32,Gt=(e,t,n)=>e>>>n-32|t<<64-n,Wt=(e,t)=>t,zt=(e,t)=>e;function ze(e,t,n,r){const s=(t>>>0)+(r>>>0);return{h:e+n+(s/2**32|0)|0,l:s|0}}const Ye=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),Je=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,A=Uint32Array.from([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),u=new Uint32Array(32);function P(e,t,n,r,s,o){const i=s[o],c=s[o+1];let h=u[2*e],v=u[2*e+1],d=u[2*t],l=u[2*t+1],a=u[2*n],y=u[2*n+1],p=u[2*r],f=u[2*r+1],b=Ye(h,d,i);v=Je(b,v,l,c),h=b|0,{Dh:f,Dl:p}={Dh:f^v,Dl:p^h},{Dh:f,Dl:p}={Dh:Wt(f,p),Dl:zt(f)},{h:y,l:a}=ze(y,a,f,p),{Bh:l,Bl:d}={Bh:l^y,Bl:d^a},{Bh:l,Bl:d}={Bh:Ge(l,d,24),Bl:We(l,d,24)},u[2*e]=h,u[2*e+1]=v,u[2*t]=d,u[2*t+1]=l,u[2*n]=a,u[2*n+1]=y,u[2*r]=p,u[2*r+1]=f}function V(e,t,n,r,s,o){const i=s[o],c=s[o+1];let h=u[2*e],v=u[2*e+1],d=u[2*t],l=u[2*t+1],a=u[2*n],y=u[2*n+1],p=u[2*r],f=u[2*r+1],b=Ye(h,d,i);v=Je(b,v,l,c),h=b|0,{Dh:f,Dl:p}={Dh:f^v,Dl:p^h},{Dh:f,Dl:p}={Dh:Ge(f,p,16),Dl:We(f,p,16)},{h:y,l:a}=ze(y,a,f,p),{Bh:l,Bl:d}={Bh:l^y,Bl:d^a},{Bh:l,Bl:d}={Bh:Xt(l,d,63),Bl:Gt(l,d,63)},u[2*e]=h,u[2*e+1]=v,u[2*t]=d,u[2*t+1]=l,u[2*n]=a,u[2*n+1]=y,u[2*r]=p,u[2*r+1]=f}function Yt(e,t={},n,r,s){if(ae(n),e<0||e>n)throw new Error("outputLen bigger than keyLen");const{key:o,salt:i,personalization:c}=t;if(o!==void 0&&(o.length<1||o.length>n))throw new Error("key length must be undefined or 1.."+n);if(i!==void 0&&i.length!==r)throw new Error("salt must be undefined or "+r);if(c!==void 0&&c.length!==s)throw new Error("personalization must be undefined or "+s)}class Jt extends Rt{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,this.length=0,this.pos=0,ae(t),ae(n),this.blockLen=t,this.outputLen=n,this.buffer=new Uint8Array(t),this.buffer32=te(this.buffer)}update(t){Ke(this),t=z(t),ue(t);const{blockLen:n,buffer:r,buffer32:s}=this,o=t.length,i=t.byteOffset,c=t.buffer;for(let h=0;h<o;){this.pos===n&&(F(s),this.compress(s,0,!1),F(s),this.pos=0);const v=Math.min(n-this.pos,o-h),d=i+h;if(v===n&&!(d%4)&&h+v<o){const l=new Uint32Array(c,d,Math.floor((o-h)/4));F(l);for(let a=0;h+n<o;a+=s.length,h+=n)this.length+=n,this.compress(l,a,!1);F(l);continue}r.set(t.subarray(h,h+v),this.pos),this.pos+=v,this.length+=v,h+=v}return this}digestInto(t){Ke(this),Nt(t,this);const{pos:n,buffer32:r}=this;this.finished=!0,le(this.buffer.subarray(n)),F(r),this.compress(r,0,!0),F(r);const s=te(t);this.get().forEach((o,i)=>s[i]=D(o))}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){const{buffer:n,length:r,finished:s,destroyed:o,outputLen:i,pos:c}=this;return t||(t=new this.constructor({dkLen:i})),t.set(...this.get()),t.buffer.set(n),t.destroyed=o,t.finished=s,t.length=r,t.pos=c,t.outputLen=i,t}clone(){return this._cloneInto()}}class Qt extends Jt{constructor(t={}){const n=t.dkLen===void 0?64:t.dkLen;super(128,n),this.v0l=A[0]|0,this.v0h=A[1]|0,this.v1l=A[2]|0,this.v1h=A[3]|0,this.v2l=A[4]|0,this.v2h=A[5]|0,this.v3l=A[6]|0,this.v3h=A[7]|0,this.v4l=A[8]|0,this.v4h=A[9]|0,this.v5l=A[10]|0,this.v5h=A[11]|0,this.v6l=A[12]|0,this.v6h=A[13]|0,this.v7l=A[14]|0,this.v7h=A[15]|0,Yt(n,t,64,16,16);let{key:r,personalization:s,salt:o}=t,i=0;if(r!==void 0&&(r=z(r),i=r.length),this.v0l^=this.outputLen|i<<8|65536|1<<24,o!==void 0){o=z(o);const c=te(o);this.v4l^=D(c[0]),this.v4h^=D(c[1]),this.v5l^=D(c[2]),this.v5h^=D(c[3])}if(s!==void 0){s=z(s);const c=te(s);this.v6l^=D(c[0]),this.v6h^=D(c[1]),this.v7l^=D(c[2]),this.v7h^=D(c[3])}if(r!==void 0){const c=new Uint8Array(this.blockLen);c.set(r),this.update(c)}}get(){let{v0l:t,v0h:n,v1l:r,v1h:s,v2l:o,v2h:i,v3l:c,v3h:h,v4l:v,v4h:d,v5l:l,v5h:a,v6l:y,v6h:p,v7l:f,v7h:b}=this;return[t,n,r,s,o,i,c,h,v,d,l,a,y,p,f,b]}set(t,n,r,s,o,i,c,h,v,d,l,a,y,p,f,b){this.v0l=t|0,this.v0h=n|0,this.v1l=r|0,this.v1h=s|0,this.v2l=o|0,this.v2h=i|0,this.v3l=c|0,this.v3h=h|0,this.v4l=v|0,this.v4h=d|0,this.v5l=l|0,this.v5h=a|0,this.v6l=y|0,this.v6h=p|0,this.v7l=f|0,this.v7h=b|0}compress(t,n,r){this.get().forEach((h,v)=>u[v]=h),u.set(A,16);let{h:s,l:o}=Ft(BigInt(this.length));u[24]=A[8]^o,u[25]=A[9]^s,r&&(u[28]=~u[28],u[29]=~u[29]);let i=0;const c=qt;for(let h=0;h<12;h++)P(0,4,8,12,t,n+2*c[i++]),V(0,4,8,12,t,n+2*c[i++]),P(1,5,9,13,t,n+2*c[i++]),V(1,5,9,13,t,n+2*c[i++]),P(2,6,10,14,t,n+2*c[i++]),V(2,6,10,14,t,n+2*c[i++]),P(3,7,11,15,t,n+2*c[i++]),V(3,7,11,15,t,n+2*c[i++]),P(0,5,10,15,t,n+2*c[i++]),V(0,5,10,15,t,n+2*c[i++]),P(1,6,11,12,t,n+2*c[i++]),V(1,6,11,12,t,n+2*c[i++]),P(2,7,8,13,t,n+2*c[i++]),V(2,7,8,13,t,n+2*c[i++]),P(3,4,9,14,t,n+2*c[i++]),V(3,4,9,14,t,n+2*c[i++]);this.v0l^=u[0]^u[16],this.v0h^=u[1]^u[17],this.v1l^=u[2]^u[18],this.v1h^=u[3]^u[19],this.v2l^=u[4]^u[20],this.v2h^=u[5]^u[21],this.v3l^=u[6]^u[22],this.v3h^=u[7]^u[23],this.v4l^=u[8]^u[24],this.v4h^=u[9]^u[25],this.v5l^=u[10]^u[26],this.v5h^=u[11]^u[27],this.v6l^=u[12]^u[28],this.v6h^=u[13]^u[29],this.v7l^=u[14]^u[30],this.v7h^=u[15]^u[31],le(u)}destroy(){this.destroyed=!0,le(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const he=Kt(e=>new Qt(e)),Qe=new TextEncoder().encode("SS58PRE"),de=2,Zt=e=>{try{const t=Re.decode(e),n=t.subarray(0,t[0]&64?2:1),r=t.subarray(n.length,t.length-de),s=t.subarray(n.length+r.length),o=he(Uint8Array.of(...Qe,...n,...r),{dkLen:64}).subarray(0,de);return s[0]===o[0]&&s[1]===o[1]?{isValid:!0,ss58Format:en(n),publicKey:r.slice()}:{isValid:!1}}catch{return{isValid:!1}}},en=e=>{const t=new DataView(e.buffer,e.byteOffset,e.byteLength);return t.byteLength===1?t.getUint8(0):t.getUint16(0)},tn=e=>{const t=e<64?Uint8Array.of(e):Uint8Array.of((e&252)>>2|64,e>>8|(e&3)<<6);return n=>{const r=he(Uint8Array.of(...Qe,...t,...n),{dkLen:64}).subarray(0,de);return Re.encode(Uint8Array.of(...t,...n,...r))}};function nn(e,t){return n=>{const r=Zt(n);if(!r.isValid)throw new Error("Invalid checksum");const{publicKey:s}=r;if(s.length!==e)throw new Error("Invalid public key length");return s}}const rn=(e=42,t=32)=>Z(R(t),nn(t),tn(e)),Ze="0123456789abcdef";function N(e){const t=new Array(e.length+1);t[0]="0x";for(let n=0;n<e.length;){const r=e[n++];t[n]=Ze[r>>4]+Ze[r&15]}return t.join("")}const fe={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function Y(e){const t=e.length%2,n=(e[1]==="x"?2:0)+t,r=(e.length-n)/2+t,s=new Uint8Array(r);t&&(s[0]=0|fe[e[2]]);for(let o=0;o<r;){const i=n+o*2,c=fe[e[i]],h=fe[e[i+1]];s[t+o++]=c<<4|h}return s}const et=(...e)=>{const t=e.reduce((r,s)=>r+s.byteLength,0),n=new Uint8Array(t);for(let r=0,s=0;r<e.length;r++){const o=e[r];n.set(o,s),s+=o.byteLength}return n},g=Z(T,e=>e,Number),sn=Z(T,e=>e,BigInt),tt=e=>{const t=R.enc(e);return n=>t(Y(n))},nt=e=>{const t=R.dec(e);return n=>N(t(n))},J=e=>B(tt(e),nt(e));J.enc=tt,J.dec=nt;const X=(e,t)=>{const n=e;return n.inner=t,n},pe=e=>X(m(e),e);pe.enc=e=>X(m.enc(e),e),pe.dec=e=>X(m.dec(e),e);const ve=e=>X(_(e),e);ve.enc=e=>X(_.enc(e),e),ve.dec=e=>X(_.dec(e),e);const S=E(I),rt=_(I),on=K({bool:x,char:x,str:x,u8:x,u16:x,u32:x,u64:x,u128:x,u256:x,i8:x,i16:x,i32:x,i64:x,i128:x,i256:x}),st=E(m({name:rt,type:g,typeName:rt,docs:S})),cn=m({len:M,type:g}),an=m({bitStoreType:g,bitOrderType:g}),un=E(m({name:I,fields:st,index:k,docs:S})),ln=K({composite:st,variant:un,sequence:g,array:cn,tuple:E(g),primitive:on,compact:g,bitSequence:an}),hn=m({name:I,type:_(g)}),dn=E(hn),fn=m({id:g,path:S,params:dn,def:ln,docs:S}),ot=E(fn),pn=K({Blake2128:x,Blake2256:x,Blake2128Concat:x,Twox128:x,Twox256:x,Twox64Concat:x,Identity:x}),vn=E(pn),gn=m({hashers:vn,key:g,value:g}),yn=m({name:I,modifier:k,type:K({plain:g,map:gn}),fallback:J(),docs:S}),mn=_(m({prefix:I,items:E(yn)})),it={name:I,storage:mn,calls:_(g),events:_(g),constants:E(m({name:I,type:g,value:J(),docs:S})),errors:_(g),index:k},wn={...it,docs:S},bn=new Uint8Array,ct=e=>B(()=>bn,()=>e),xn=m({type:g,version:k,signedExtensions:E(m({identifier:I,type:g,additionalSigned:g}))}),En=m({lookup:ot,pallets:E(m({...it,docs:ct([])})),extrinsic:xn,type:g,apis:ct([])}),An=m({name:I,methods:E(m({name:I,inputs:E(m({name:I,type:g})),output:g,docs:S})),docs:S}),Bn=m({version:k,address:g,call:g,signature:g,extra:g,signedExtensions:E(m({identifier:I,type:g,additionalSigned:g}))}),kn=m({lookup:ot,pallets:E(m(wn)),extrinsic:Bn,type:g,apis:E(An),outerEnums:m({call:g,event:g,error:g}),custom:E(q(I,m({type:g,value:J()})))}),at=()=>{throw new Error("Unsupported metadata version!")},U=B(at,at),re=m({magicNumber:M,metadata:K({v0:U,v1:U,v2:U,v3:U,v4:U,v5:U,v6:U,v7:U,v8:U,v9:U,v10:U,v11:U,v12:U,v13:U,v14:En,v15:kn})}),ge=R(),In=_(ge),Un=q(T,ge),Tn=e=>{try{return re.dec(e)}catch{}try{return re.dec(In.dec(e))}catch{}try{return re.dec(ge.dec(e))}catch{}try{return re.dec(Un.dec(e)[1])}catch{}throw null},_n={dkLen:32},Cn=e=>he(e,_n),ut=(e,t)=>e.type==="array"&&e.len===t&&e.value.type==="primitive"&&e.value.value==="u8",$={type:"void"},On=(e,t=()=>null)=>{const n=new Map,r=new Set,s=d=>l=>{let a=n.get(l);if(a)return a;if(r.has(l)){const p={id:l};return n.set(l,p),p}r.add(l);const y=d(l);return a=n.get(l),a?Object.assign(a,y):(a={id:l,...y},n.set(l,a)),r.delete(l),a};let o=!0,i=!0;const c=s(d=>{const l=t(e[d]);if(l)return l;const{def:a,path:y,params:p}=e[d];if(a.tag==="composite"){if(a.value.length===0)return $;if(a.value.length===1){const f=c(a.value[0].type);return o&&y.at(-1)==="AccountId32"&&ut(f,32)?(o=!1,{type:"AccountId32"}):i&&y.at(-1)==="AccountId20"&&ut(f,20)?(i=!1,{type:"AccountId20"}):f}return h(a.value)}if(a.tag==="variant"){if(y.length===1&&y[0]==="Option"&&p.length===1&&p[0].name==="T"){const w=c(p[0].type);return w.type==="void"?{type:"primitive",value:"bool"}:{type:"option",value:w}}if(y.length===1&&y[0]==="Result"&&p.length===2&&p[0].name==="T"&&p[1].name==="E")return{type:"result",value:{ok:c(p[0].type),ko:c(p[1].type)}};if(a.value.length===0)return $;const f={},b={};return a.value.forEach(w=>{const O=w.name;if(b[O]=w.docs,w.fields.length===0){f[O]={...$,idx:w.index};return}if(w.fields.length===1&&!w.fields[0].name){f[O]={type:"lookupEntry",value:c(w.fields[0].type),idx:w.index};return}f[O]={...h(w.fields),idx:w.index}}),{type:"enum",value:f,innerDocs:b}}if(a.tag==="sequence")return{type:"sequence",value:c(a.value)};if(a.tag==="array"){const{len:f}=a.value,b=c(a.value.type);return!f||b.type==="void"?$:f>1?{type:"array",value:b,len:a.value.len}:b}if(a.tag==="tuple")return a.value.length===0?$:a.value.length>1?v(a.value.map(f=>c(f)),a.value.map(f=>e[f].docs)):c(a.value[0]);if(a.tag==="primitive")return{type:"primitive",value:a.value.tag};if(a.tag==="compact"){const f=c(a.value);return f.type==="void"?$:{type:"compact",isBig:Number(f.value.slice(1))>32,size:f.value}}return{type:a.tag}}),h=d=>{let l=!0;const a={},y={};return d.forEach((p,f)=>{l=l&&!!p.name;const b=p.name||f,w=c(p.type);w.type!=="void"&&(a[b]=w,y[b]=p.docs)}),l?{type:"struct",value:a,innerDocs:y}:v(Object.values(a),Object.values(y))},v=(d,l)=>{if(d.every(a=>a.id===d[0].id)&&l.every(a=>!a.length)){const[a]=d;return a.type==="void"?$:{type:"array",value:d[0],len:d.length}}return{type:"tuple",value:d,innerDocs:l}};return c},Ln=e=>{const t=On(e.lookup,({def:s})=>{if(s.tag==="composite"){const o=n(s);if(o)return{type:"enum",innerDocs:{},value:Object.fromEntries(e.pallets.map(i=>[i.name,i.errors==null?{...$,idx:i.index}:{type:"lookupEntry",value:t(i.errors),idx:i.index}])),byteLength:o}}return null});function n(s){if(!(s.value.length===2&&s.value[0].name==="index"&&s.value[1].name==="error"))return null;const i=t(s.value[0].type),c=t(s.value[1].type);return i.type==="primitive"&&i.value==="u8"&&c.type==="array"&&c.value.type==="primitive"&&c.value.value==="u8"?1+c.len:null}return Object.assign(t,{metadata:e,call:"outerEnums"in e?e.outerEnums.call:e.lookup[e.extrinsic?.type]?.params.find(i=>i.name==="Call")?.type??null})},Dn=oe(k.enc,e=>+!!e.signed<<7|e.version),ye=()=>new Error("Unkown signer"),Sn=e=>{const{extrinsic:t}=e,n=Ln(e);let r,s;if("address"in t)r=n(t.address),s=n(t.signature);else{const o=Object.fromEntries(e.lookup[t.type].params.filter(i=>i.type!=null).map(i=>[i.name,n(i.type)]));if(r=o.Address,s=o.Signature,!r||!s)throw ye()}if(r.type==="AccountId20"&&s.type==="array"&&s.len===65&&s.value.type==="primitive"&&s.value.value==="u8")return[1,[]];if(s.type!=="enum"||["Ecdsa","Ed25519","Sr25519"].some(o=>!(o in s.value)))throw ye();if(r.type==="enum"){const o=r.value.Id;if(o.type==="lookupEntry"&&o.value.type==="AccountId32")return[0,[o.idx]]}else if(r.type==="AccountId32")return[0,[]];throw ye()},jn=(e,t,n,r,s,o)=>{const[i,c]=Sn(e),h=et(Dn({signed:!0,version:4}),i===1?t:new Uint8Array([...c,...t]),n,...r,s);return et(T.enc(h.length),h)},G=(e,t)=>{let n=e.toString(16);n=(n.length%2?"0":"")+n;const r=Math.max(0,(t||0)-n.length/2);return"0x"+"00".repeat(r)+n},Mn=({additionalSigned:e})=>({genesisHash:N(e)}),Pn=({value:e})=>({nonce:G(T.dec(e),4)}),Vn=({additionalSigned:e})=>({transactionVersion:G(M.dec(e),4)}),Nn=pe({tip:T,asset:ve(R(1/0))}).dec;var lt=Object.freeze({__proto__:null,ChargeAssetTxPayment:({value:e})=>{const{tip:t,asset:n}=Nn(e);return{...n?{assetId:N(n)}:{},tip:G(t,16)}},ChargeTransactionPayment:({value:e})=>({tip:G(sn.dec(e),16)}),CheckGenesis:Mn,CheckMetadataHash:({value:e,additionalSigned:t})=>e.length&&e[0]?{mode:1,metadataHash:N(t.length?t.slice(1):t)}:{},CheckMortality:({value:e,additionalSigned:t},n)=>({era:N(e),blockHash:N(t),blockNumber:G(n,4)}),CheckNonce:Pn,CheckSpecVersion:({additionalSigned:e})=>({specVersion:G(M.dec(e),4)}),CheckTxVersion:Vn});const $n=rn().enc,Hn=e=>e.startsWith("0x")?Y(e):$n(e);function ht(e,t,n){const r=i=>n({address:e,data:N(i),type:"bytes"}).then(({signature:c})=>Y(c)),s=Hn(e);return{publicKey:s,signTx:async(i,c,h,v,d=Cn)=>{let l;try{const w=Tn(h);if(w.metadata.tag!=="v14"&&w.metadata.tag!=="v15")throw null;l=w.metadata.value}catch{throw new Error("Unsupported metadata version")}const a={};a.signedExtensions=[];const{version:y}=l.extrinsic,p=[];l.extrinsic.signedExtensions.map(({identifier:w})=>{const O=c[w];if(!O)throw new Error(`Missing ${w} signed-extension`);if(p.push(O.value),a.signedExtensions.push(w),!lt[w]){if(O.value.length===0&&O.additionalSigned.length===0)return;throw new Error(`PJS does not support this signed-extension: ${w}`)}Object.assign(a,lt[w](O,v))}),a.address=e,a.method=N(i),a.version=y,a.withSignedTransaction=!0;const f=await t(a),b=f.signedTransaction;return b?typeof b=="string"?Y(b):b:jn(l,s,Y(f.signature),p,i)},signBytes:r}}const Rn=new Set(["ed25519","sr25519","ecdsa","ethereum"]),Kn=async(e,t)=>{let n=window.injectedWeb3?.[e];if(!n)throw new Error(`Unavailable extension: "${e}"`);const r=await n.enable(t),s=r.signer.signPayload.bind(r.signer),o=r.signer.signRaw.bind(r.signer),i=d=>d.filter(({type:l})=>Rn.has(l)).map(l=>{const a=ht(l.address,s,o);return{...l,polkadotSigner:a}});let c=i(await r.accounts.get());const h=new Set,v=r.accounts.subscribe(d=>{c=i(d),h.forEach(l=>{l(c)})});return{name:e,getAccounts:()=>c,subscribe:d=>(h.add(d),()=>{h.delete(d)}),disconnect:()=>{v()}}},qn=()=>{const{injectedWeb3:e}=window;return e?Object.keys(e):[]};H.connectInjectedExtension=Kn,H.getInjectedExtensions=qn,H.getPolkadotSignerFromPjs=ht});
