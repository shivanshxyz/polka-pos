"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QrDisplay = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = tslib_1.__importStar(require("react"));
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const qrcode_js_1 = require("./qrcode.js");
const styled_js_1 = require("./styled.js");
const util_js_1 = require("./util.js");
const DEFAULT_FRAME_DELAY = 2750;
const TIMER_INC = 500;
function getDataUrl(value) {
    const qr = (0, qrcode_js_1.qrcode)(0, 'M');
    // HACK See our qrcode stringToBytes override as used internally. This
    // will only work for the case where we actually pass `Bytes` in here
    qr.addData(value, 'Byte');
    qr.make();
    return qr.createDataURL(16, 0);
}
function Display({ className = '', size, skipEncoding, style = {}, timerDelay = DEFAULT_FRAME_DELAY, value }) {
    const [{ image }, setFrameState] = (0, react_1.useState)({ frameIdx: 0, frames: [], image: null, valueHash: null });
    const timerRef = (0, react_1.useRef)({ timerDelay, timerId: null });
    const containerStyle = (0, react_1.useMemo)(() => (0, util_js_1.createImgSize)(size), [size]);
    // run on initial load to setup the global timer and provide and unsubscribe
    (0, react_1.useEffect)(() => {
        const nextFrame = () => setFrameState((state) => {
            // when we have a single frame, we only ever fire once
            if (state.frames.length <= 1) {
                return state;
            }
            let frameIdx = state.frameIdx + 1;
            // when we overflow, skip to the first and slightly increase the delay between frames
            if (frameIdx === state.frames.length) {
                frameIdx = 0;
                timerRef.current.timerDelay = timerRef.current.timerDelay + TIMER_INC;
            }
            // only encode the frames on demand, not above as part of the
            // state derivation - in the case of large payloads, this should
            // be slightly more responsive on initial load
            const newState = (0, util_1.objectSpread)({}, state, {
                frameIdx,
                image: getDataUrl(state.frames[frameIdx])
            });
            // set the new timer last
            timerRef.current.timerId = setTimeout(nextFrame, timerRef.current.timerDelay);
            return newState;
        });
        timerRef.current.timerId = setTimeout(nextFrame, timerRef.current.timerDelay);
        return () => {
            // eslint-disable-next-line react-hooks/exhaustive-deps
            timerRef.current.timerId && clearTimeout(timerRef.current.timerId);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    (0, react_1.useEffect)(() => {
        setFrameState((state) => {
            const valueHash = (0, util_crypto_1.xxhashAsHex)(value);
            if (valueHash === state.valueHash) {
                return state;
            }
            const frames = skipEncoding
                ? [value]
                : (0, util_js_1.createFrames)(value);
            // encode on demand
            return {
                frameIdx: 0,
                frames,
                image: getDataUrl(frames[0]),
                valueHash
            };
        });
    }, [skipEncoding, value]);
    if (!image) {
        return null;
    }
    return ((0, jsx_runtime_1.jsx)(StyledDiv, { className: className, style: containerStyle, children: (0, jsx_runtime_1.jsx)("div", { className: 'ui--qr-Display', style: style, children: (0, jsx_runtime_1.jsx)("img", { src: image }) }) }));
}
const StyledDiv = styled_js_1.styled.div `
  .ui--qr-Display {
    height: 100%;
    width: 100%;

    img,
    svg {
      background: white;
      height: auto !important;
      max-height: 100%;
      max-width: 100%;
      width: auto !important;
    }
  }
`;
exports.QrDisplay = react_1.default.memo(Display);
