import { jsx as _jsx } from "react/jsx-runtime";
import React, { useCallback } from 'react';
import { decodeAddress } from '@polkadot/util-crypto';
import { ADDRESS_PREFIX, SEED_PREFIX } from './constants.js';
import { QrScan } from './Scan.js';
function ScanAddress({ className, isEthereum, onError, onScan, size, style }) {
    const _onScan = useCallback((data) => {
        if (data) {
            try {
                let prefix;
                let content;
                let genesisHash;
                let name;
                if (!isEthereum) {
                    [prefix, content, genesisHash, ...name] = data.split(':');
                }
                else {
                    [prefix, content, ...name] = data.split(':');
                    genesisHash = null;
                    content = content.substring(0, 42);
                }
                const expectedPrefix = (isEthereum ? 'ethereum' : ADDRESS_PREFIX);
                const isValidPrefix = (prefix === expectedPrefix) || (prefix === SEED_PREFIX);
                if (!isValidPrefix) {
                    throw new Error(`Invalid prefix received, expected '${expectedPrefix} or ${SEED_PREFIX}' , found '${prefix}'`);
                }
                const isAddress = prefix === expectedPrefix;
                if (isAddress && !isEthereum) {
                    decodeAddress(content);
                }
                onScan({ content, genesisHash: genesisHash, isAddress, name: name?.length ? name.join(':') : undefined });
            }
            catch (error) {
                onError && onError(error);
                console.error('@polkadot/react-qr:QrScanAddress', error.message, data);
            }
        }
    }, [onScan, onError, isEthereum]);
    return (_jsx(QrScan, { className: className, onError: onError, onScan: _onScan, size: size, style: style }));
}
export const QrScanAddress = React.memo(ScanAddress);
