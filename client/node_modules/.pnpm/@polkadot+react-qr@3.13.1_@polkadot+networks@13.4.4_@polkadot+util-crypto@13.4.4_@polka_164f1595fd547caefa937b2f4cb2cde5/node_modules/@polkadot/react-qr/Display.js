import { jsx as _jsx } from "react/jsx-runtime";
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { objectSpread } from '@polkadot/util';
import { xxhashAsHex } from '@polkadot/util-crypto';
import { qrcode } from './qrcode.js';
import { styled } from './styled.js';
import { createFrames, createImgSize } from './util.js';
const DEFAULT_FRAME_DELAY = 2750;
const TIMER_INC = 500;
function getDataUrl(value) {
    const qr = qrcode(0, 'M');
    // HACK See our qrcode stringToBytes override as used internally. This
    // will only work for the case where we actually pass `Bytes` in here
    qr.addData(value, 'Byte');
    qr.make();
    return qr.createDataURL(16, 0);
}
function Display({ className = '', size, skipEncoding, style = {}, timerDelay = DEFAULT_FRAME_DELAY, value }) {
    const [{ image }, setFrameState] = useState({ frameIdx: 0, frames: [], image: null, valueHash: null });
    const timerRef = useRef({ timerDelay, timerId: null });
    const containerStyle = useMemo(() => createImgSize(size), [size]);
    // run on initial load to setup the global timer and provide and unsubscribe
    useEffect(() => {
        const nextFrame = () => setFrameState((state) => {
            // when we have a single frame, we only ever fire once
            if (state.frames.length <= 1) {
                return state;
            }
            let frameIdx = state.frameIdx + 1;
            // when we overflow, skip to the first and slightly increase the delay between frames
            if (frameIdx === state.frames.length) {
                frameIdx = 0;
                timerRef.current.timerDelay = timerRef.current.timerDelay + TIMER_INC;
            }
            // only encode the frames on demand, not above as part of the
            // state derivation - in the case of large payloads, this should
            // be slightly more responsive on initial load
            const newState = objectSpread({}, state, {
                frameIdx,
                image: getDataUrl(state.frames[frameIdx])
            });
            // set the new timer last
            timerRef.current.timerId = setTimeout(nextFrame, timerRef.current.timerDelay);
            return newState;
        });
        timerRef.current.timerId = setTimeout(nextFrame, timerRef.current.timerDelay);
        return () => {
            // eslint-disable-next-line react-hooks/exhaustive-deps
            timerRef.current.timerId && clearTimeout(timerRef.current.timerId);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    useEffect(() => {
        setFrameState((state) => {
            const valueHash = xxhashAsHex(value);
            if (valueHash === state.valueHash) {
                return state;
            }
            const frames = skipEncoding
                ? [value]
                : createFrames(value);
            // encode on demand
            return {
                frameIdx: 0,
                frames,
                image: getDataUrl(frames[0]),
                valueHash
            };
        });
    }, [skipEncoding, value]);
    if (!image) {
        return null;
    }
    return (_jsx(StyledDiv, { className: className, style: containerStyle, children: _jsx("div", { className: 'ui--qr-Display', style: style, children: _jsx("img", { src: image }) }) }));
}
const StyledDiv = styled.div `
  .ui--qr-Display {
    height: 100%;
    width: 100%;

    img,
    svg {
      background: white;
      height: auto !important;
      max-height: 100%;
      max-width: 100%;
      width: auto !important;
    }
  }
`;
export const QrDisplay = React.memo(Display);
