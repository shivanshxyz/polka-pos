"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LRUCache = exports.DEFAULT_TTL = exports.DEFAULT_CAPACITY = void 0;
exports.DEFAULT_CAPACITY = 1024;
exports.DEFAULT_TTL = 30000;
class LRUNode {
    key;
    __internal__expires;
    __internal__ttl;
    createdAt;
    next;
    prev;
    constructor(key, ttl) {
        this.key = key;
        this.__internal__ttl = ttl;
        this.__internal__expires = Date.now() + ttl;
        this.createdAt = Date.now();
        this.next = this.prev = this;
    }
    refresh() {
        this.__internal__expires = Date.now() + this.__internal__ttl;
    }
    get expiry() {
        return this.__internal__expires;
    }
}
class LRUCache {
    capacity;
    __internal__data = new Map();
    __internal__refs = new Map();
    __internal__length = 0;
    __internal__head;
    __internal__tail;
    __internal__ttl;
    constructor(capacity = exports.DEFAULT_CAPACITY, ttl = exports.DEFAULT_TTL) {
        this.capacity = capacity;
        this.__internal__ttl = ttl;
        this.__internal__head = this.__internal__tail = new LRUNode('<empty>', ttl);
    }
    get ttl() {
        return this.__internal__ttl;
    }
    get length() {
        return this.__internal__length;
    }
    get lengthData() {
        return this.__internal__data.size;
    }
    get lengthRefs() {
        return this.__internal__refs.size;
    }
    entries() {
        const keys = this.keys();
        const count = keys.length;
        const entries = new Array(count);
        for (let i = 0; i < count; i++) {
            const key = keys[i];
            entries[i] = [key, this.__internal__data.get(key)];
        }
        return entries;
    }
    keys() {
        const keys = [];
        if (this.__internal__length) {
            let curr = this.__internal__head;
            while (curr !== this.__internal__tail) {
                keys.push(curr.key);
                curr = curr.next;
            }
            keys.push(curr.key);
        }
        return keys;
    }
    get(key) {
        const data = this.__internal__data.get(key);
        if (data) {
            this.__internal__toHead(key);
            // Evict TTL once data is refreshed
            this.__internal__evictTTL();
            return data;
        }
        this.__internal__evictTTL();
        return null;
    }
    set(key, value) {
        if (this.__internal__data.has(key)) {
            this.__internal__toHead(key);
        }
        else {
            const node = new LRUNode(key, this.__internal__ttl);
            this.__internal__refs.set(node.key, node);
            if (this.length === 0) {
                this.__internal__head = this.__internal__tail = node;
            }
            else {
                this.__internal__head.prev = node;
                node.next = this.__internal__head;
                this.__internal__head = node;
            }
            if (this.__internal__length === this.capacity) {
                this.__internal__data.delete(this.__internal__tail.key);
                this.__internal__refs.delete(this.__internal__tail.key);
                this.__internal__tail = this.__internal__tail.prev;
                this.__internal__tail.next = this.__internal__head;
            }
            else {
                this.__internal__length += 1;
            }
        }
        // Evict TTL once data is refreshed or added
        this.__internal__evictTTL();
        this.__internal__data.set(key, value);
    }
    __internal__evictTTL() {
        // Find last node to keep
        // traverse map to find the expired nodes
        while (this.__internal__tail.expiry && this.__internal__tail.expiry < Date.now() && this.__internal__length > 0) {
            this.__internal__refs.delete(this.__internal__tail.key);
            this.__internal__data.delete(this.__internal__tail.key);
            this.__internal__length -= 1;
            this.__internal__tail = this.__internal__tail.prev;
            this.__internal__tail.next = this.__internal__head;
        }
        if (this.__internal__length === 0) {
            this.__internal__head = this.__internal__tail = new LRUNode('<empty>', this.__internal__ttl);
        }
    }
    __internal__toHead(key) {
        const ref = this.__internal__refs.get(key);
        if (ref && ref !== this.__internal__head) {
            ref.refresh();
            ref.prev.next = ref.next;
            ref.next.prev = ref.prev;
            ref.next = this.__internal__head;
            this.__internal__head.prev = ref;
            this.__internal__head = ref;
        }
    }
}
exports.LRUCache = LRUCache;
