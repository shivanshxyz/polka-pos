{"version":3,"file":"ink-client.mjs","sources":["../../src/ink-client.ts"],"sourcesContent":["import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { getInkDynamicBuilder, InkDynamicBuilder } from \"./dynamic-builders\"\nimport { getInkLookup, InkMetadataLookup } from \"./get-lookup\"\nimport {\n  Event,\n  InkCallableDescriptor,\n  InkDescriptors,\n  InkStorageDescriptor,\n} from \"./ink-descriptors\"\nimport { ConstructorSpec, EventSpecV5, MessageSpec } from \"./metadata-types\"\n\nexport type InkCallableInterface<T extends InkCallableDescriptor> = <\n  L extends string & keyof T,\n>(\n  label: L,\n) => {\n  encode: {} extends T[L][\"message\"]\n    ? (value?: T[L][\"message\"]) => Binary\n    : (value: T[L][\"message\"]) => Binary\n  decode: (value: { data: Binary }) => T[L][\"response\"]\n  attributes: {\n    payable: boolean\n    default: boolean\n    mutates: boolean\n  }\n}\n\nexport type InkStorageInterface<S extends InkStorageDescriptor> =\n  (\"\" extends keyof S\n    ? () => {\n        encode: S[\"\"][\"key\"] extends undefined\n          ? (key?: undefined) => Binary\n          : (key: S[\"\"][\"key\"]) => Binary\n        decode: (data: Binary) => S[\"\"][\"value\"]\n      }\n    : unknown) &\n    (<L extends string & keyof S>(\n      label: L,\n    ) => {\n      encode: S[L][\"key\"] extends undefined\n        ? (key?: undefined) => Binary\n        : (key: S[L][\"key\"]) => Binary\n      decode: (data: Binary) => S[L][\"value\"]\n    })\n\nexport type GenericEvent =\n  | {\n      type: \"Contracts\"\n      value:\n        | {\n            type: \"ContractEmitted\"\n            value: {\n              contract: string\n              data: Binary\n            }\n          }\n        | { type: string; value: unknown }\n    }\n  | { type: string; value: unknown }\nexport interface InkEventInterface<E> {\n  decode: (value: { data: Binary }, signatureTopic?: string) => E\n  filter: (\n    address: string,\n    events?: Array<\n      | { event: GenericEvent; topics: Binary[] }\n      | (GenericEvent & { topics: Binary[] })\n    >,\n  ) => E[]\n}\n\ntype HasDefault<T> = \"default\" extends keyof T\n  ? T[\"default\"] extends true\n    ? true\n    : false\n  : false\ntype GetDefault<M> = keyof {\n  [K in keyof M as HasDefault<M[K]> extends true ? K : never]: true\n}\n\n// T can be the default message or `never`.\n// Typescript doesn't like doing `extends never` (it works for the \"false\" case, but for the other it will always give back never)\n// One way of running around it is by checking whether an empty object extends an object with that key.\ntype WrapDefault<T extends string> = {} extends {\n  [K in T]: K\n}\n  ? string | undefined\n  : T\n\nexport interface InkClient<\n  D extends InkDescriptors<\n    InkStorageDescriptor,\n    InkCallableDescriptor,\n    InkCallableDescriptor,\n    Event\n  >,\n> {\n  constructor: InkCallableInterface<D[\"__types\"][\"constructors\"]>\n  defaultConstructor: WrapDefault<GetDefault<D[\"__types\"][\"constructors\"]>>\n  message: InkCallableInterface<D[\"__types\"][\"messages\"]>\n  defaultMessage: WrapDefault<GetDefault<D[\"__types\"][\"messages\"]>>\n  storage: InkStorageInterface<D[\"__types\"][\"storage\"]>\n  event: InkEventInterface<D[\"__types\"][\"event\"]>\n}\n\nexport const getInkClient = <\n  D extends InkDescriptors<\n    InkStorageDescriptor,\n    InkCallableDescriptor,\n    InkCallableDescriptor,\n    Event\n  >,\n>(\n  inkContract: D,\n): InkClient<D> => {\n  const lookup = getInkLookup(inkContract.metadata)\n  const builder = getInkDynamicBuilder(lookup)\n\n  const constructorCodec = buildCallable(builder.buildConstructor)\n  const messageCodec = buildCallable(builder.buildMessage)\n\n  const findConstructor = (label: string) => {\n    const result = lookup.metadata.spec.constructors.find(\n      (c) => c.label === label,\n    )\n    if (!result) {\n      throw new Error(`Constructor ${label} not found`)\n    }\n    return result\n  }\n  const findMessage = (label: string) => {\n    const result = lookup.metadata.spec.messages.find((c) => c.label === label)\n    if (!result) {\n      throw new Error(`Message ${label} not found`)\n    }\n    return result\n  }\n\n  const defaultConstructor: any = lookup.metadata.spec.constructors.find(\n    (c) => c.default,\n  )?.label\n  const defaultMessage: any = lookup.metadata.spec.messages.find(\n    (c) => c.default,\n  )?.label\n\n  return {\n    constructor: (label) => ({\n      attributes: getAttributes(findConstructor(label)),\n      ...constructorCodec(label),\n    }),\n    defaultConstructor,\n    message: (label) => ({\n      attributes: getAttributes(findMessage(label)),\n      ...messageCodec(label),\n    }),\n    defaultMessage,\n    storage: buildStorage(builder.buildStorage),\n    event:\n      Number(lookup.metadata.version) === 4\n        ? buildEventV4(builder.buildEvents)\n        : buildEventV5(lookup, builder.buildEvent),\n  }\n}\n\nconst getAttributes = (spec: ConstructorSpec | MessageSpec) => ({\n  payable: spec.payable,\n  default: spec.default,\n  mutates: \"mutates\" in spec ? spec.mutates : true,\n})\n\nconst buildCallable =\n  <T extends InkCallableDescriptor>(\n    builder:\n      | InkDynamicBuilder[\"buildConstructor\"]\n      | InkDynamicBuilder[\"buildMessage\"],\n  ) =>\n  <L extends string & keyof T>(label: L) => {\n    const codecs = builder(label)\n\n    return {\n      encode: (value?: T[L][\"message\"]) =>\n        Binary.fromBytes(codecs.call.enc(value || {})),\n      decode: (response: { data: Binary }) =>\n        codecs.value.dec(response.data.asBytes()),\n    }\n  }\n\nconst buildStorage =\n  <S extends InkStorageDescriptor>(\n    builder: InkDynamicBuilder[\"buildStorage\"],\n  ): InkStorageInterface<S> =>\n  <L extends string & keyof S>(label?: L) => {\n    const codecs = builder(label)\n\n    return {\n      encode: (key?: S[L][\"key\"]) =>\n        Binary.fromBytes(codecs.key.enc(key as any)),\n      decode: (response: Binary) => codecs.value.dec(response.asBytes()),\n    }\n  }\n\nconst buildEventV4 = <E extends Event>(\n  eventsDecoder: InkDynamicBuilder[\"buildEvents\"],\n): InkEventInterface<E> => {\n  const decode: InkEventInterface<E>[\"decode\"] = (value) => {\n    return eventsDecoder().dec(value.data.asBytes()) as E\n  }\n  const filter: InkEventInterface<E>[\"filter\"] = (address, events = []) => {\n    const contractEvents = events\n      .map((v) => (\"event\" in v ? v.event : v))\n      .filter(\n        (v: any) =>\n          v.type === \"Contracts\" &&\n          v.value.type === \"ContractEmitted\" &&\n          v.value.value.contract === address,\n      )\n    return contractEvents.map((v: any) => {\n      try {\n        return decode(v.value.value)\n      } catch (ex) {\n        console.error(\n          `Contract ${address} emitted an incompatible event`,\n          v.value.value,\n        )\n        throw ex\n      }\n    })\n  }\n  return { decode, filter }\n}\n\nconst buildEventV5 = <E extends Event>(\n  lookup: InkMetadataLookup,\n  eventDecoder: InkDynamicBuilder[\"buildEvent\"],\n): InkEventInterface<E> => {\n  const metadataEventTopics = new Set(\n    lookup.metadata.spec.events\n      .map((evt) => (evt as EventSpecV5).signature_topic)\n      .filter((v) => v != null),\n  )\n  const hasAnonymousEvents = lookup.metadata.spec.events.some(\n    (evt) => (evt as EventSpecV5).signature_topic == null,\n  )\n\n  const decode: InkEventInterface<E>[\"decode\"] = (value, signatureTopic) => {\n    if (signatureTopic != null) {\n      if (!metadataEventTopics.has(signatureTopic)) {\n        throw new Error(`Event with signature topic ${value} not found`)\n      }\n      return eventDecoder(signatureTopic)!.dec(value.data.asBytes()) as E\n    }\n    if (!hasAnonymousEvents) {\n      throw new Error(\"Event signature topic required\")\n    }\n    return eventDecoder(undefined)!.dec(value.data.asBytes()) as E\n  }\n  const filter: InkEventInterface<E>[\"filter\"] = (address, events = []) => {\n    const contractEvents = events\n      .map((v) => (\"event\" in v ? v : { event: v, topics: v.topics }))\n      .filter(\n        (v) =>\n          v.event.type === \"Contracts\" &&\n          (v.event.value as any).type === \"ContractEmitted\" &&\n          (v.event.value as any).value.contract === address,\n      )\n\n    return contractEvents\n      .map((v) => {\n        const eventTopics = v.topics.map((evt) => evt.asHex())\n        const suitableTopic = eventTopics.find((topic) =>\n          metadataEventTopics.has(topic),\n        )\n        try {\n          return decode((v.event.value as any).value, suitableTopic)\n        } catch (ex) {\n          console.error(`Contract ${address} emitted an incompatible event`, {\n            event: (v.event.value as any).value.data.asHex(),\n            eventTopics,\n            metadataEventTopics: [...metadataEventTopics],\n            hasAnonymousEvents,\n          })\n          return null\n        }\n      })\n      .filter((v) => v !== null)\n  }\n\n  return {\n    decode,\n    filter,\n  }\n}\n"],"names":[],"mappings":"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"}