import { Vector, Tuple, str, compactNumber, Variant, _void, Self, Struct, Option } from '@polkadot-api/substrate-bindings';

const smallCompact = compactNumber;
const StructCodec = Vector(Tuple(str, smallCompact));
const Primitive = {
  bool: "boolean",
  str: "string",
  num: "number",
  big: "bigint",
  bits: "bitseq",
  void: "void"
};
const TerminalCodec = Variant(
  Object.fromEntries(
    Object.values(Primitive).map((p) => [p, _void])
  )
);
const EnumCodec = Vector(
  Tuple(
    str,
    Variant({
      inline: Self(() => TypedefCodec),
      lookup: smallCompact
    })
  )
);
const TupleCodec = Vector(smallCompact);
const ArrayCodec = Struct({
  typeRef: smallCompact,
  length: Option(smallCompact)
});
const BinaryCodec = Option(smallCompact);
const OptionCodec = smallCompact;
const ResultCodec = Struct({
  ok: smallCompact,
  ko: smallCompact
});
const TypedefCodec = Variant({
  struct: StructCodec,
  terminal: TerminalCodec,
  enum: EnumCodec,
  tuple: TupleCodec,
  array: ArrayCodec,
  binary: BinaryCodec,
  option: OptionCodec,
  result: ResultCodec
});
const primitiveToTerminal = {
  i256: Primitive.big,
  i128: Primitive.big,
  i64: Primitive.big,
  i32: Primitive.num,
  i16: Primitive.num,
  i8: Primitive.num,
  u256: Primitive.big,
  u128: Primitive.big,
  u64: Primitive.big,
  u32: Primitive.num,
  u16: Primitive.num,
  u8: Primitive.num,
  bool: Primitive.bool,
  char: Primitive.str,
  str: Primitive.str
};
const terminal = (type) => ({
  type: "terminal",
  value: { type }
});
function mapLookupToTypedef(entry, resolve = () => {
}) {
  switch (entry.type) {
    case "AccountId20":
    case "AccountId32":
      return terminal(Primitive.str);
    case "array":
      if (entry.value.type === "primitive" && entry.value.value === "u8") {
        return { type: "binary", value: entry.len };
      }
      resolve(entry.value.id);
      return {
        type: "array",
        value: {
          typeRef: entry.value.id,
          length: entry.len
        }
      };
    case "bitSequence":
      return terminal(Primitive.bits);
    case "compact":
      return terminal(entry.isBig ? Primitive.big : Primitive.num);
    case "enum":
      return {
        type: "enum",
        value: Object.entries(entry.value).map(
          ([key, params]) => {
            if (params.type !== "lookupEntry")
              return [
                key,
                { type: "inline", value: mapLookupToTypedef(params, resolve) }
              ];
            resolve(params.value.id);
            return [
              key,
              {
                type: "lookup",
                value: params.value.id
              }
            ];
          }
        )
      };
    case "struct": {
      const value = Object.entries(entry.value).map(
        ([key, prop]) => [key, prop.id]
      );
      value.forEach(([, v]) => resolve(v));
      return {
        type: "struct",
        value
      };
    }
    case "tuple": {
      const value = entry.value.map((v) => v.id);
      value.forEach(resolve);
      return {
        type: "tuple",
        value
      };
    }
    case "option":
      resolve(entry.value.id);
      return {
        type: "option",
        value: entry.value.id
      };
    case "primitive":
      return terminal(primitiveToTerminal[entry.value]);
    case "result":
      resolve(entry.value.ok.id);
      resolve(entry.value.ko.id);
      return {
        type: "result",
        value: {
          ok: entry.value.ok.id,
          ko: entry.value.ko.id
        }
      };
    case "sequence":
      if (entry.value.type === "primitive" && entry.value.value === "u8") {
        return { type: "binary", value: void 0 };
      }
      resolve(entry.value.id);
      return {
        type: "array",
        value: { typeRef: entry.value.id }
      };
    case "void":
      return terminal(Primitive.void);
  }
}
function mapReferences(node, mapFn) {
  switch (node.type) {
    case "array":
      return {
        ...node,
        value: {
          ...node.value,
          typeRef: mapFn(node.value.typeRef)
        }
      };
    case "option":
      return { ...node, value: mapFn(node.value) };
    case "result":
      return {
        ...node,
        value: { ok: mapFn(node.value.ok), ko: mapFn(node.value.ko) }
      };
    case "tuple":
      return { ...node, value: node.value.map(mapFn) };
    case "struct":
      return {
        ...node,
        value: node.value.map(([k, v]) => [k, mapFn(v)])
      };
    case "enum": {
      return {
        ...node,
        value: node.value.map(([k, { type, value }]) => [
          k,
          type === "lookup" ? { type, value: mapFn(value) } : { type, value: mapReferences(value, mapFn) }
        ])
      };
    }
    case "binary":
    case "terminal":
      return node;
  }
}

export { Primitive, TypedefCodec, mapLookupToTypedef, mapReferences };
//# sourceMappingURL=typedef.mjs.map
