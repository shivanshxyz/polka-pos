// node_modules/.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.4/node_modules/@polkadot-api/json-rpc-provider-proxy/dist/esm/json-rpc-message.mjs
var jsonRpcMsg = (msg) => JSON.stringify({
  jsonrpc: "2.0",
  ...msg
});

// node_modules/.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.4/node_modules/@polkadot-api/json-rpc-provider-proxy/dist/esm/get-proxy.mjs
var unfollowMethods = new Set(
  ["v1", "unstable"].map((x) => `chainHead_${x}_unfollow`)
);
var getProxy = (toConsumer) => {
  let state = {
    type: 1,
    pending: []
  };
  const onMsgFromProvider = (msg) => {
    var _a;
    if (state.type === 0) {
      const parsed = JSON.parse(msg);
      if ("id" in parsed) {
        if ("result" in parsed && ((_a = state.onGoingRequests.get(parsed.id)) == null ? void 0 : _a.type) === 0)
          state.activeChainHeads.add(parsed.result);
        state.onGoingRequests.delete(parsed.id);
      } else if ("params" in parsed) {
        const { subscription, result } = parsed.params;
        if ((result == null ? void 0 : result.event) === "stop")
          state.activeChainHeads.delete(subscription);
      }
    }
    if (state.type !== 2) toConsumer(msg);
  };
  const send = (msg) => {
    if (state.type === 2) return;
    if (state.type === 1) {
      state.pending.push(msg);
      return;
    }
    const parsed = JSON.parse(msg);
    if (unfollowMethods.has(parsed.method))
      state.activeChainHeads.delete(parsed.params[0]);
    if ("id" in parsed) {
      const { method, id } = parsed;
      const ongoingMsg = method.startsWith("chainHead") ? method.endsWith("follow") ? {
        type: 0,
        msg
      } : { type: 1, id } : { type: 2, msg };
      state.onGoingRequests.set(id, ongoingMsg);
    }
    state.connection.send(msg);
  };
  return {
    send,
    disconnect: () => {
      if (state.type === 2) return;
      if (state.type === 0) state.connection.disconnect();
      state = {
        type: 2
        /* Done */
      };
    },
    connect: (cb) => {
      if (state.type !== 1) throw new Error("Nonesense");
      const { pending } = state;
      const onGoingRequests = /* @__PURE__ */ new Map();
      const activeChainHeads = /* @__PURE__ */ new Set();
      const onHalt = () => {
        state = {
          type: 1,
          pending: []
        };
        activeChainHeads.forEach((subscription) => {
          onMsgFromProvider(
            jsonRpcMsg({
              params: {
                subscription,
                result: {
                  event: "stop",
                  internal: true
                }
              }
            })
          );
        });
        activeChainHeads.clear();
        for (const x of onGoingRequests.values()) {
          if (x.type === 1)
            onMsgFromProvider(
              jsonRpcMsg({
                id: x.id,
                error: { code: -32603, message: "Internal error" },
                internal: true
              })
            );
          else send(x.msg);
        }
        onGoingRequests.clear();
      };
      state = {
        type: 0,
        connection: cb(onMsgFromProvider, onHalt),
        onGoingRequests,
        activeChainHeads
      };
      pending.forEach(send);
    }
  };
};

// node_modules/.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.4/node_modules/@polkadot-api/json-rpc-provider-proxy/dist/esm/get-sync-provider.mjs
var getSyncProvider = (input) => (onMessage) => {
  let proxy = getProxy(onMessage);
  const start = () => {
    input().then(
      (cb) => {
        if (!proxy) {
          try {
            cb(
              () => {
              },
              () => {
              }
            ).disconnect();
          } catch (_) {
          }
        } else
          proxy.connect(
            (onMsg, onHalt) => cb(onMsg, () => {
              onHalt();
              start();
            })
          );
      },
      () => {
        proxy && setTimeout(start, 0);
      }
    );
  };
  start();
  return {
    send: (msg) => {
      proxy == null ? void 0 : proxy.send(msg);
    },
    disconnect: () => {
      proxy == null ? void 0 : proxy.disconnect();
      proxy = null;
    }
  };
};

export {
  getSyncProvider
};
//# sourceMappingURL=chunk-NUCDN3S3.js.map
