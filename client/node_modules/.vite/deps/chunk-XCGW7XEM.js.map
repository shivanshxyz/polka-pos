{
  "version": 3,
  "sources": ["../../.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/public-types.js", "../../.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/internals/buffer.js", "../../.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/internals/local-instance.js", "../../.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/internals/remote-instance.js", "../../.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/internals/client.js", "../../.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/no-auto-bytecode-browser.js"],
  "sourcesContent": ["// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n/**\n * Thrown in case of a problem when initializing the chain.\n */\nexport class AddChainError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"AddChainError\";\n    }\n}\n/**\n * Thrown in case the API user tries to use a chain or client that has already been destroyed.\n */\nexport class AlreadyDestroyedError extends Error {\n    constructor() {\n        super();\n        this.name = \"AlreadyDestroyedError\";\n    }\n}\n/**\n * Thrown when trying to send a JSON-RPC message to a chain whose JSON-RPC system hasn't been\n * enabled.\n */\nexport class JsonRpcDisabledError extends Error {\n    constructor() {\n        super();\n        this.name = \"JsonRpcDisabledError\";\n    }\n}\n/**\n * Thrown in case the underlying client encounters an unexpected crash.\n *\n * This is always an internal bug in smoldot and is never supposed to happen.\n */\nexport class CrashError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\n/**\n * Thrown in case the buffer of JSON-RPC requests is full and cannot accept any more request.\n */\nexport class QueueFullError extends Error {\n    constructor() {\n        super(\"JSON-RPC requests queue is full\");\n    }\n}\n", "// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\nexport function utf8BytesToString(buffer, offset, length) {\n    checkRange(buffer, offset, length);\n    // The `TextDecoder` API is supported by all major browsers and by NodeJS.\n    // <https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder>\n    return new TextDecoder().decode(buffer.slice(offset, offset + length));\n}\nexport function readUInt8(buffer, offset) {\n    checkRange(buffer, offset, 1);\n    return buffer[offset];\n}\nexport function readUInt16BE(buffer, offset) {\n    checkRange(buffer, offset, 2);\n    return ((buffer[offset] << 8) | buffer[offset + 1]);\n}\nexport function readUInt32LE(buffer, offset) {\n    checkRange(buffer, offset, 4);\n    return (buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16)) + (buffer[offset + 3] * 0x1000000);\n}\n/**\n * Sets the value of a given byte in the buffer.\n *\n * This function is equivalent to `buffer[offset] = value`, except that an exception is thrown\n * if `offset` is out of range.\n */\nexport function writeUInt8(buffer, offset, value) {\n    checkRange(buffer, offset, 1);\n    buffer[offset] = value & 0xff;\n}\nexport function writeUInt32LE(buffer, offset, value) {\n    checkRange(buffer, offset, 4);\n    buffer[offset + 3] = (value >>> 24) & 0xff;\n    buffer[offset + 2] = (value >>> 16) & 0xff;\n    buffer[offset + 1] = (value >>> 8) & 0xff;\n    buffer[offset] = value & 0xff;\n}\nexport function writeUInt64LE(buffer, offset, value) {\n    checkRange(buffer, offset, 8);\n    buffer[offset + 7] = Number((value >> BigInt(56)) & BigInt(0xff));\n    buffer[offset + 6] = Number((value >> BigInt(48)) & BigInt(0xff));\n    buffer[offset + 5] = Number((value >> BigInt(40)) & BigInt(0xff));\n    buffer[offset + 4] = Number((value >> BigInt(32)) & BigInt(0xff));\n    buffer[offset + 3] = Number((value >> BigInt(24)) & BigInt(0xff));\n    buffer[offset + 2] = Number((value >> BigInt(16)) & BigInt(0xff));\n    buffer[offset + 1] = Number((value >> BigInt(8)) & BigInt(0xff));\n    buffer[offset] = Number(value & BigInt(0xff));\n}\nfunction checkRange(buffer, offset, length) {\n    if (!Number.isInteger(offset) || offset < 0)\n        throw new RangeError();\n    if (offset + length > buffer.length)\n        throw new RangeError();\n}\n", "// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport * as buffer from './buffer.js';\n/**\n * Starts a new instance using the given configuration.\n *\n * Even though this function doesn't do anything asynchronous, it needs to be asynchronous due to\n * the fact that `WebAssembly.instantiate` is for some reason asynchronous.\n *\n * After this function returns, the execution of CPU-heavy tasks of smoldot will happen\n * asynchronously in the background.\n *\n * This instance is low-level in the sense that invalid input can lead to crashes and that input\n * isn't sanitized. In other words, you know what you're doing.\n */\nexport function startLocalInstance(config, wasmModule, eventCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const state = {\n            instance: null,\n            currentTask: null,\n            bufferIndices: new Array(),\n            advanceExecutionPromise: null,\n            onShutdownExecutorOrWasmPanic: () => { }\n        };\n        const smoldotJsBindings = {\n            // Must exit with an error. A human-readable message can be found in the WebAssembly\n            // memory in the given buffer.\n            panic: (ptr, len) => {\n                const instance = state.instance;\n                state.instance = null;\n                ptr >>>= 0;\n                len >>>= 0;\n                const message = buffer.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), ptr, len);\n                eventCallback({ ty: \"wasm-panic\", message, currentTask: state.currentTask });\n                state.onShutdownExecutorOrWasmPanic();\n                state.onShutdownExecutorOrWasmPanic = () => { };\n                throw new Error();\n            },\n            chain_initialized: (chainId, errorMsgPtr, errorMsgLen) => {\n                const instance = state.instance;\n                const mem = new Uint8Array(instance.exports.memory.buffer);\n                errorMsgPtr >>>= 0;\n                errorMsgLen >>>= 0;\n                if (errorMsgPtr === 0) {\n                    eventCallback({ ty: \"add-chain-result\", chainId, success: true });\n                }\n                else {\n                    const errorMsg = buffer.utf8BytesToString(mem, errorMsgPtr, errorMsgLen);\n                    eventCallback({ ty: \"add-chain-result\", chainId, success: false, error: errorMsg });\n                }\n            },\n            random_get: (ptr, len) => {\n                const instance = state.instance;\n                ptr >>>= 0;\n                len >>>= 0;\n                const baseBuffer = new Uint8Array(instance.exports.memory.buffer)\n                    .subarray(ptr, ptr + len);\n                for (let iter = 0; iter < len; iter += 65536) {\n                    // `baseBuffer.subarray` automatically saturates at the end of the buffer\n                    config.getRandomValues(baseBuffer.subarray(iter, iter + 65536));\n                }\n            },\n            unix_timestamp_us: () => {\n                const value = Math.floor(Date.now());\n                if (value < 0)\n                    throw new Error(\"UNIX timestamp inferior to 0\");\n                return BigInt(value) * BigInt(1000);\n            },\n            monotonic_clock_us: () => {\n                const nowMs = config.performanceNow();\n                const nowMsInt = Math.floor(nowMs);\n                const now = BigInt(nowMsInt) * BigInt(1000) +\n                    BigInt(Math.floor(((nowMs - nowMsInt) * 1000)));\n                return now;\n            },\n            buffer_size: (bufferIndex) => {\n                const buf = state.bufferIndices[bufferIndex];\n                return buf.byteLength;\n            },\n            buffer_copy: (bufferIndex, targetPtr) => {\n                const instance = state.instance;\n                targetPtr = targetPtr >>> 0;\n                const buf = state.bufferIndices[bufferIndex];\n                new Uint8Array(instance.exports.memory.buffer).set(buf, targetPtr);\n            },\n            advance_execution_ready: () => {\n                if (state.advanceExecutionPromise)\n                    state.advanceExecutionPromise();\n                state.advanceExecutionPromise = null;\n            },\n            // Used by the Rust side to notify that a JSON-RPC response or subscription notification\n            // is available in the queue of JSON-RPC responses.\n            json_rpc_responses_non_empty: (chainId) => {\n                eventCallback({ ty: \"json-rpc-responses-non-empty\", chainId });\n            },\n            // Used by the Rust side to emit a log entry.\n            // See also the `max_log_level` parameter in the configuration.\n            log: (level, targetPtr, targetLen, messagePtr, messageLen) => {\n                const instance = state.instance;\n                targetPtr >>>= 0;\n                targetLen >>>= 0;\n                messagePtr >>>= 0;\n                messageLen >>>= 0;\n                const mem = new Uint8Array(instance.exports.memory.buffer);\n                let target = buffer.utf8BytesToString(mem, targetPtr, targetLen);\n                let message = buffer.utf8BytesToString(mem, messagePtr, messageLen);\n                eventCallback({ ty: \"log\", level, message, target });\n            },\n            // Must call `timer_finished` after the given number of milliseconds has elapsed.\n            start_timer: (ms) => {\n                const instance = state.instance;\n                // In both NodeJS and browsers, if `setTimeout` is called with a value larger than\n                // 2147483647, the delay is for some reason instead set to 1.\n                // As mentioned in the documentation of `start_timer`, it is acceptable to end the\n                // timer before the given number of milliseconds has passed.\n                if (ms > 2147483647)\n                    ms = 2147483647;\n                // In browsers, `setTimeout` works as expected when `ms` equals 0. However, NodeJS\n                // requires a minimum of 1 millisecond (if `0` is passed, it is automatically replaced\n                // with `1`) and wants you to use `setImmediate` instead.\n                if (ms < 1 && typeof setImmediate === \"function\") {\n                    setImmediate(() => {\n                        if (!state.instance)\n                            return;\n                        try {\n                            instance.exports.timer_finished();\n                        }\n                        catch (_error) { }\n                    });\n                }\n                else {\n                    setTimeout(() => {\n                        if (!state.instance)\n                            return;\n                        try {\n                            instance.exports.timer_finished();\n                        }\n                        catch (_error) { }\n                    }, ms);\n                }\n            },\n            // Must indicate whether the given connection type is supported.\n            connection_type_supported: (ty) => {\n                // TODO: consider extracting config options so user can't change the fields dynamically\n                switch (ty) {\n                    case 0:\n                    case 1:\n                    case 2: {\n                        return config.forbidTcp ? 0 : 1;\n                    }\n                    case 4:\n                    case 5:\n                    case 6: {\n                        return (config.forbidWs || config.forbidNonLocalWs) ? 0 : 1;\n                    }\n                    case 7: {\n                        return config.forbidWs ? 0 : 1;\n                    }\n                    case 14: {\n                        return config.forbidWss ? 0 : 1;\n                    }\n                    case 16:\n                    case 17: {\n                        return config.forbidWebRtc ? 0 : 1;\n                    }\n                    default:\n                        // Indicates a bug somewhere.\n                        throw new Error(\"Invalid connection type passed to `connection_type_supported`\");\n                }\n            },\n            // Must create a new connection object. This implementation stores the created object in\n            // `connections`.\n            connection_new: (connectionId, addrPtr, addrLen) => {\n                const instance = state.instance;\n                const mem = new Uint8Array(instance.exports.memory.buffer);\n                addrPtr >>>= 0;\n                addrLen >>>= 0;\n                let address;\n                switch (buffer.readUInt8(mem, addrPtr)) {\n                    case 0:\n                    case 1:\n                    case 2: {\n                        const port = buffer.readUInt16BE(mem, addrPtr + 1);\n                        const hostname = buffer.utf8BytesToString(mem, addrPtr + 3, addrLen - 3);\n                        address = { ty: \"tcp\", port, hostname };\n                        break;\n                    }\n                    case 4:\n                    case 6: {\n                        const port = buffer.readUInt16BE(mem, addrPtr + 1);\n                        const hostname = buffer.utf8BytesToString(mem, addrPtr + 3, addrLen - 3);\n                        address = { ty: \"websocket\", url: \"ws://\" + hostname + \":\" + port };\n                        break;\n                    }\n                    case 5: {\n                        const port = buffer.readUInt16BE(mem, addrPtr + 1);\n                        const hostname = buffer.utf8BytesToString(mem, addrPtr + 3, addrLen - 3);\n                        address = { ty: \"websocket\", url: \"ws://[\" + hostname + \"]:\" + port };\n                        break;\n                    }\n                    case 14: {\n                        const port = buffer.readUInt16BE(mem, addrPtr + 1);\n                        const hostname = buffer.utf8BytesToString(mem, addrPtr + 3, addrLen - 3);\n                        address = { ty: \"websocket\", url: \"wss://\" + hostname + \":\" + port };\n                        break;\n                    }\n                    case 16: {\n                        const targetPort = buffer.readUInt16BE(mem, addrPtr + 1);\n                        const remoteTlsCertificateSha256 = mem.slice(addrPtr + 3, addrPtr + 35);\n                        const targetIp = buffer.utf8BytesToString(mem, addrPtr + 35, addrLen - 35);\n                        address = { ty: \"webrtc\", ipVersion: '4', remoteTlsCertificateSha256, targetIp, targetPort };\n                        break;\n                    }\n                    case 17: {\n                        const targetPort = buffer.readUInt16BE(mem, addrPtr + 1);\n                        const remoteTlsCertificateSha256 = mem.slice(addrPtr + 3, addrPtr + 35);\n                        const targetIp = buffer.utf8BytesToString(mem, addrPtr + 35, addrLen - 35);\n                        address = { ty: \"webrtc\", ipVersion: '6', remoteTlsCertificateSha256, targetIp, targetPort };\n                        break;\n                    }\n                    default:\n                        // Indicates a bug somewhere.\n                        throw new Error(\"Invalid encoded address passed to `connection_new`\");\n                }\n                eventCallback({ ty: \"new-connection\", connectionId, address });\n            },\n            // Must close and destroy the connection object.\n            reset_connection: (connectionId) => {\n                eventCallback({ ty: \"connection-reset\", connectionId });\n            },\n            // Opens a new substream on a multi-stream connection.\n            connection_stream_open: (connectionId) => {\n                eventCallback({ ty: \"connection-stream-open\", connectionId });\n            },\n            // Closes a substream on a multi-stream connection.\n            connection_stream_reset: (connectionId, streamId) => {\n                eventCallback({ ty: \"connection-stream-reset\", connectionId, streamId });\n            },\n            // Must queue the data found in the WebAssembly memory at the given pointer. It is assumed\n            // that this function is called only when the connection is in an open state.\n            stream_send: (connectionId, streamId, ptr, len) => {\n                const instance = state.instance;\n                const mem = new Uint8Array(instance.exports.memory.buffer);\n                ptr >>>= 0;\n                len >>>= 0;\n                const data = new Array();\n                for (let i = 0; i < len; ++i) {\n                    const bufPtr = buffer.readUInt32LE(mem, ptr + 8 * i);\n                    const bufLen = buffer.readUInt32LE(mem, ptr + 8 * i + 4);\n                    data.push(mem.slice(bufPtr, bufPtr + bufLen));\n                }\n                // TODO: docs says the streamId is provided only for multi-stream connections, but here it's always provided\n                eventCallback({ ty: \"stream-send\", connectionId, streamId, data });\n            },\n            stream_send_close: (connectionId, streamId) => {\n                // TODO: docs says the streamId is provided only for multi-stream connections, but here it's always provided\n                eventCallback({ ty: \"stream-send-close\", connectionId, streamId });\n            },\n            current_task_entered: (ptr, len) => {\n                ptr >>>= 0;\n                len >>>= 0;\n                const taskName = buffer.utf8BytesToString(new Uint8Array(state.instance.exports.memory.buffer), ptr, len);\n                state.currentTask = taskName;\n            },\n            current_task_exit: () => {\n                state.currentTask = null;\n            }\n        };\n        // Start the Wasm virtual machine.\n        // The Rust code defines a list of imports that must be fulfilled by the environment. The second\n        // parameter provides their implementations.\n        const result = yield WebAssembly.instantiate(wasmModule, {\n            // The functions with the \"smoldot\" prefix are specific to smoldot.\n            \"smoldot\": smoldotJsBindings,\n        });\n        state.instance = result;\n        // Smoldot requires an initial call to the `init` function in order to do its internal\n        // configuration.\n        state.instance.exports.init(config.maxLogLevel);\n        // Promise that is notified when the `shutdownExecutor` function is called or when a Wasm\n        // panic happens.\n        const shutdownExecutorOrWasmPanicPromise = new Promise((resolve) => state.onShutdownExecutorOrWasmPanic = () => resolve(\"stop\"));\n        (() => __awaiter(this, void 0, void 0, function* () {\n            const cpuRateLimit = config.cpuRateLimit;\n            // In order to avoid calling `setTimeout` too often, we accumulate sleep up until\n            // a certain threshold.\n            let missingSleep = 0;\n            let now = config.performanceNow();\n            while (true) {\n                const whenReadyAgain = new Promise((resolve) => state.advanceExecutionPromise = () => resolve(\"ready\"));\n                if (!state.instance)\n                    break;\n                state.instance.exports.advance_execution();\n                const afterExec = config.performanceNow();\n                const elapsed = afterExec - now;\n                now = afterExec;\n                // In order to enforce the rate limiting, we stop executing for a certain\n                // amount of time.\n                // The base equation here is: `(sleep + elapsed) * rateLimit == elapsed`,\n                // from which the calculation below is derived.\n                const sleep = elapsed * (1.0 / cpuRateLimit - 1.0);\n                missingSleep += sleep;\n                if (missingSleep > 5) {\n                    // `setTimeout` has a maximum value, after which it will overflow. ðŸ¤¦\n                    // See <https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value>\n                    // While adding a cap technically skews the CPU rate limiting algorithm, we don't\n                    // really care for such extreme values.\n                    if (missingSleep > 2147483646) // Doc says `> 2147483647`, but I don't really trust their pedanticism so let's be safe\n                        missingSleep = 2147483646;\n                    const sleepFinished = new Promise((resolve) => setTimeout(() => resolve(\"timeout\"), missingSleep));\n                    if ((yield Promise.race([sleepFinished, shutdownExecutorOrWasmPanicPromise])) === \"stop\")\n                        break;\n                }\n                if ((yield Promise.race([whenReadyAgain, shutdownExecutorOrWasmPanicPromise])) === \"stop\")\n                    break;\n                const afterWait = config.performanceNow();\n                // `afterWait - now` is equal to how long we've waited for the `setTimeout` callback to\n                // trigger. While in principle `afterWait - now` should be roughly equal to\n                // `missingSleep`, in reality `setTimeout` can take much longer than the parameter\n                // provided. See <https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#timeouts_in_inactive_tabs>.\n                // For this reason, `missingSleep` can become negative here. This is intended.\n                // However, we don't want to accumulate too much sleep. There should be a maximum\n                // amount of time during which the CPU executes without yielding. For this reason, we\n                // add a minimum bound for `missingSleep`.\n                missingSleep -= (afterWait - now);\n                if (missingSleep < -10000)\n                    missingSleep = -10000;\n                now = afterWait;\n            }\n            if (!state.instance)\n                return;\n            eventCallback({ ty: \"executor-shutdown\" });\n        }))();\n        return {\n            request: (request, chainId) => {\n                if (!state.instance)\n                    return 1; // TODO: return a different error code? should be documented\n                state.bufferIndices[0] = new TextEncoder().encode(request);\n                return state.instance.exports.json_rpc_send(0, chainId) >>> 0;\n            },\n            peekJsonRpcResponse: (chainId) => {\n                if (!state.instance)\n                    return null;\n                const responseInfo = state.instance.exports.json_rpc_responses_peek(chainId) >>> 0;\n                // Note that the memory must be created after calling the Wasm function, otherwise\n                // it might be invalidated if it is grown.\n                const mem = new Uint8Array(state.instance.exports.memory.buffer);\n                const ptr = buffer.readUInt32LE(mem, responseInfo) >>> 0;\n                const len = buffer.readUInt32LE(mem, responseInfo + 4) >>> 0;\n                // `len === 0` means \"queue is empty\" according to the API.\n                // In that situation, queue the resolve/reject.\n                if (len !== 0) {\n                    const message = buffer.utf8BytesToString(mem, ptr, len);\n                    state.instance.exports.json_rpc_responses_pop(chainId);\n                    return message;\n                }\n                else {\n                    return null;\n                }\n            },\n            addChain: (chainSpec, databaseContent, potentialRelayChains, disableJsonRpc, jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions) => {\n                if (!state.instance) {\n                    eventCallback({ ty: \"add-chain-id-allocated\", chainId: 0 });\n                    eventCallback({ ty: \"add-chain-result\", chainId: 0, success: false, error: \"Smoldot has crashed\" });\n                    return;\n                }\n                // The caller is supposed to avoid this situation.\n                console.assert(disableJsonRpc || jsonRpcMaxPendingRequests != 0, \"invalid jsonRpcMaxPendingRequests value passed to local-instance::addChain\");\n                // `add_chain` unconditionally allocates a chain id. If an error occurs, however, this chain\n                // id will refer to an *erroneous* chain. `chain_is_ok` is used below to determine whether it\n                // has succeeeded or not.\n                state.bufferIndices[0] = new TextEncoder().encode(chainSpec);\n                state.bufferIndices[1] = new TextEncoder().encode(databaseContent);\n                const potentialRelayChainsEncoded = new Uint8Array(potentialRelayChains.length * 4);\n                for (let idx = 0; idx < potentialRelayChains.length; ++idx) {\n                    buffer.writeUInt32LE(potentialRelayChainsEncoded, idx * 4, potentialRelayChains[idx]);\n                }\n                state.bufferIndices[2] = potentialRelayChainsEncoded;\n                const chainId = state.instance.exports.add_chain(0, 1, disableJsonRpc ? 0 : jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions, 2);\n                delete state.bufferIndices[0];\n                delete state.bufferIndices[1];\n                delete state.bufferIndices[2];\n                eventCallback({ ty: \"add-chain-id-allocated\", chainId });\n            },\n            removeChain: (chainId) => {\n                if (!state.instance)\n                    return;\n                state.instance.exports.remove_chain(chainId);\n            },\n            shutdownExecutor: () => {\n                if (!state.instance)\n                    return;\n                const cb = state.onShutdownExecutorOrWasmPanic;\n                state.onShutdownExecutorOrWasmPanic = () => { };\n                cb();\n            },\n            connectionMultiStreamSetHandshakeInfo: (connectionId, info) => {\n                if (!state.instance)\n                    return;\n                const handshakeTy = new Uint8Array(1 + info.localTlsCertificateSha256.length);\n                buffer.writeUInt8(handshakeTy, 0, 0);\n                handshakeTy.set(info.localTlsCertificateSha256, 1);\n                state.bufferIndices[0] = handshakeTy;\n                state.instance.exports.connection_multi_stream_set_handshake_info(connectionId, 0);\n                delete state.bufferIndices[0];\n            },\n            connectionReset: (connectionId, message) => {\n                if (!state.instance)\n                    return;\n                state.bufferIndices[0] = new TextEncoder().encode(message);\n                state.instance.exports.connection_reset(connectionId, 0);\n                delete state.bufferIndices[0];\n            },\n            streamWritableBytes: (connectionId, numExtra, streamId) => {\n                if (!state.instance)\n                    return;\n                state.instance.exports.stream_writable_bytes(connectionId, streamId || 0, numExtra);\n            },\n            streamMessage: (connectionId, message, streamId) => {\n                if (!state.instance)\n                    return;\n                state.bufferIndices[0] = message;\n                state.instance.exports.stream_message(connectionId, streamId || 0, 0);\n                delete state.bufferIndices[0];\n            },\n            streamOpened: (connectionId, streamId, direction) => {\n                if (!state.instance)\n                    return;\n                state.instance.exports.connection_stream_opened(connectionId, streamId, direction === 'outbound' ? 1 : 0);\n            },\n            streamReset: (connectionId, streamId, message) => {\n                if (!state.instance)\n                    return;\n                state.bufferIndices[0] = new TextEncoder().encode(message);\n                state.instance.exports.stream_reset(connectionId, streamId, 0);\n                delete state.bufferIndices[0];\n            },\n        };\n    });\n}\n", "// Smoldot\n// Copyright (C) 2023  Pierre Krieger\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n// Contains an implementation of `Instance` that is remote.\n//\n// In terms of implementation, the logic is pretty straight forward, with two exceptions:\n//\n// - Connections are tracked on both sides in order to handle situations where one side has\n//   reset a connection or stream but the other is sending messages about this connection/stream.\n//\n// - JSON-RPC requests aren't sent back lazily one at a time. Instead, the client indicates that it\n//   is ready to accept more JSON-RPC responses, after which the server can send responses at any\n//   time and the client queues them locally.\nimport * as instance from './local-instance.js';\n// Implementation note: it is unclear even in the official specification\n// (https://html.spec.whatwg.org/multipage/web-messaging.html) whether both sides of a\n// `MessagePort` should be closed, or if one is enough.\n//\n// It has been noticed that doing `port.postMessage(...); port.close();` doesn't deliver the\n// message on Firefox (but it does on Chrome). The code below takes note of this, and only closes\n// a port upon *receiving* the last possible message. It therefore assumes that closing only one\n// side is enough. It is unclear whether this causes any memory leak.\nexport function connectToInstanceServer(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Send the wasm module and configuration to the server.\n        // Note that we await the `wasmModule` `Promise` here.\n        // If instead we used `wasmModule.then(...)`, the user would be able to start using the\n        // returned instance before the module has been sent to the server.\n        // In order to simplify the implementation, we create new ports and send one of them to\n        // the server. This is necessary so that the server can pause receiving messages while the\n        // instance is being initialized.\n        const { port1: portToServer, port2: serverToClient } = new MessageChannel();\n        const initialPort = config.portToServer;\n        const initialMessage = {\n            wasmModule: yield config.wasmModule,\n            serverToClient,\n            maxLogLevel: config.maxLogLevel,\n            cpuRateLimit: config.cpuRateLimit,\n            forbidWs: config.forbidWs,\n            forbidWss: config.forbidWss,\n            forbidNonLocalWs: config.forbidNonLocalWs,\n            forbidTcp: config.forbidTcp,\n            forbidWebRtc: config.forbidWebRtc\n        };\n        initialPort.postMessage(initialMessage, [serverToClient]);\n        // Note that closing `initialPort` here will lead to the message not being delivered on Firefox\n        // for some reason. It is therefore closed only on shutdown.\n        const state = {\n            jsonRpcResponses: new Map(),\n            connections: new Map(),\n        };\n        portToServer.onmessage = (messageEvent) => {\n            const message = messageEvent.data;\n            // Update some local state.\n            switch (message.ty) {\n                case \"wasm-panic\":\n                case \"executor-shutdown\": {\n                    portToServer.close();\n                    initialPort.close();\n                    break;\n                }\n                case \"add-chain-result\": {\n                    if (message.success) {\n                        state.jsonRpcResponses.set(message.chainId, new Array);\n                        const moreAccepted = { ty: \"accept-more-json-rpc-answers\", chainId: message.chainId };\n                        for (let i = 0; i < 10; ++i)\n                            portToServer.postMessage(moreAccepted);\n                    }\n                    break;\n                }\n                case \"new-connection\": {\n                    state.connections.set(message.connectionId, new Set());\n                    break;\n                }\n                case \"connection-reset\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    state.connections.delete(message.connectionId);\n                    break;\n                }\n                case \"connection-stream-open\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    break;\n                }\n                case \"connection-stream-reset\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    // The stream might have been reset locally in the past.\n                    if (!state.connections.get(message.connectionId).has(message.streamId))\n                        return;\n                    break;\n                }\n                case \"stream-send\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    // The stream might have been reset locally in the past.\n                    if (message.streamId && !state.connections.get(message.connectionId).has(message.streamId))\n                        return;\n                    break;\n                }\n                case \"stream-send-close\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    // The stream might have been reset locally in the past.\n                    if (message.streamId && !state.connections.get(message.connectionId).has(message.streamId))\n                        return;\n                    break;\n                }\n                case \"json-rpc-response\": {\n                    const queue = state.jsonRpcResponses.get(message.chainId);\n                    // The chain might have been removed locally in the past.\n                    if (queue) {\n                        queue.push(message.response);\n                        config.eventCallback({ ty: \"json-rpc-responses-non-empty\", chainId: message.chainId });\n                    }\n                    return;\n                }\n            }\n            config.eventCallback(message);\n        };\n        return {\n            addChain(chainSpec, databaseContent, potentialRelayChains, disableJsonRpc, jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    const msg = { ty: \"add-chain\", chainSpec, databaseContent, potentialRelayChains, disableJsonRpc, jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions };\n                    portToServer.postMessage(msg);\n                });\n            },\n            removeChain(chainId) {\n                state.jsonRpcResponses.delete(chainId);\n                const msg = { ty: \"remove-chain\", chainId };\n                portToServer.postMessage(msg);\n            },\n            request(request, chainId) {\n                const msg = { ty: \"request\", chainId, request };\n                portToServer.postMessage(msg);\n                return 0; // TODO: wrong return value\n            },\n            peekJsonRpcResponse(chainId) {\n                const item = state.jsonRpcResponses.get(chainId).shift();\n                if (!item)\n                    return null;\n                const msg = { ty: \"accept-more-json-rpc-answers\", chainId };\n                portToServer.postMessage(msg);\n                return item;\n            },\n            shutdownExecutor() {\n                const msg = { ty: \"shutdown\" };\n                portToServer.postMessage(msg);\n            },\n            connectionReset(connectionId, message) {\n                state.connections.delete(connectionId);\n                const msg = { ty: \"connection-reset\", connectionId, message };\n                portToServer.postMessage(msg);\n            },\n            connectionMultiStreamSetHandshakeInfo(connectionId, info) {\n                const msg = { ty: \"connection-multistream-set-info\", connectionId, info };\n                portToServer.postMessage(msg);\n            },\n            streamMessage(connectionId, message, streamId) {\n                const msg = { ty: \"stream-message\", connectionId, message, streamId };\n                portToServer.postMessage(msg);\n            },\n            streamOpened(connectionId, streamId, direction) {\n                state.connections.get(connectionId).add(streamId);\n                const msg = { ty: \"stream-opened\", connectionId, streamId, direction };\n                portToServer.postMessage(msg);\n            },\n            streamWritableBytes(connectionId, numExtra, streamId) {\n                const msg = { ty: \"stream-writable-bytes\", connectionId, numExtra, streamId };\n                portToServer.postMessage(msg);\n            },\n            streamReset(connectionId, streamId, message) {\n                state.connections.get(connectionId).delete(streamId);\n                const msg = { ty: \"stream-reset\", connectionId, streamId, message };\n                portToServer.postMessage(msg);\n            },\n        };\n    });\n}\n/**\n * Returns a `Promise` that resolves when the instance shuts down. Since the function is also\n * an asynchronous function, the actual return type is `Promise<Promise<void>>`. That is, the\n * outer `Promise` yields once the instance starts, and the inner `Promise` yields once the\n * instance shuts down.\n */\nexport function startInstanceServer(config, initPortToClient) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { serverToClient: portToClient, wasmModule, maxLogLevel, cpuRateLimit, forbidTcp, forbidWs, forbidWss, forbidNonLocalWs, forbidWebRtc } = yield new Promise((resolve) => {\n            initPortToClient.onmessage = (event) => resolve(event.data);\n        });\n        initPortToClient.close();\n        const state = {\n            instance: null,\n            connections: new Map(),\n            acceptedJsonRpcResponses: new Map(),\n        };\n        const eventsCallback = (event) => {\n            switch (event.ty) {\n                case \"add-chain-result\": {\n                    if (event.success) {\n                        state.acceptedJsonRpcResponses.set(event.chainId, 0);\n                    }\n                    break;\n                }\n                case \"executor-shutdown\":\n                case \"wasm-panic\": {\n                    if (state.onExecutorShutdownOrWasmPanic) {\n                        const cb = state.onExecutorShutdownOrWasmPanic;\n                        delete state.onExecutorShutdownOrWasmPanic;\n                        cb();\n                    }\n                    break;\n                }\n                case \"json-rpc-responses-non-empty\": {\n                    // Process this event asynchronously because we can't call into `instance`\n                    // from within the events callback itself.\n                    // TODO: do better than setTimeout?\n                    setTimeout(() => {\n                        const numAccepted = state.acceptedJsonRpcResponses.get(event.chainId);\n                        if (numAccepted === undefined || numAccepted === 0)\n                            return;\n                        const response = state.instance.peekJsonRpcResponse(event.chainId);\n                        if (response) {\n                            state.acceptedJsonRpcResponses.set(event.chainId, numAccepted - 1);\n                            const msg = { ty: \"json-rpc-response\", chainId: event.chainId, response };\n                            portToClient.postMessage(msg);\n                        }\n                    }, 0);\n                    return;\n                }\n                case \"new-connection\": {\n                    state.connections.set(event.connectionId, new Set());\n                    break;\n                }\n                case \"connection-reset\": {\n                    state.connections.delete(event.connectionId);\n                    break;\n                }\n                case \"connection-stream-reset\": {\n                    state.connections.get(event.connectionId).delete(event.streamId);\n                    break;\n                }\n            }\n            const ev = event;\n            portToClient.postMessage(ev);\n        };\n        // We create the `Promise` ahead of time in order to potentially catch potential `wasm-panic`\n        // events as early as during initialization.\n        const execFinishedPromise = new Promise((resolve) => state.onExecutorShutdownOrWasmPanic = resolve);\n        state.instance = yield instance.startLocalInstance(Object.assign({ forbidTcp,\n            forbidWs,\n            forbidNonLocalWs,\n            forbidWss,\n            forbidWebRtc,\n            cpuRateLimit,\n            maxLogLevel }, config), wasmModule, eventsCallback);\n        portToClient.onmessage = (messageEvent) => {\n            const message = messageEvent.data;\n            switch (message.ty) {\n                case \"add-chain\": {\n                    state.instance.addChain(message.chainSpec, message.databaseContent, message.potentialRelayChains, message.disableJsonRpc, message.jsonRpcMaxPendingRequests, message.jsonRpcMaxSubscriptions);\n                    break;\n                }\n                case \"remove-chain\": {\n                    state.acceptedJsonRpcResponses.delete(message.chainId);\n                    state.instance.removeChain(message.chainId);\n                    break;\n                }\n                case \"request\": {\n                    state.instance.request(message.request, message.chainId); // TODO: return value unused\n                    break;\n                }\n                case \"accept-more-json-rpc-answers\": {\n                    const response = state.instance.peekJsonRpcResponse(message.chainId);\n                    if (response) {\n                        const msg = { ty: \"json-rpc-response\", chainId: message.chainId, response };\n                        portToClient.postMessage(msg);\n                    }\n                    else {\n                        const numAccepted = state.acceptedJsonRpcResponses.get(message.chainId);\n                        state.acceptedJsonRpcResponses.set(message.chainId, numAccepted + 1);\n                    }\n                    break;\n                }\n                case \"shutdown\": {\n                    state.instance.shutdownExecutor();\n                    break;\n                }\n                case \"connection-reset\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    state.instance.connectionReset(message.connectionId, message.message);\n                    break;\n                }\n                case \"connection-multistream-set-info\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    state.instance.connectionMultiStreamSetHandshakeInfo(message.connectionId, message.info);\n                    break;\n                }\n                case \"stream-message\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    // The stream might have been reset locally in the past.\n                    if (message.streamId !== undefined && !state.connections.get(message.connectionId).has(message.streamId))\n                        return;\n                    state.instance.streamMessage(message.connectionId, message.message, message.streamId);\n                    break;\n                }\n                case \"stream-opened\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    state.connections.get(message.connectionId).add(message.streamId);\n                    state.instance.streamOpened(message.connectionId, message.streamId, message.direction);\n                    break;\n                }\n                case \"stream-writable-bytes\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    // The stream might have been reset locally in the past.\n                    if (message.streamId !== undefined && !state.connections.get(message.connectionId).has(message.streamId))\n                        return;\n                    state.instance.streamWritableBytes(message.connectionId, message.numExtra, message.streamId);\n                    break;\n                }\n                case \"stream-reset\": {\n                    // The connection might have been reset locally in the past.\n                    if (!state.connections.has(message.connectionId))\n                        return;\n                    // The stream might have been reset locally in the past.\n                    if (!state.connections.get(message.connectionId).has(message.streamId))\n                        return;\n                    state.connections.get(message.connectionId).delete(message.streamId);\n                    state.instance.streamReset(message.connectionId, message.streamId, message.message);\n                    break;\n                }\n            }\n        };\n        return execFinishedPromise;\n    });\n}\n", "// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport { QueueFullError, AlreadyDestroyedError, AddChainError, JsonRpcDisabledError, CrashError } from '../public-types.js';\nimport * as instance from './local-instance.js';\nimport * as remote from './remote-instance.js';\n// This function is similar to the `start` function found in `index.ts`, except with an extra\n// parameter containing the platform-specific bindings.\n// Contrary to the one within `index.js`, this function is not supposed to be directly used.\nexport function start(options, wasmModule, platformBindings) {\n    const logCallback = options.logCallback || ((level, target, message) => {\n        // The first parameter of the methods of `console` has some printf-like substitution\n        // capabilities. We don't really need to use this, but not using it means that the logs might\n        // not get printed correctly if they contain `%`.\n        if (level <= 1) {\n            console.error(\"[%s] %s\", target, message);\n        }\n        else if (level == 2) {\n            console.warn(\"[%s] %s\", target, message);\n        }\n        else if (level == 3) {\n            console.info(\"[%s] %s\", target, message);\n        }\n        else if (level == 4) {\n            console.debug(\"[%s] %s\", target, message);\n        }\n        else {\n            console.trace(\"[%s] %s\", target, message);\n        }\n    });\n    if (!(wasmModule instanceof Promise)) {\n        wasmModule = Promise.resolve(wasmModule);\n    }\n    // Extract (to make sure the value doesn't change) and sanitize `cpuRateLimit`.\n    let cpuRateLimit = options.cpuRateLimit || 1.0;\n    if (isNaN(cpuRateLimit))\n        cpuRateLimit = 1.0;\n    if (cpuRateLimit > 1.0)\n        cpuRateLimit = 1.0;\n    if (cpuRateLimit < 0.0)\n        cpuRateLimit = 0.0;\n    // This object holds the state of everything.\n    const state = {\n        instance: { status: \"not-created\" },\n        chainIds: new WeakMap(),\n        connections: new Map(),\n        addChainIdAllocations: [],\n        addChainResults: new Map(),\n        onExecutorShutdownOrWasmPanic: () => { },\n        chains: new Map(),\n    };\n    // Callback called during the execution of the instance.\n    const eventCallback = (event) => {\n        switch (event.ty) {\n            case \"wasm-panic\": {\n                console.error(\"Smoldot has panicked\" +\n                    (event.currentTask ? (\" while executing task `\" + event.currentTask + \"`\") : \"\") +\n                    \". This is a bug in smoldot. Please open an issue at \" +\n                    \"https://github.com/smol-dot/smoldot/issues with the following message:\\n\" +\n                    event.message);\n                state.instance = {\n                    status: \"destroyed\",\n                    error: new CrashError(event.message),\n                };\n                state.connections.forEach((connec) => connec.reset());\n                state.connections.clear();\n                for (const addChainResult of state.addChainIdAllocations) {\n                    addChainResult({ success: false, error: \"Smoldot has crashed\" });\n                }\n                state.addChainIdAllocations = [];\n                state.addChainResults.forEach((addChainResult) => {\n                    addChainResult({ success: false, error: \"Smoldot has crashed\" });\n                });\n                state.addChainResults.clear();\n                for (const chain of Array.from(state.chains.values())) {\n                    for (const callback of chain.jsonRpcResponsesPromises) {\n                        callback();\n                    }\n                    chain.jsonRpcResponsesPromises = [];\n                }\n                state.chains.clear();\n                const cb = state.onExecutorShutdownOrWasmPanic;\n                state.onExecutorShutdownOrWasmPanic = () => { };\n                cb();\n                break;\n            }\n            case \"executor-shutdown\": {\n                const cb = state.onExecutorShutdownOrWasmPanic;\n                state.onExecutorShutdownOrWasmPanic = () => { };\n                cb();\n                break;\n            }\n            case \"log\": {\n                logCallback(event.level, event.target, event.message);\n                break;\n            }\n            case \"add-chain-id-allocated\": {\n                const callback = state.addChainIdAllocations.shift();\n                state.addChainResults.set(event.chainId, callback);\n                break;\n            }\n            case \"add-chain-result\": {\n                (state.addChainResults.get(event.chainId))(event);\n                state.addChainResults.delete(event.chainId);\n                break;\n            }\n            case \"json-rpc-responses-non-empty\": {\n                // Notify every single promise found in `jsonRpcResponsesPromises`.\n                const callbacks = state.chains.get(event.chainId).jsonRpcResponsesPromises;\n                while (callbacks.length !== 0) {\n                    (callbacks.shift())();\n                }\n                break;\n            }\n            case \"new-connection\": {\n                const connectionId = event.connectionId;\n                state.connections.set(connectionId, platformBindings.connect({\n                    address: event.address,\n                    onConnectionReset(message) {\n                        if (state.instance.status !== \"ready\")\n                            throw new Error();\n                        state.connections.delete(connectionId);\n                        state.instance.instance.connectionReset(connectionId, message);\n                    },\n                    onMessage(message, streamId) {\n                        if (state.instance.status !== \"ready\")\n                            throw new Error();\n                        state.instance.instance.streamMessage(connectionId, message, streamId);\n                    },\n                    onStreamOpened(streamId, direction) {\n                        if (state.instance.status !== \"ready\")\n                            throw new Error();\n                        state.instance.instance.streamOpened(connectionId, streamId, direction);\n                    },\n                    onMultistreamHandshakeInfo(info) {\n                        if (state.instance.status !== \"ready\")\n                            throw new Error();\n                        state.instance.instance.connectionMultiStreamSetHandshakeInfo(connectionId, info);\n                    },\n                    onWritableBytes(numExtra, streamId) {\n                        if (state.instance.status !== \"ready\")\n                            throw new Error();\n                        state.instance.instance.streamWritableBytes(connectionId, numExtra, streamId);\n                    },\n                    onStreamReset(streamId, message) {\n                        if (state.instance.status !== \"ready\")\n                            throw new Error();\n                        state.instance.instance.streamReset(connectionId, streamId, message);\n                    },\n                }));\n                break;\n            }\n            case \"connection-reset\": {\n                const connection = state.connections.get(event.connectionId);\n                connection.reset();\n                state.connections.delete(event.connectionId);\n                break;\n            }\n            case \"connection-stream-open\": {\n                const connection = state.connections.get(event.connectionId);\n                connection.openOutSubstream();\n                break;\n            }\n            case \"connection-stream-reset\": {\n                const connection = state.connections.get(event.connectionId);\n                connection.reset(event.streamId);\n                break;\n            }\n            case \"stream-send\": {\n                const connection = state.connections.get(event.connectionId);\n                connection.send(event.data, event.streamId);\n                break;\n            }\n            case \"stream-send-close\": {\n                const connection = state.connections.get(event.connectionId);\n                connection.closeSend(event.streamId);\n                break;\n            }\n        }\n    };\n    const portToWorker = options.portToWorker;\n    if (!portToWorker) {\n        // Start a local instance.\n        state.instance = {\n            status: \"not-ready\",\n            whenReady: wasmModule\n                .then((wasmModule) => {\n                return instance.startLocalInstance({\n                    forbidTcp: options.forbidTcp || false,\n                    forbidWs: options.forbidWs || false,\n                    forbidNonLocalWs: options.forbidNonLocalWs || false,\n                    forbidWss: options.forbidWss || false,\n                    forbidWebRtc: options.forbidWebRtc || false,\n                    maxLogLevel: options.maxLogLevel || 3,\n                    cpuRateLimit,\n                    envVars: [],\n                    performanceNow: platformBindings.performanceNow,\n                    getRandomValues: platformBindings.getRandomValues,\n                }, wasmModule.wasm, eventCallback);\n            })\n                .then((instance) => {\n                // The Wasm instance might have been crashed before this callback is called.\n                if (state.instance.status === \"destroyed\")\n                    return;\n                state.instance = {\n                    status: \"ready\",\n                    instance,\n                };\n            })\n        };\n    }\n    else {\n        // Connect to the remote instance.\n        state.instance = {\n            status: \"not-ready\",\n            whenReady: remote.connectToInstanceServer({\n                wasmModule: wasmModule.then((b) => b.wasm),\n                forbidTcp: options.forbidTcp || false,\n                forbidWs: options.forbidWs || false,\n                forbidNonLocalWs: options.forbidNonLocalWs || false,\n                forbidWss: options.forbidWss || false,\n                forbidWebRtc: options.forbidWebRtc || false,\n                maxLogLevel: options.maxLogLevel || 3,\n                cpuRateLimit,\n                portToServer: portToWorker,\n                eventCallback\n            }).then((instance) => {\n                // The Wasm instance might have been crashed before this callback is called.\n                if (state.instance.status === \"destroyed\")\n                    return;\n                state.instance = {\n                    status: \"ready\",\n                    instance,\n                };\n            })\n        };\n    }\n    return {\n        addChain: (options) => __awaiter(this, void 0, void 0, function* () {\n            if (state.instance.status === \"not-ready\")\n                yield state.instance.whenReady;\n            if (state.instance.status === \"destroyed\")\n                throw state.instance.error;\n            if (state.instance.status === \"not-created\" || state.instance.status === \"not-ready\")\n                throw new Error(); // Internal error, not supposed to ever happen.\n            // Passing a JSON object for the chain spec is an easy mistake, so we provide a more\n            // readable error.\n            if (!(typeof options.chainSpec === 'string'))\n                throw new Error(\"Chain specification must be a string\");\n            let potentialRelayChainsIds = [];\n            if (!!options.potentialRelayChains) {\n                for (const chain of options.potentialRelayChains) {\n                    // The content of `options.potentialRelayChains` are supposed to be chains earlier\n                    // returned by `addChain`.\n                    const id = state.chainIds.get(chain);\n                    if (id === undefined) // It is possible for `id` to be missing if it has earlier been removed.\n                        continue;\n                    potentialRelayChainsIds.push(id);\n                }\n            }\n            // Sanitize `jsonRpcMaxPendingRequests`.\n            let jsonRpcMaxPendingRequests = options.jsonRpcMaxPendingRequests === undefined ? Infinity : options.jsonRpcMaxPendingRequests;\n            jsonRpcMaxPendingRequests = Math.floor(jsonRpcMaxPendingRequests);\n            if (jsonRpcMaxPendingRequests <= 0 || isNaN(jsonRpcMaxPendingRequests)) {\n                throw new AddChainError(\"Invalid value for `jsonRpcMaxPendingRequests`\");\n            }\n            if (jsonRpcMaxPendingRequests > 0xffffffff) {\n                jsonRpcMaxPendingRequests = 0xffffffff;\n            }\n            // Sanitize `jsonRpcMaxSubscriptions`.\n            let jsonRpcMaxSubscriptions = options.jsonRpcMaxSubscriptions === undefined ? Infinity : options.jsonRpcMaxSubscriptions;\n            jsonRpcMaxSubscriptions = Math.floor(jsonRpcMaxSubscriptions);\n            if (jsonRpcMaxSubscriptions < 0 || isNaN(jsonRpcMaxSubscriptions)) {\n                throw new AddChainError(\"Invalid value for `jsonRpcMaxSubscriptions`\");\n            }\n            if (jsonRpcMaxSubscriptions > 0xffffffff) {\n                jsonRpcMaxSubscriptions = 0xffffffff;\n            }\n            // Sanitize `databaseContent`.\n            if (options.databaseContent !== undefined && typeof options.databaseContent !== 'string')\n                throw new AddChainError(\"`databaseContent` is not a string\");\n            const promise = new Promise((resolve) => state.addChainIdAllocations.push(resolve));\n            state.instance.instance.addChain(options.chainSpec, options.databaseContent || \"\", potentialRelayChainsIds, !!options.disableJsonRpc, jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions);\n            const outcome = yield promise;\n            if (!outcome.success)\n                throw new AddChainError(outcome.error);\n            const chainId = outcome.chainId;\n            state.chains.set(chainId, {\n                jsonRpcResponsesPromises: new Array()\n            });\n            const newChain = {\n                sendJsonRpc: (request) => {\n                    if (state.instance.status === \"destroyed\")\n                        throw state.instance.error;\n                    if (state.instance.status !== \"ready\")\n                        throw new Error(); // Internal error. Never supposed to happen.\n                    if (!state.chains.has(chainId))\n                        throw new AlreadyDestroyedError();\n                    if (options.disableJsonRpc)\n                        throw new JsonRpcDisabledError();\n                    const retVal = state.instance.instance.request(request, chainId);\n                    switch (retVal) {\n                        case 0: break;\n                        case 1: throw new QueueFullError();\n                        default: throw new Error(\"Internal error: unknown json_rpc_send error code: \" + retVal);\n                    }\n                },\n                jsonRpcResponses: {\n                    next: () => __awaiter(this, void 0, void 0, function* () {\n                        while (true) {\n                            if (!state.chains.has(chainId))\n                                return { done: true, value: undefined };\n                            if (options.disableJsonRpc)\n                                throw new JsonRpcDisabledError();\n                            if (state.instance.status === \"destroyed\")\n                                throw state.instance.error;\n                            if (state.instance.status !== \"ready\")\n                                throw new Error(); // Internal error. Never supposed to happen.\n                            // Try to pop a message from the queue.\n                            const message = state.instance.instance.peekJsonRpcResponse(chainId);\n                            if (message)\n                                return { done: false, value: message };\n                            // If no message is available, wait for one to be.\n                            yield new Promise((resolve) => {\n                                state.chains.get(chainId).jsonRpcResponsesPromises.push(resolve);\n                            });\n                        }\n                    }),\n                    [Symbol.asyncIterator]() {\n                        return this;\n                    }\n                },\n                nextJsonRpcResponse: () => __awaiter(this, void 0, void 0, function* () {\n                    const result = yield newChain.jsonRpcResponses.next();\n                    if (result.done) {\n                        throw new AlreadyDestroyedError();\n                    }\n                    return result.value;\n                }),\n                remove: () => {\n                    if (state.instance.status === \"destroyed\")\n                        throw state.instance.error;\n                    if (state.instance.status !== \"ready\")\n                        throw new Error(); // Internal error. Never supposed to happen.\n                    if (!state.chains.has(chainId))\n                        throw new AlreadyDestroyedError();\n                    console.assert(state.chainIds.has(newChain));\n                    state.chainIds.delete(newChain);\n                    for (const callback of state.chains.get(chainId).jsonRpcResponsesPromises) {\n                        callback();\n                    }\n                    state.chains.delete(chainId);\n                    state.instance.instance.removeChain(chainId);\n                },\n            };\n            state.chainIds.set(newChain, chainId);\n            return newChain;\n        }),\n        terminate: () => __awaiter(this, void 0, void 0, function* () {\n            if (state.instance.status === \"not-ready\")\n                yield state.instance.whenReady;\n            if (state.instance.status === \"destroyed\")\n                throw state.instance.error;\n            if (state.instance.status !== \"ready\")\n                throw new Error(); // Internal error. Never supposed to happen.\n            state.instance.instance.shutdownExecutor();\n            // Wait for the `executor-shutdown` event to be generated.\n            yield new Promise((resolve) => state.onExecutorShutdownOrWasmPanic = resolve);\n            // In case the instance crashes while we were waiting, we don't want to overwrite\n            // the error.\n            if (state.instance.status === \"ready\")\n                state.instance = { status: \"destroyed\", error: new AlreadyDestroyedError() };\n            state.connections.forEach((connec) => connec.reset());\n            state.connections.clear();\n            for (const addChainResult of state.addChainIdAllocations) {\n                addChainResult({ success: false, error: \"Client.terminate() has been called\" });\n            }\n            state.addChainIdAllocations = [];\n            state.addChainResults.forEach((addChainResult) => {\n                addChainResult({ success: false, error: \"Client.terminate() has been called\" });\n            });\n            state.addChainResults.clear();\n            for (const chain of Array.from(state.chains.values())) {\n                for (const callback of chain.jsonRpcResponsesPromises) {\n                    callback();\n                }\n                chain.jsonRpcResponsesPromises = [];\n            }\n            state.chains.clear();\n        })\n    };\n}\n", "// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { start as innerStart } from './internals/client.js';\nexport { AddChainError, AlreadyDestroyedError, CrashError, JsonRpcDisabledError, QueueFullError } from './public-types.js';\n/**\n * Initializes a new client. This is a pre-requisite to connecting to a blockchain.\n *\n * Can never fail.\n *\n * @param options Configuration of the client.\n */\nexport function startWithBytecode(options) {\n    options.forbidTcp = true;\n    // When in a secure context, browsers refuse to open non-secure WebSocket connections to\n    // non-localhost. There is an exception if the page is localhost, in which case all connections\n    // are allowed.\n    // Detecting this ahead of time is better for the overall health of the client, as it will\n    // avoid storing in memory addresses that it knows it can't connect to.\n    // The condition below is a hint, and false-positives or false-negatives are not fundamentally\n    // an issue.\n    if ((typeof isSecureContext === 'boolean' && isSecureContext) && typeof location !== undefined) {\n        const loc = location.toString();\n        if (loc.indexOf('localhost') !== -1 && loc.indexOf('127.0.0.1') !== -1 && loc.indexOf('::1') !== -1) {\n            options.forbidNonLocalWs = true;\n        }\n    }\n    return innerStart(options, options.bytecode, {\n        performanceNow: () => {\n            return performance.now();\n        },\n        getRandomValues: (buffer) => {\n            const crypto = globalThis.crypto;\n            if (!crypto)\n                throw new Error('randomness not available');\n            // Browsers have this completely undocumented behavior (it's not even part of a spec)\n            // that for some reason `getRandomValues` can't be called on arrayviews back by\n            // `SharedArrayBuffer`s and they throw an exception if you try.\n            if (buffer.buffer instanceof ArrayBuffer)\n                crypto.getRandomValues(buffer);\n            else {\n                const tmpArray = new Uint8Array(buffer.length);\n                crypto.getRandomValues(tmpArray);\n                buffer.set(tmpArray);\n            }\n        },\n        connect: (config) => {\n            return connect(config);\n        }\n    });\n}\n/**\n * Tries to open a new connection using the given configuration.\n *\n * @see Connection\n * @throws any If the multiaddress couldn't be parsed or contains an invalid protocol.\n */\nfunction connect(config) {\n    if (config.address.ty === \"websocket\") {\n        // Even though the WHATWG specification (<https://websockets.spec.whatwg.org/#dom-websocket-websocket>)\n        // doesn't mention it, `new WebSocket` can throw an exception if the URL is forbidden\n        // for security reasons. We absord this exception as soon as it is thrown.\n        // `connection` can be either a `WebSocket` object (the normal case), or a string\n        // indicating an error message that must be propagated with `onConnectionReset` as soon\n        // as possible, or `null` if the API user considers the connection as reset.\n        let connection;\n        try {\n            connection = new WebSocket(config.address.url);\n        }\n        catch (error) {\n            connection = error instanceof Error ? error.toString() : \"Exception thrown by new WebSocket\";\n        }\n        const bufferedAmountCheck = { quenedUnreportedBytes: 0, nextTimeout: 10 };\n        const checkBufferedAmount = () => {\n            if (!(connection instanceof WebSocket))\n                return;\n            if (connection.readyState != 1)\n                return;\n            // Note that we might expect `bufferedAmount` to always be <= the sum of the lengths\n            // of all the data that has been sent, but that might not be the case. For this\n            // reason, we use `bufferedAmount` as a hint rather than a correct value.\n            const bufferedAmount = connection.bufferedAmount;\n            let wasSent = bufferedAmountCheck.quenedUnreportedBytes - bufferedAmount;\n            if (wasSent < 0)\n                wasSent = 0;\n            bufferedAmountCheck.quenedUnreportedBytes -= wasSent;\n            if (bufferedAmountCheck.quenedUnreportedBytes != 0) {\n                setTimeout(checkBufferedAmount, bufferedAmountCheck.nextTimeout);\n                bufferedAmountCheck.nextTimeout *= 2;\n                if (bufferedAmountCheck.nextTimeout > 500)\n                    bufferedAmountCheck.nextTimeout = 500;\n            }\n            // Note: it is important to call `onWritableBytes` at the very end, as it might\n            // trigger a call to `send`.\n            if (wasSent != 0)\n                config.onWritableBytes(wasSent);\n        };\n        if (connection instanceof WebSocket) {\n            connection.binaryType = 'arraybuffer';\n            connection.onopen = () => {\n                config.onWritableBytes(1024 * 1024);\n            };\n            connection.onclose = (event) => {\n                const message = \"Error code \" + event.code + (!!event.reason ? (\": \" + event.reason) : \"\");\n                config.onConnectionReset(message);\n            };\n            connection.onmessage = (msg) => {\n                config.onMessage(new Uint8Array(msg.data));\n            };\n        }\n        else {\n            setTimeout(() => {\n                if (connection && !(connection instanceof WebSocket)) {\n                    config.onConnectionReset(connection);\n                    connection = null;\n                }\n            }, 1);\n        }\n        return {\n            reset: () => {\n                if (connection instanceof WebSocket) {\n                    connection.onopen = null;\n                    connection.onclose = null;\n                    connection.onmessage = null;\n                    connection.onerror = null;\n                    // According to the WebSocket specification, calling `close()` when a WebSocket\n                    // isn't fully opened yet is completely legal and seemingly a normal thing to\n                    // do (see <https://websockets.spec.whatwg.org/#dom-websocket-close>).\n                    // Unfortunately, browsers print a warning in the console if you do that. To\n                    // avoid these warnings, we only call `close()` if the connection is fully\n                    // opened. According to <https://websockets.spec.whatwg.org/#garbage-collection>,\n                    // removing all the event listeners will cause the WebSocket to be garbage\n                    // collected, which should have the same effect as `close()`.\n                    if (connection.readyState == WebSocket.OPEN)\n                        connection.close();\n                }\n                connection = null;\n            },\n            send: (data) => {\n                if (bufferedAmountCheck.quenedUnreportedBytes == 0) {\n                    bufferedAmountCheck.nextTimeout = 10;\n                    setTimeout(checkBufferedAmount, 10);\n                }\n                for (const buffer of data) {\n                    bufferedAmountCheck.quenedUnreportedBytes += buffer.length;\n                }\n                connection.send(new Blob(data));\n            },\n            closeSend: () => { throw new Error('Wrong connection type'); },\n            openOutSubstream: () => { throw new Error('Wrong connection type'); }\n        };\n    }\n    else if (config.address.ty === \"webrtc\") {\n        const { targetPort, ipVersion, targetIp, remoteTlsCertificateSha256 } = config.address;\n        const state = {\n            pc: undefined,\n            dataChannels: new Map(),\n            nextStreamId: 0,\n            isFirstOutSubstream: true,\n        };\n        // Kills all the JavaScript objects (the connection and all its substreams), ensuring that no\n        // callback will be called again. Doesn't report anything to smoldot, as this should be done\n        // by the caller.\n        const killAllJs = () => {\n            // The `RTCPeerConnection` is created pretty quickly. It is however still possible for\n            // smoldot to cancel the opening, in which case `pc` will still be undefined.\n            if (!state.pc) {\n                console.assert(state.dataChannels.size === 0, \"substreams exist while pc is undef\");\n                state.pc = null;\n                return;\n            }\n            state.pc.onconnectionstatechange = null;\n            state.pc.onnegotiationneeded = null;\n            state.pc.ondatachannel = null;\n            for (const channel of Array.from(state.dataChannels.values())) {\n                channel.channel.onopen = null;\n                channel.channel.onerror = null;\n                channel.channel.onclose = null;\n                channel.channel.onbufferedamountlow = null;\n                channel.channel.onmessage = null;\n            }\n            state.dataChannels.clear();\n            state.pc.close(); // Not necessarily necessary, but it doesn't hurt to do so.\n        };\n        // Function that configures a newly-opened channel and adds it to the map. Used for both\n        // inbound and outbound substreams.\n        const addChannel = (dataChannel, direction) => {\n            const streamId = state.nextStreamId;\n            state.nextStreamId += 1;\n            dataChannel.binaryType = 'arraybuffer';\n            let isOpen = { value: false };\n            dataChannel.onopen = () => {\n                console.assert(!isOpen.value, \"substream opened twice\");\n                isOpen.value = true;\n                config.onStreamOpened(streamId, direction);\n                config.onWritableBytes(65536, streamId);\n            };\n            dataChannel.onerror = dataChannel.onclose = (event) => {\n                // Note that Firefox doesn't support <https://developer.mozilla.org/en-US/docs/Web/API/RTCErrorEvent>.\n                const message = (event instanceof RTCErrorEvent) ? event.error.toString() : \"RTCDataChannel closed\";\n                if (!isOpen.value) {\n                    // Substream wasn't opened yet and thus has failed to open. The API has no\n                    // mechanism to report substream openings failures. We could try opening it\n                    // again, but given that it's unlikely to succeed, we simply opt to kill the\n                    // entire connection.\n                    killAllJs();\n                    // Note that the event doesn't give any additional reason for the failure.\n                    config.onConnectionReset(\"data channel failed to open: \" + message);\n                }\n                else {\n                    // Substream was open and is now closed. Normal situation.\n                    dataChannel.onopen = null;\n                    dataChannel.onerror = null;\n                    dataChannel.onclose = null;\n                    dataChannel.onbufferedamountlow = null;\n                    dataChannel.onmessage = null;\n                    state.dataChannels.delete(streamId);\n                    config.onStreamReset(streamId, message);\n                }\n            };\n            dataChannel.onbufferedamountlow = () => {\n                const channel = state.dataChannels.get(streamId);\n                const val = channel.bufferedBytes;\n                channel.bufferedBytes = 0;\n                config.onWritableBytes(val, streamId);\n            };\n            dataChannel.onmessage = (m) => {\n                // The `data` field is an `ArrayBuffer`.\n                config.onMessage(new Uint8Array(m.data), streamId);\n            };\n            state.dataChannels.set(streamId, { channel: dataChannel, bufferedBytes: 0 });\n        };\n        // It is possible for the browser to use multiple different certificates.\n        // In order for our local certificate to be deterministic, we need to generate it manually and\n        // set it explicitly as part of the configuration.\n        // According to <https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-generatecertificate>,\n        // browsers are guaranteed to support `{ name: \"ECDSA\", namedCurve: \"P-256\" }`.\n        RTCPeerConnection.generateCertificate({ name: \"ECDSA\", namedCurve: \"P-256\", hash: \"SHA-256\" }).then((localCertificate) => __awaiter(this, void 0, void 0, function* () {\n            if (state.pc === null)\n                return;\n            // Due to <https://bugzilla.mozilla.org/show_bug.cgi?id=1659672>, connections from\n            // Firefox to a localhost WebRTC server always fails. Since this bug has been opened\n            // for three years at the time of writing, it is unlikely to be fixed in the short\n            // term. In order to provider better user feedback, we straight up refuse connecting\n            // and stop the connection.\n            // Note that this is just a hint. Failing to detect this will lead to the WebRTC\n            // handshake  timing out.\n            // TODO: eventually remove this if the Firefox bug is fixed\n            if ((targetIp == 'localhost' || targetIp == '127.0.0.1' || targetIp == '::1') && navigator.userAgent.indexOf('Firefox') !== -1) {\n                killAllJs();\n                config.onConnectionReset(\"Firefox can't connect to a localhost WebRTC server\");\n                return;\n            }\n            // Create a new WebRTC connection.\n            state.pc = new RTCPeerConnection({ certificates: [localCertificate] });\n            // We need to build the multihash corresponding to the local certificate.\n            // While there exists a `RTCPeerConnection.getFingerprints` function, Firefox notably\n            // doesn't support it.\n            // See <https://developer.mozilla.org/en-US/docs/Web/API/RTCCertificate#browser_compatibility>\n            // An alternative to `getFingerprints` is to ask the browser to generate an SDP offer and\n            // extract from fingerprint from it. Because we explicitly provide a certificate, we have\n            // the guarantee that the list of certificates will always be the same whenever an SDP offer\n            // is generated by the browser. However, while this alternative does work on Firefox, it\n            // doesn't on Chrome, as the SDP offer is for some reason missing the fingerprints.\n            // Therefore, our strategy is to use `getFingerprints` when it is available (i.e. every\n            // browser except Firefox), and parse the SDP offer when it is not (i.e. Firefox). In the\n            // future, only `getFingerprints` would be used.\n            let localTlsCertificateHex;\n            if (localCertificate.getFingerprints) {\n                for (const { algorithm, value } of localCertificate.getFingerprints()) {\n                    if (algorithm === 'sha-256') {\n                        localTlsCertificateHex = value;\n                        break;\n                    }\n                }\n            }\n            else {\n                const localSdpOffer = yield state.pc.createOffer();\n                // Note that this regex is not strict. The browser isn't a malicious actor, and the\n                // objective of this regex is not to detect invalid input.\n                const localSdpOfferFingerprintMatch = localSdpOffer.sdp.match(/a(\\s*)=(\\s*)fingerprint:(\\s*)(sha|SHA)-256(\\s*)(([a-fA-F0-9]{2}(:)*){32})/);\n                if (localSdpOfferFingerprintMatch) {\n                    localTlsCertificateHex = localSdpOfferFingerprintMatch[6];\n                }\n            }\n            if (localTlsCertificateHex === undefined) {\n                // Because we've already returned from the `connect` function at this point, we pretend\n                // that the connection has failed to open.\n                config.onConnectionReset('Failed to obtain the browser certificate fingerprint');\n                return;\n            }\n            let localTlsCertificateSha256 = new Uint8Array(32);\n            localTlsCertificateSha256.set(localTlsCertificateHex.split(':').map((s) => parseInt(s, 16)), 0);\n            // `onconnectionstatechange` is used to detect when the connection has closed or has failed\n            // to open.\n            // Note that smoldot will think that the connection is open even when it is still opening.\n            // Therefore we don't care about events concerning the fact that the connection is now fully\n            // open.\n            state.pc.onconnectionstatechange = (_event) => {\n                if (state.pc.connectionState == \"closed\" || state.pc.connectionState == \"disconnected\" || state.pc.connectionState == \"failed\") {\n                    killAllJs();\n                    config.onConnectionReset(\"WebRTC state transitioned to \" + state.pc.connectionState);\n                }\n            };\n            state.pc.onnegotiationneeded = (_event) => __awaiter(this, void 0, void 0, function* () {\n                var _a;\n                // Create a new offer and set it as local description.\n                let sdpOffer = (yield state.pc.createOffer()).sdp;\n                // We check that the locally-generated SDP offer has a data channel with the UDP\n                // protocol. If that isn't the case, the connection will likely fail.\n                if (sdpOffer.match(/^m=application(\\s+)(\\d+)(\\s+)UDP\\/DTLS\\/SCTP(\\s+)webrtc-datachannel$/m) === null) {\n                    console.error(\"Local offer doesn't contain UDP data channel. WebRTC connections will likely fail. Please report this issue.\");\n                }\n                // According to the libp2p WebRTC spec, the ufrag and pwd are the same\n                // randomly-generated string on both sides, and must be prefixed with\n                // `libp2p-webrtc-v1:`. We modify the local description to ensure that.\n                // While we could randomly generate a new string, we just grab the one that the\n                // browser has generated, in order to make sure that it respects the constraints\n                // of the ICE protocol.\n                const browserGeneratedPwd = (_a = sdpOffer.match(/^a=ice-pwd:(.+)$/m)) === null || _a === void 0 ? void 0 : _a.at(1);\n                if (browserGeneratedPwd === undefined) {\n                    console.error(\"Failed to set ufrag to pwd. WebRTC connections will likely fail. Please report this issue.\");\n                }\n                const ufragPwd = \"libp2p+webrtc+v1/\" + browserGeneratedPwd;\n                sdpOffer = sdpOffer.replace(/^a=ice-ufrag.*$/m, 'a=ice-ufrag:' + ufragPwd);\n                sdpOffer = sdpOffer.replace(/^a=ice-pwd.*$/m, 'a=ice-pwd:' + ufragPwd);\n                yield state.pc.setLocalDescription({ type: 'offer', sdp: sdpOffer });\n                // Transform certificate hash into fingerprint (upper-hex; each byte separated by \":\").\n                const fingerprint = Array.from(remoteTlsCertificateSha256).map((n) => (\"0\" + n.toString(16)).slice(-2).toUpperCase()).join(':');\n                // Note that the trailing line feed is important, as otherwise Chrome\n                // fails to parse the payload.\n                const remoteSdp = \n                // Version of the SDP protocol. Always 0. (RFC8866)\n                \"v=0\" + \"\\n\" +\n                    // Identifies the creator of the SDP document. We are allowed to use dummy values\n                    // (`-` and `0.0.0.0`) to remain anonymous, which we do. Note that \"IN\" means\n                    // \"Internet\" (and not \"input\"). (RFC8866)\n                    \"o=- 0 0 IN IP\" + ipVersion + \" \" + targetIp + \"\\n\" +\n                    // Name for the session. We are allowed to pass a dummy `-`. (RFC8866)\n                    \"s=-\" + \"\\n\" +\n                    // Start and end of the validity of the session. `0 0` means that the session never\n                    // expires. (RFC8866)\n                    \"t=0 0\" + \"\\n\" +\n                    // A lite implementation is only appropriate for devices that will\n                    // always be connected to the public Internet and have a public\n                    // IP address at which it can receive packets from any\n                    // correspondent.  ICE will not function when a lite implementation\n                    // is placed behind a NAT (RFC8445).\n                    \"a=ice-lite\" + \"\\n\" +\n                    // A `m=` line describes a request to establish a certain protocol.\n                    // The protocol in this line (i.e. `TCP/DTLS/SCTP` or `UDP/DTLS/SCTP`) must always be\n                    // the same as the one in the offer. We know that this is true because checked above.\n                    // The `<fmt>` component must always be `webrtc-datachannel` for WebRTC.\n                    // The rest of the SDP payload adds attributes to this specific media stream.\n                    // RFCs: 8839, 8866, 8841\n                    \"m=application \" + String(targetPort) + \" \" + \"UDP/DTLS/SCTP webrtc-datachannel\" + \"\\n\" +\n                    // Indicates the IP address of the remote.\n                    // Note that \"IN\" means \"Internet\" (and not \"input\").\n                    \"c=IN IP\" + ipVersion + \" \" + targetIp + \"\\n\" +\n                    // Media ID - uniquely identifies this media stream (RFC9143).\n                    \"a=mid:0\" + \"\\n\" +\n                    // Indicates that we are complying with RFC8839 (as oppposed to the legacy RFC5245).\n                    \"a=ice-options:ice2\" + \"\\n\" +\n                    // ICE username and password, which are used for establishing and\n                    // maintaining the ICE connection. (RFC8839)\n                    // These values are set according to the libp2p WebRTC specification.\n                    \"a=ice-ufrag:\" + ufragPwd + \"\\n\" +\n                    \"a=ice-pwd:\" + ufragPwd + \"\\n\" +\n                    // Fingerprint of the certificate that the server will use during the TLS\n                    // handshake. (RFC8122)\n                    // MUST be derived from the certificate used by the answerer (server).\n                    \"a=fingerprint:sha-256 \" + fingerprint + \"\\n\" +\n                    // Indicates that the remote DTLS server will only listen for incoming\n                    // connections. (RFC5763)\n                    // The answerer (server) MUST not be located behind a NAT (RFC6135).\n                    \"a=setup:passive\" + \"\\n\" +\n                    // The SCTP port (RFC8841)\n                    // Note it's different from the \"m=\" line port value, which\n                    // indicates the port of the underlying transport-layer protocol\n                    // (UDP or TCP)\n                    \"a=sctp-port:5000\" + \"\\n\" +\n                    // The maximum SCTP user message size (in bytes) (RFC8841)\n                    // Setting this field is part of the libp2p spec.\n                    \"a=max-message-size:16384\" + \"\\n\" +\n                    // A transport address for a candidate that can be used for connectivity\n                    // checks (RFC8839).\n                    \"a=candidate:1 1 UDP 1 \" + targetIp + \" \" + String(targetPort) + \" typ host\" + \"\\n\";\n                yield state.pc.setRemoteDescription({ type: \"answer\", sdp: remoteSdp });\n            });\n            state.pc.ondatachannel = ({ channel }) => {\n                // TODO: is the substream maybe already open? according to the Internet it seems that no but it's unclear\n                addChannel(channel, 'inbound');\n            };\n            config.onMultistreamHandshakeInfo({\n                handshake: 'webrtc',\n                localTlsCertificateSha256,\n            });\n        }));\n        return {\n            reset: (streamId) => {\n                // If `streamId` is undefined, then the whole connection must be destroyed.\n                if (streamId === undefined) {\n                    killAllJs();\n                }\n                else {\n                    const channel = state.dataChannels.get(streamId);\n                    channel.channel.onopen = null;\n                    channel.channel.onerror = null;\n                    channel.channel.onclose = null;\n                    channel.channel.onbufferedamountlow = null;\n                    channel.channel.onmessage = null;\n                    channel.channel.close();\n                    state.dataChannels.delete(streamId);\n                }\n            },\n            send: (data, streamId) => {\n                const channel = state.dataChannels.get(streamId);\n                for (const buffer of data) {\n                    channel.bufferedBytes += buffer.length;\n                }\n                channel.channel.send(new Blob(data));\n            },\n            closeSend: () => { throw new Error('Wrong connection type'); },\n            openOutSubstream: () => {\n                // `openOutSubstream` can only be called after we have called `config.onOpen`,\n                // therefore `pc` is guaranteed to be non-null.\n                // Note that the label passed to `createDataChannel` is required to be empty as\n                // per the libp2p WebRTC specification.\n                // TODO: adjusting the options based on the first substream is a bit hacky\n                const opts = state.isFirstOutSubstream ? { negotiated: true, id: 0 } : {};\n                state.isFirstOutSubstream = false;\n                addChannel(state.pc.createDataChannel(\"\", opts), 'outbound');\n            }\n        };\n    }\n    else {\n        // Should never happen, as we tweak the options to refuse connection types that\n        // we don't support.\n        throw new Error();\n    }\n}\n"],
  "mappings": "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",
  "names": ["__awaiter", "__awaiter", "wasmModule", "options", "__awaiter"]
}
