{
  "version": 3,
  "sources": ["../../.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.4/node_modules/@polkadot-api/json-rpc-provider-proxy/src/json-rpc-message.ts", "../../.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.4/node_modules/@polkadot-api/json-rpc-provider-proxy/src/get-proxy.ts", "../../.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.4/node_modules/@polkadot-api/json-rpc-provider-proxy/src/get-sync-provider.ts"],
  "sourcesContent": ["export const jsonRpcMsg = <T extends {}>(msg: T) =>\n  JSON.stringify({\n    jsonrpc: \"2.0\",\n    ...msg,\n  })\n", "import { JsonRpcConnection } from \"@polkadot-api/json-rpc-provider\"\nimport { ReconnectableJsonRpcConnection } from \"./internal-types\"\nimport { jsonRpcMsg } from \"./json-rpc-message\"\n\nconst enum State {\n  Connected,\n  Connecting,\n  Done,\n}\n\nconst enum OngoingMsgType {\n  ChainHeadFollow,\n  ChainHeadOperation,\n  Other,\n}\ntype OngoingMsg =\n  | {\n      type: OngoingMsgType.ChainHeadFollow\n      msg: string\n    }\n  | { type: OngoingMsgType.ChainHeadOperation; id: string }\n  | { type: OngoingMsgType.Other; msg: string }\n\nconst unfollowMethods = new Set(\n  [\"v1\", \"unstable\"].map((x) => `chainHead_${x}_unfollow`),\n)\n\nexport const getProxy: ReconnectableJsonRpcConnection = (\n  toConsumer: (msg: string) => void,\n) => {\n  let state:\n    | {\n        type: State.Connected\n        connection: JsonRpcConnection\n        onGoingRequests: Map<string, OngoingMsg>\n        activeChainHeads: Set<string>\n      }\n    | { type: State.Connecting; pending: Array<string> }\n    | { type: State.Done } = {\n    type: State.Connecting,\n    pending: [],\n  }\n\n  const onMsgFromProvider = (msg: string) => {\n    if (state.type === State.Connected) {\n      const parsed = JSON.parse(msg)\n      if (\"id\" in parsed) {\n        if (\n          \"result\" in parsed &&\n          state.onGoingRequests.get(parsed.id)?.type ===\n            OngoingMsgType.ChainHeadFollow\n        )\n          state.activeChainHeads.add(parsed.result)\n        state.onGoingRequests.delete(parsed.id)\n      } else if (\"params\" in parsed) {\n        const { subscription, result } = parsed.params\n        if (result?.event === \"stop\")\n          state.activeChainHeads.delete(subscription)\n      }\n    }\n    // If the state is \"Connecting\", then these are messages\n    // sent from the `onHalt` function. So, we mus realy them\n    if (state.type !== State.Done) toConsumer(msg)\n  }\n\n  const send = (msg: string) => {\n    if (state.type === State.Done) return\n    if (state.type === State.Connecting) {\n      state.pending.push(msg)\n      return\n    }\n    const parsed = JSON.parse(msg)\n    if (unfollowMethods.has(parsed.method))\n      state.activeChainHeads.delete(parsed.params[0])\n\n    if (\"id\" in parsed) {\n      const { method, id } = parsed as { method: string; id: string }\n      const ongoingMsg: OngoingMsg = method.startsWith(\"chainHead\")\n        ? method.endsWith(\"follow\")\n          ? {\n              type: OngoingMsgType.ChainHeadFollow,\n              msg,\n            }\n          : { type: OngoingMsgType.ChainHeadOperation, id }\n        : { type: OngoingMsgType.Other, msg }\n      state.onGoingRequests.set(id, ongoingMsg)\n    }\n\n    state.connection.send(msg)\n  }\n\n  return {\n    send,\n    disconnect: () => {\n      if (state.type === State.Done) return\n      if (state.type === State.Connected) state.connection.disconnect()\n      state = { type: State.Done }\n    },\n    connect: (cb) => {\n      if (state.type !== State.Connecting) throw new Error(\"Nonesense\")\n\n      const { pending } = state\n      const onGoingRequests = new Map<string, OngoingMsg>()\n      const activeChainHeads = new Set<string>()\n      const onHalt = () => {\n        state = {\n          type: State.Connecting,\n          pending: [],\n        }\n        activeChainHeads.forEach((subscription) => {\n          // We don't send the messages directy to the consumer\n          // b/c they could have disconnected after receiving one\n          // of these messages. The `onMsgFromProvider` fn handles that\n          onMsgFromProvider(\n            jsonRpcMsg({\n              params: {\n                subscription,\n                result: {\n                  event: \"stop\",\n                  internal: true,\n                },\n              },\n            }),\n          )\n        })\n        activeChainHeads.clear()\n        for (const x of onGoingRequests.values()) {\n          if (x.type === OngoingMsgType.ChainHeadOperation)\n            onMsgFromProvider(\n              jsonRpcMsg({\n                id: x.id,\n                error: { code: -32603, message: \"Internal error\" },\n                internal: true,\n              }),\n            )\n          else send(x.msg)\n        }\n        onGoingRequests.clear()\n      }\n      state = {\n        type: State.Connected,\n        connection: cb(onMsgFromProvider, onHalt),\n        onGoingRequests,\n        activeChainHeads,\n      }\n      pending.forEach(send)\n    },\n  }\n}\n", "import type { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport { getProxy } from \"./get-proxy\"\nimport { AsyncJsonRpcProvider } from \"./public-types\"\nimport { ConnectableJsonRpcConnection } from \"./internal-types\"\n\nexport const getSyncProvider =\n  (input: () => Promise<AsyncJsonRpcProvider>): JsonRpcProvider =>\n  (onMessage) => {\n    let proxy: ConnectableJsonRpcConnection | null = getProxy(onMessage)\n\n    const start = () => {\n      input().then(\n        (cb) => {\n          if (!proxy) {\n            try {\n              cb(\n                () => {},\n                () => {},\n              ).disconnect()\n            } catch (_) {}\n          } else\n            proxy.connect((onMsg, onHalt) =>\n              cb(onMsg, () => {\n                onHalt()\n                start()\n              }),\n            )\n        },\n        () => {\n          proxy && setTimeout(start, 0)\n        },\n      )\n    }\n\n    start()\n    return {\n      send: (msg) => {\n        proxy?.send(msg)\n      },\n      disconnect: () => {\n        proxy?.disconnect()\n        proxy = null\n      },\n    }\n  }\n"],
  "mappings": "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",
  "names": []
}
