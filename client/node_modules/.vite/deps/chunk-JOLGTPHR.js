import {
  BehaviorSubject,
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  Subscriber,
  Subscription,
  catchError,
  combineLatest,
  combineLatestWith,
  concat,
  concatMap,
  connectable,
  defer,
  delay,
  distinct,
  distinctUntilChanged,
  exhaustMap,
  filter,
  firstValueFrom,
  from,
  identity,
  lastValueFrom,
  map,
  merge,
  mergeAll,
  mergeMap,
  noop,
  of,
  pairwise,
  pipe,
  scan,
  share,
  shareReplay,
  startWith,
  switchAll,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  tap,
  throwError,
  timer,
  withLatestFrom
} from "./chunk-AUYVYD36.js";
import {
  BLAKE2,
  SHA256_IV,
  abytes,
  aexists,
  anumber,
  aoutput,
  base58,
  blake2b,
  clean,
  compress,
  createXOFer,
  fromBig,
  keccak_256,
  swap32IfBE,
  toBytes,
  u32,
  u8
} from "./chunk-3KOWDXJX.js";
import {
  __export
} from "./chunk-2TUXWMP5.js";

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/index.mjs
var esm_exports = {};
__export(esm_exports, {
  AccountId: () => AccountId,
  Bin: () => Bin,
  Binary: () => Binary,
  Blake2128: () => Blake2128,
  Blake2128Concat: () => Blake2128Concat,
  Blake2256: () => Blake2256,
  Blake3256: () => Blake3256,
  Blake3256Concat: () => Blake3256Concat,
  Bytes: () => Bytes,
  Enum: () => Enum2,
  FixedSizeBinary: () => FixedSizeBinary,
  Hex: () => Hex,
  Identity: () => Identity,
  Option: () => Option2,
  Result: () => Result2,
  ScaleEnum: () => ScaleEnum,
  Self: () => Self,
  Storage: () => Storage,
  Struct: () => Struct2,
  Tuple: () => Tuple2,
  Twox128: () => Twox128,
  Twox256: () => Twox256,
  Twox64Concat: () => Twox64Concat,
  Variant: () => Variant,
  Vector: () => Vector2,
  _Enum: () => _Enum,
  _void: () => _void,
  bitSequence: () => bitSequence,
  blockHeader: () => blockHeader,
  bool: () => bool,
  char: () => char,
  compact: () => compact,
  compactBn: () => compactBn,
  compactNumber: () => compactNumber,
  createCodec: () => createCodec,
  createDecoder: () => createDecoder,
  decAnyMetadata: () => decAnyMetadata,
  enhanceCodec: () => enhanceCodec,
  enhanceDecoder: () => enhanceDecoder,
  enhanceEncoder: () => enhanceEncoder,
  ethAccount: () => ethAccount,
  fixedStr: () => fixedStr,
  fromBufferToBase58: () => fromBufferToBase58,
  getMultisigAccountId: () => getMultisigAccountId,
  getSs58AddressInfo: () => getSs58AddressInfo,
  h64: () => h64,
  i128: () => i128,
  i16: () => i16,
  i256: () => i256,
  i32: () => i32,
  i64: () => i64,
  i8: () => i8,
  metadata: () => metadata,
  selfDecoder: () => selfDecoder,
  selfEncoder: () => selfEncoder,
  sortMultisigSignatories: () => sortMultisigSignatories,
  str: () => str,
  u128: () => u128,
  u16: () => u16,
  u256: () => u256,
  u32: () => u322,
  u64: () => u64,
  u8: () => u82,
  v14: () => v14,
  v14Lookup: () => lookup,
  v15: () => v15
});

// node_modules/.pnpm/scale-ts@1.6.1/node_modules/scale-ts/dist/scale-ts.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var HEX_MAP = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
function fromHex(hexString) {
  const isOdd = hexString.length % 2;
  const base = (hexString[1] === "x" ? 2 : 0) + isOdd;
  const nBytes = (hexString.length - base) / 2 + isOdd;
  const bytes = new Uint8Array(nBytes);
  if (isOdd)
    bytes[0] = 0 | HEX_MAP[hexString[2]];
  for (let i = 0; i < nBytes; ) {
    const idx = base + i * 2;
    const a = HEX_MAP[hexString[idx]];
    const b = HEX_MAP[hexString[idx + 1]];
    bytes[isOdd + i++] = a << 4 | b;
  }
  return bytes;
}
var InternalUint8Array = class extends Uint8Array {
  constructor(buffer2) {
    super(buffer2);
    __publicField(this, "i", 0);
    __publicField(this, "v");
    this.v = new DataView(buffer2);
  }
};
var toInternalBytes = (fn) => (buffer2) => fn(buffer2 instanceof InternalUint8Array ? buffer2 : new InternalUint8Array(buffer2 instanceof Uint8Array ? buffer2.buffer : typeof buffer2 === "string" ? fromHex(buffer2).buffer : buffer2));
var mergeUint8 = (inputs) => {
  const len = inputs.length;
  let totalLen = 0;
  for (let i = 0; i < len; i++)
    totalLen += inputs[i].length;
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < len; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};
function mapObject(input, mapper) {
  const keys = Object.keys(input);
  const len = keys.length;
  const result = {};
  for (let i = 0; i < len; i++) {
    const key = keys[i];
    result[key] = mapper(input[key], key);
  }
  return result;
}
var createDecoder = toInternalBytes;
var createCodec = (encoder, decoder) => {
  const result = [encoder, decoder];
  result.enc = encoder;
  result.dec = decoder;
  return result;
};
var enhanceEncoder = (encoder, mapper) => (value2) => encoder(mapper(value2));
var enhanceDecoder = (decoder, mapper) => (value2) => mapper(decoder(value2));
var enhanceCodec = ([encoder, decoder], toFrom, fromTo) => createCodec(enhanceEncoder(encoder, toFrom), enhanceDecoder(decoder, fromTo));
function decodeInt(nBytes, getter) {
  return toInternalBytes((bytes) => {
    const result = bytes.v[getter](bytes.i, true);
    bytes.i += nBytes;
    return result;
  });
}
function encodeInt(nBytes, setter) {
  return (input) => {
    const result = new Uint8Array(nBytes);
    const dv = new DataView(result.buffer);
    dv[setter](0, input, true);
    return result;
  };
}
function intCodec(nBytes, getter, setter) {
  return createCodec(encodeInt(nBytes, setter), decodeInt(nBytes, getter));
}
var u82 = intCodec(1, "getUint8", "setUint8");
var u16 = intCodec(2, "getUint16", "setUint16");
var u322 = intCodec(4, "getUint32", "setUint32");
var u64 = intCodec(8, "getBigUint64", "setBigUint64");
var i8 = intCodec(1, "getInt8", "setInt8");
var i16 = intCodec(2, "getInt16", "setInt16");
var i32 = intCodec(4, "getInt32", "setInt32");
var i64 = intCodec(8, "getBigInt64", "setBigInt64");
var x128Enc = (value2) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigInt64(0, value2, true);
  dv.setBigInt64(8, value2 >> 64n, true);
  return result;
};
var create128Dec = (method) => toInternalBytes((input) => {
  const { v, i } = input;
  const right = v.getBigUint64(i, true);
  const left = v[method](i + 8, true);
  input.i += 16;
  return left << 64n | right;
});
var u128 = createCodec(x128Enc, create128Dec("getBigUint64"));
var i128 = createCodec(x128Enc, create128Dec("getBigInt64"));
var x256Enc = (value2) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigInt64(0, value2, true);
  dv.setBigInt64(8, value2 >> 64n, true);
  dv.setBigInt64(16, value2 >> 128n, true);
  dv.setBigInt64(24, value2 >> 192n, true);
  return result;
};
var create256Dec = (method) => toInternalBytes((input) => {
  let result = input.v.getBigUint64(input.i, true);
  input.i += 8;
  result |= input.v.getBigUint64(input.i, true) << 64n;
  input.i += 8;
  result |= input.v.getBigUint64(input.i, true) << 128n;
  input.i += 8;
  result |= input.v[method](input.i, true) << 192n;
  input.i += 8;
  return result;
});
var u256 = createCodec(x256Enc, create256Dec("getBigUint64"));
var i256 = createCodec(x256Enc, create256Dec("getBigInt64"));
var bool = enhanceCodec(u82, (value2) => value2 ? 1 : 0, Boolean);
var decoders = [u82[1], u16[1], u322[1]];
var compactDec = toInternalBytes((bytes) => {
  const init = bytes[bytes.i];
  const kind = init & 3;
  if (kind < 3)
    return decoders[kind](bytes) >>> 2;
  const nBytes = (init >>> 2) + 4;
  bytes.i++;
  let result = 0n;
  const nU64 = nBytes / 8 | 0;
  let shift = 0n;
  for (let i = 0; i < nU64; i++) {
    result = u64[1](bytes) << shift | result;
    shift += 64n;
  }
  let nReminders = nBytes % 8;
  if (nReminders > 3) {
    result = BigInt(u322[1](bytes)) << shift | result;
    shift += 32n;
    nReminders -= 4;
  }
  if (nReminders > 1) {
    result = BigInt(u16[1](bytes)) << shift | result;
    shift += 16n;
    nReminders -= 2;
  }
  if (nReminders)
    result = BigInt(u82[1](bytes)) << shift | result;
  return result;
});
var MIN_U64 = 1n << 56n;
var MIN_U32 = 1 << 24;
var MIN_U16 = 256;
var U32_MASK = 4294967295n;
var SINGLE_BYTE_MODE_LIMIT = 1 << 6;
var TWO_BYTE_MODE_LIMIT = 1 << 14;
var FOUR_BYTE_MODE_LIMIT = 1 << 30;
var compactEnc = (input) => {
  if (input < 0)
    throw new Error(`Wrong compact input (${input})`);
  const nInput = Number(input) << 2;
  if (input < SINGLE_BYTE_MODE_LIMIT)
    return u82[0](nInput);
  if (input < TWO_BYTE_MODE_LIMIT)
    return u16[0](nInput | 1);
  if (input < FOUR_BYTE_MODE_LIMIT)
    return u322[0](nInput | 2);
  let buffers = [new Uint8Array(1)];
  let bigValue = BigInt(input);
  while (bigValue >= MIN_U64) {
    buffers.push(u64[0](bigValue));
    bigValue >>= 64n;
  }
  if (bigValue >= MIN_U32) {
    buffers.push(u322[0](Number(bigValue & U32_MASK)));
    bigValue >>= 32n;
  }
  let smValue = Number(bigValue);
  if (smValue >= MIN_U16) {
    buffers.push(u16[0](smValue));
    smValue >>= 16;
  }
  smValue && buffers.push(u82[0](smValue));
  const result = mergeUint8(buffers);
  result[0] = result.length - 5 << 2 | 3;
  return result;
};
var compact = createCodec(compactEnc, compactDec);
var textEncoder = new TextEncoder();
var strEnc = (str2) => {
  const val = textEncoder.encode(str2);
  return mergeUint8([compact.enc(val.length), val]);
};
var textDecoder = new TextDecoder();
var strDec = toInternalBytes((bytes) => {
  let nElements = compact.dec(bytes);
  const dv = new DataView(bytes.buffer, bytes.i, nElements);
  bytes.i += nElements;
  return textDecoder.decode(dv);
});
var str = createCodec(strEnc, strDec);
var noop2 = () => {
};
var emptyArr = new Uint8Array(0);
var _void = createCodec(() => emptyArr, noop2);
var BytesEnc = (nBytes) => nBytes === void 0 ? (bytes) => mergeUint8([compact.enc(bytes.length), bytes]) : (bytes) => bytes.length === nBytes ? bytes : bytes.slice(0, nBytes);
var BytesDec = (nBytes) => toInternalBytes((bytes) => {
  const len = nBytes === void 0 ? compact.dec(bytes) : nBytes !== Infinity ? nBytes : bytes.byteLength - bytes.i;
  const result = new Uint8Array(bytes.buffer.slice(bytes.i, bytes.i + len));
  bytes.i += len;
  return result;
});
var Bytes = (nBytes) => createCodec(BytesEnc(nBytes), BytesDec(nBytes));
Bytes.enc = BytesEnc;
Bytes.dec = BytesDec;
var enumEnc = (inner, x) => {
  const keys = Object.keys(inner);
  const mappedKeys = new Map((x == null ? void 0 : x.map((actualIdx, idx) => [keys[idx], actualIdx])) ?? keys.map((key, idx) => [key, idx]));
  const getKey = (key) => mappedKeys.get(key);
  return ({ tag, value: value2 }) => mergeUint8([u82.enc(getKey(tag)), inner[tag](value2)]);
};
var enumDec = (inner, x) => {
  const keys = Object.keys(inner);
  const mappedKeys = new Map((x == null ? void 0 : x.map((actualIdx, idx) => [actualIdx, keys[idx]])) ?? keys.map((key, idx) => [idx, key]));
  return toInternalBytes((bytes) => {
    const idx = u82.dec(bytes);
    const tag = mappedKeys.get(idx);
    const innerDecoder = inner[tag];
    return {
      tag,
      value: innerDecoder(bytes)
    };
  });
};
var Enum = (inner, ...args) => createCodec(enumEnc(mapObject(inner, ([encoder]) => encoder), ...args), enumDec(mapObject(inner, ([, decoder]) => decoder), ...args));
Enum.enc = enumEnc;
Enum.dec = enumDec;
var OptionDec = (inner) => toInternalBytes((bytes) => u82[1](bytes) > 0 ? inner(bytes) : void 0);
var OptionEnc = (inner) => (value2) => {
  const result = new Uint8Array(1);
  if (value2 === void 0)
    return result;
  result[0] = 1;
  return mergeUint8([result, inner(value2)]);
};
var Option = (inner) => createCodec(OptionEnc(inner[0]), OptionDec(inner[1]));
Option.enc = OptionEnc;
Option.dec = OptionDec;
var ResultDec = (okDecoder, koDecoder) => toInternalBytes((bytes) => {
  const success = u82[1](bytes) === 0;
  const decoder = success ? okDecoder : koDecoder;
  const value2 = decoder(bytes);
  return { success, value: value2 };
});
var ResultEnc = (okEncoder, koEncoder) => ({ success, value: value2 }) => mergeUint8([
  u82[0](success ? 0 : 1),
  (success ? okEncoder : koEncoder)(value2)
]);
var Result = (okCodec, koCodec) => createCodec(ResultEnc(okCodec[0], koCodec[0]), ResultDec(okCodec[1], koCodec[1]));
Result.dec = ResultDec;
Result.enc = ResultEnc;
var TupleDec = (...decoders2) => toInternalBytes((bytes) => decoders2.map((decoder) => decoder(bytes)));
var TupleEnc = (...encoders) => (values) => mergeUint8(encoders.map((enc3, idx) => enc3(values[idx])));
var Tuple = (...codecs) => createCodec(TupleEnc(...codecs.map(([encoder]) => encoder)), TupleDec(...codecs.map(([, decoder]) => decoder)));
Tuple.enc = TupleEnc;
Tuple.dec = TupleDec;
var StructEnc = (encoders) => {
  const keys = Object.keys(encoders);
  return enhanceEncoder(Tuple.enc(...Object.values(encoders)), (input) => keys.map((k) => input[k]));
};
var StructDec = (decoders2) => {
  const keys = Object.keys(decoders2);
  return enhanceDecoder(Tuple.dec(...Object.values(decoders2)), (tuple) => Object.fromEntries(tuple.map((value2, idx) => [keys[idx], value2])));
};
var Struct = (codecs) => createCodec(StructEnc(mapObject(codecs, (x) => x[0])), StructDec(mapObject(codecs, (x) => x[1])));
Struct.enc = StructEnc;
Struct.dec = StructDec;
var VectorEnc = (inner, size) => size >= 0 ? (value2) => mergeUint8(value2.map(inner)) : (value2) => mergeUint8([compact.enc(value2.length), mergeUint8(value2.map(inner))]);
var VectorDec = (getter, size) => toInternalBytes((bytes) => {
  const nElements = size >= 0 ? size : compact.dec(bytes);
  const result = new Array(nElements);
  for (let i = 0; i < nElements; i++) {
    result[i] = getter(bytes);
  }
  return result;
});
var Vector = (inner, size) => createCodec(VectorEnc(inner[0], size), VectorDec(inner[1], size));
Vector.enc = VectorEnc;
Vector.dec = VectorDec;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/utils/ss58-util.mjs
var SS58_PREFIX = new TextEncoder().encode("SS58PRE");
var CHECKSUM_LENGTH = 2;
var getSs58AddressInfo = (address) => {
  try {
    const decoded = base58.decode(address);
    const prefixBytes = decoded.subarray(0, decoded[0] & 64 ? 2 : 1);
    const publicKey = decoded.subarray(
      prefixBytes.length,
      decoded.length - CHECKSUM_LENGTH
    );
    const checksum = decoded.subarray(prefixBytes.length + publicKey.length);
    const expectedChecksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    const isChecksumValid = checksum[0] === expectedChecksum[0] && checksum[1] === expectedChecksum[1];
    if (!isChecksumValid) return { isValid: false };
    return {
      isValid: true,
      ss58Format: prefixBytesToNumber(prefixBytes),
      publicKey: publicKey.slice()
    };
  } catch (_) {
    return { isValid: false };
  }
};
var prefixBytesToNumber = (bytes) => {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0);
};
var fromBufferToBase58 = (ss58Format) => {
  const prefixBytes = ss58Format < 64 ? Uint8Array.of(ss58Format) : Uint8Array.of(
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  );
  return (publicKey) => {
    const checksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    return base58.encode(
      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum)
    );
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/AccountId.mjs
function fromBase58ToBuffer(nBytes, _ss58Format) {
  return (address) => {
    const info = getSs58AddressInfo(address);
    if (!info.isValid) throw new Error("Invalid checksum");
    const { publicKey } = info;
    if (publicKey.length !== nBytes)
      throw new Error("Invalid public key length");
    return publicKey;
  };
}
var AccountId = (ss58Format = 42, nBytes = 32) => enhanceCodec(
  Bytes(nBytes),
  fromBase58ToBuffer(nBytes),
  fromBufferToBase58(ss58Format)
);

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/hex.mjs
var HEX_STR = "0123456789abcdef";
function toHex(bytes) {
  const result = new Array(bytes.length + 1);
  result[0] = "0x";
  for (let i = 0; i < bytes.length; ) {
    const b = bytes[i++];
    result[i] = HEX_STR[b >> 4] + HEX_STR[b & 15];
  }
  return result.join("");
}
var HEX_MAP2 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
function fromHex2(hexString) {
  const isOdd = hexString.length % 2;
  const base = (hexString[1] === "x" ? 2 : 0) + isOdd;
  const nBytes = (hexString.length - base) / 2 + isOdd;
  const bytes = new Uint8Array(nBytes);
  if (isOdd) bytes[0] = 0 | HEX_MAP2[hexString[2]];
  for (let i = 0; i < nBytes; ) {
    const idx = base + i * 2;
    const a = HEX_MAP2[hexString[idx]];
    const b = HEX_MAP2[hexString[idx + 1]];
    bytes[isOdd + i++] = a << 4 | b;
  }
  return bytes;
}

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/mapObject.mjs
function mapObject2(input, mapper) {
  return Object.fromEntries(
    Object.entries(input).map(
      ([key, value2]) => [key, mapper(value2, key)]
    )
  );
}

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/mergeUint8.mjs
var mergeUint82 = (...inputs) => {
  const totalLen = inputs.reduce((acc, a) => acc + a.byteLength, 0);
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < inputs.length; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/noop.mjs
var noop3 = Function.prototype;

// node_modules/.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/dist/esm/AbortError.mjs
var AbortError = class extends Error {
  constructor() {
    super("Abort Error");
    this.name = "AbortError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Binary.mjs
var __defProp2 = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp2 = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField2 = (obj, key, value2) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value2), value2);
var _bytes;
var _opaqueBytes;
var _hex;
var _opaqueHex;
var _str;
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var opaqueBytesDec = Tuple(compact, Bytes(Infinity))[1];
var Binary = class {
  constructor(data, opaque = false) {
    __privateAdd(this, _bytes);
    __privateAdd(this, _opaqueBytes, null);
    __privateAdd(this, _hex, null);
    __privateAdd(this, _opaqueHex, null);
    __privateAdd(this, _str, null);
    __publicField2(this, "asText", () => __privateGet(this, _str) ?? __privateSet(this, _str, textDecoder2.decode(__privateGet(this, _bytes))));
    __publicField2(this, "asHex", () => __privateGet(this, _hex) || __privateSet(this, _hex, toHex(__privateGet(this, _bytes))));
    __publicField2(this, "asOpaqueHex", () => __privateGet(this, _opaqueHex) || __privateSet(this, _opaqueHex, toHex(this.asBytes())));
    __publicField2(this, "asBytes", () => __privateGet(this, _bytes));
    __publicField2(this, "asOpaqueBytes", () => __privateGet(this, _opaqueBytes) || __privateSet(this, _opaqueBytes, mergeUint82(
      compact[0](__privateGet(this, _bytes).length),
      __privateGet(this, _bytes)
    )));
    if (opaque) {
      try {
        const [len, bytes] = opaqueBytesDec(data);
        if (len === bytes.length) {
          __privateSet(this, _bytes, bytes);
          __privateSet(this, _opaqueBytes, data);
          return;
        }
      } catch (_) {
      }
      throw new Error("Invalid opaque bytes");
    } else __privateSet(this, _bytes, data);
  }
  static fromText(input) {
    return new this(textEncoder2.encode(input));
  }
  static fromHex(input) {
    return new this(fromHex2(input));
  }
  static fromOpaqueHex(input) {
    return new this(fromHex2(input), true);
  }
  static fromBytes(input) {
    return new this(input);
  }
  static fromOpaqueBytes(input) {
    return new this(input, true);
  }
};
_bytes = /* @__PURE__ */ new WeakMap();
_opaqueBytes = /* @__PURE__ */ new WeakMap();
_hex = /* @__PURE__ */ new WeakMap();
_opaqueHex = /* @__PURE__ */ new WeakMap();
_str = /* @__PURE__ */ new WeakMap();
var [accountIdEncoder] = AccountId();
var FixedSizeBinary = class extends Binary {
  constructor(data) {
    super(data);
  }
  static fromArray(input) {
    return new this(new Uint8Array(input));
  }
  static fromAccountId32(input) {
    return new this(accountIdEncoder(input));
  }
};
var enc = (nBytes) => {
  const _enc = Bytes.enc(nBytes);
  return (value2) => _enc(value2.asBytes());
};
var dec = (nBytes) => {
  const _dec = Bytes.dec(nBytes);
  const Bin2 = nBytes == null ? Binary : FixedSizeBinary;
  return (value2) => Bin2.fromBytes(_dec(value2));
};
var Bin = (nBytes) => createCodec(enc(nBytes), dec(nBytes));
Bin.enc = enc;
Bin.dec = dec;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/compact.mjs
var compactNumber = enhanceCodec(compact, (v) => v, Number);
var compactBn = enhanceCodec(compact, (v) => v, BigInt);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/bitSequence.mjs
var bitSequenceDecoder = createDecoder((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = Bytes(bytesLen).dec(data);
  return { bytes, bitsLen };
});
var bitSequenceEncoder = (input) => {
  if (input.bitsLen > input.bytes.length * 8)
    throw new Error(
      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`
    );
  const lenEncoded = compactNumber.enc(input.bitsLen);
  const result = new Uint8Array(input.bytes.length + lenEncoded.length);
  result.set(lenEncoded, 0);
  result.set(input.bytes, lenEncoded.length);
  return result;
};
var bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/char.mjs
var char = enhanceCodec(
  u82,
  (str2) => str2.charCodeAt(0),
  String.fromCharCode
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Hex.mjs
var enc2 = (nBytes) => {
  const _enc = Bytes.enc(nBytes);
  return (value2) => _enc(fromHex2(value2));
};
var dec2 = (nBytes) => {
  const _dec = Bytes.dec(nBytes);
  return (value2) => toHex(_dec(value2));
};
var Hex = (nBytes) => createCodec(enc2(nBytes), dec2(nBytes));
Hex.enc = enc2;
Hex.dec = dec2;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/fixed-str.mjs
var textEncoder3 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var fixedStr = (nBytes) => enhanceCodec(
  Bytes(nBytes),
  (str2) => textEncoder3.encode(str2),
  (bytes) => textDecoder3.decode(bytes)
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Self.mjs
var selfEncoder = (value2) => {
  let cache = (x) => {
    const encoder = value2();
    cache = encoder;
    return encoder(x);
  };
  return (x) => cache(x);
};
var selfDecoder = (value2) => {
  let cache = (x) => {
    const decoder = value2();
    const result = decoder;
    cache = decoder;
    return result(x);
  };
  return (x) => cache(x);
};
var Self = (value2) => createCodec(
  selfEncoder(() => value2().enc),
  selfDecoder(() => value2().dec)
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/types/enum.mjs
var discriminant = {
  is(value2, type) {
    return value2.type === type;
  },
  as(value2, type) {
    if (type !== value2.type)
      throw new Error(
        `Enum.as(enum, ${type}) used with actual type ${value2.type}`
      );
    return value2;
  }
};
var Enum2 = Object.assign((type, value2) => {
  return {
    type,
    value: value2
  };
}, discriminant);
var _Enum = new Proxy(
  {},
  {
    get(_, prop) {
      return (value2) => Enum2(prop, value2);
    }
  }
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/with-inner.mjs
var withInner = (codec, inner) => {
  const result = codec;
  result.inner = inner;
  return result;
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Variant.mjs
var VariantEnc = (...args) => {
  const enc3 = Enum.enc(...args);
  return withInner((v) => enc3({ tag: v.type, value: v.value }), args[0]);
};
var VariantDec = (...args) => {
  const dec3 = Enum.dec(...args);
  return withInner((v) => {
    const { tag, value: value2 } = dec3(v);
    return Enum2(tag, value2);
  }, args[0]);
};
var Variant = (inner, ...args) => withInner(
  createCodec(
    VariantEnc(
      mapObject2(inner, ([encoder]) => encoder),
      ...args
    ),
    VariantDec(
      mapObject2(inner, ([, decoder]) => decoder),
      ...args
    )
  ),
  inner
);
Variant.enc = VariantEnc;
Variant.dec = VariantDec;
var ScaleEnum = (inner, ...args) => withInner(Enum(inner, ...args), inner);
ScaleEnum.enc = (inner, ...rest) => withInner(Enum.enc(inner, ...rest), inner);
ScaleEnum.dec = (inner, ...rest) => withInner(Enum.dec(inner, ...rest), inner);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/ethAccount.mjs
var getFormattedAddress = (hexAddress) => {
  const nonChecksum = hexAddress.slice(2);
  const hashedAddress = toHex(keccak_256(nonChecksum)).slice(2);
  const result = new Array(40);
  for (let i = 0; i < 40; i++) {
    const checksumVal = parseInt(hashedAddress[i], 16);
    const char2 = nonChecksum[i];
    result[i] = checksumVal > 7 ? char2.toUpperCase() : char2;
  }
  return `0x${result.join("")}`;
};
var bytes20Dec = Bytes(20)[1];
var ethAccount = createCodec(
  (input) => {
    const bytes = fromHex2(input);
    if (bytes.length !== 20)
      throw new Error(`Invalid length found on EthAddress(${input})`);
    const hexAddress = toHex(bytes);
    if (input === hexAddress || input === hexAddress.toUpperCase()) return bytes;
    if (getFormattedAddress(hexAddress) !== input)
      throw new Error(`Invalid checksum found on EthAddress(${input})`);
    return bytes;
  },
  createDecoder((bytes) => getFormattedAddress(toHex(bytes20Dec(bytes))))
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/shaped.mjs
var Struct2 = (codecs) => withInner(Struct(codecs), codecs);
Struct2.enc = (x) => withInner(Struct.enc(x), x);
Struct2.dec = (x) => withInner(Struct.dec(x), x);
var Tuple2 = (...inner) => withInner(Tuple(...inner), inner);
Tuple2.enc = (...inner) => withInner(Tuple.enc(...inner), inner);
Tuple2.dec = (...inner) => withInner(Tuple.dec(...inner), inner);
var Vector2 = (inner, ...rest) => withInner(Vector(inner, ...rest), inner);
Vector2.enc = (inner, ...rest) => withInner(Vector.enc(inner, ...rest), inner);
Vector2.dec = (inner, ...rest) => withInner(Vector.dec(inner, ...rest), inner);
var Result2 = (ok, ko) => withInner(Result(ok, ko), { ok, ko });
Result2.enc = (ok, ko) => withInner(Result.enc(ok, ko), { ok, ko });
Result2.dec = (ok, ko) => withInner(Result.dec(ok, ko), { ok, ko });
var Option2 = (inner) => withInner(Option(inner), inner);
Option2.enc = (inner) => withInner(Option.enc(inner), inner);
Option2.dec = (inner) => withInner(Option.dec(inner), inner);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/blockHeader.mjs
var textEncoder4 = new TextEncoder();
var textDecoder4 = new TextDecoder();
var fourChars = enhanceCodec(
  Bytes(4),
  textEncoder4.encode.bind(textEncoder4),
  textDecoder4.decode.bind(textDecoder4)
);
var diggestVal = Struct2({
  engine: fourChars,
  payload: Hex()
});
var diggest = Variant(
  {
    consensus: diggestVal,
    seal: diggestVal,
    preRuntime: diggestVal,
    runtimeUpdated: _void
  },
  [4, 5, 6, 8]
);
var hex32 = Hex(32);
var blockHeader = Struct2({
  parentHash: hex32,
  number: compactNumber,
  stateRoot: hex32,
  extrinsicRoot: hex32,
  digests: Vector2(diggest)
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/docs.mjs
var docs = Vector(str);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/lookup.mjs
var oStr = Option(str);
var primitive = Enum({
  bool: _void,
  char: _void,
  str: _void,
  u8: _void,
  u16: _void,
  u32: _void,
  u64: _void,
  u128: _void,
  u256: _void,
  i8: _void,
  i16: _void,
  i32: _void,
  i64: _void,
  i128: _void,
  i256: _void
});
var fields = Vector(
  Struct({
    name: oStr,
    type: compactNumber,
    typeName: oStr,
    docs
  })
);
var arr = Struct({
  len: u322,
  type: compactNumber
});
var bitSequence2 = Struct({
  bitStoreType: compactNumber,
  bitOrderType: compactNumber
});
var variant = Vector(
  Struct({
    name: str,
    fields,
    index: u82,
    docs
  })
);
var def = Enum({
  composite: fields,
  variant,
  sequence: compactNumber,
  array: arr,
  tuple: Vector(compactNumber),
  primitive,
  compact: compactNumber,
  bitSequence: bitSequence2
});
var param = Struct({
  name: str,
  type: Option(compactNumber)
});
var params = Vector(param);
var entry = Struct({
  id: compactNumber,
  path: docs,
  params,
  def,
  docs
});
var lookup = Vector(entry);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/pallets.mjs
var hashType = Enum({
  Blake2128: _void,
  Blake2256: _void,
  Blake2128Concat: _void,
  Twox128: _void,
  Twox256: _void,
  Twox64Concat: _void,
  Identity: _void
});
var hashers = Vector(hashType);
var storageMap = Struct({
  hashers,
  key: compactNumber,
  value: compactNumber
});
var storageItem = Struct({
  name: str,
  modifier: u82,
  type: Enum({
    plain: compactNumber,
    map: storageMap
  }),
  fallback: Hex(),
  docs
});
var storage = Option(
  Struct({
    prefix: str,
    items: Vector(storageItem)
  })
);
var v14Pallet = {
  name: str,
  storage,
  calls: Option(compactNumber),
  events: Option(compactNumber),
  constants: Vector(
    Struct({
      name: str,
      type: compactNumber,
      value: Hex(),
      docs
    })
  ),
  errors: Option(compactNumber),
  index: u82
};
var v15Pallet = {
  ...v14Pallet,
  docs
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/v14.mjs
var empty = new Uint8Array();
var Always = (value2) => createCodec(
  () => empty,
  () => value2
);
var extrinsic = Struct({
  type: compactNumber,
  version: u82,
  signedExtensions: Vector(
    Struct({
      identifier: str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v14 = Struct({
  lookup,
  pallets: Vector(Struct({ ...v14Pallet, docs: Always([]) })),
  extrinsic,
  type: compactNumber,
  apis: Always([])
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/runtime-api.mjs
var runtimeApi = Struct({
  name: str,
  methods: Vector(
    Struct({
      name: str,
      inputs: Vector(
        Struct({
          name: str,
          type: compactNumber
        })
      ),
      output: compactNumber,
      docs
    })
  ),
  docs
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/v15.mjs
var extrinsic2 = Struct({
  version: u82,
  address: compactNumber,
  call: compactNumber,
  signature: compactNumber,
  extra: compactNumber,
  signedExtensions: Vector(
    Struct({
      identifier: str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v15 = Struct({
  lookup,
  pallets: Vector(Struct(v15Pallet)),
  extrinsic: extrinsic2,
  type: compactNumber,
  apis: Vector(runtimeApi),
  outerEnums: Struct({
    call: compactNumber,
    event: compactNumber,
    error: compactNumber
  }),
  custom: Vector(Tuple(str, Struct({ type: compactNumber, value: Hex() })))
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/metadata.mjs
var unsupportedFn = () => {
  throw new Error("Unsupported metadata version!");
};
var unsupported = createCodec(
  unsupportedFn,
  unsupportedFn
);
var metadata = Struct({
  magicNumber: u322,
  metadata: Enum({
    v0: unsupported,
    v1: unsupported,
    v2: unsupported,
    v3: unsupported,
    v4: unsupported,
    v5: unsupported,
    v6: unsupported,
    v7: unsupported,
    v8: unsupported,
    v9: unsupported,
    v10: unsupported,
    v11: unsupported,
    v12: unsupported,
    v13: unsupported,
    v14,
    v15
  })
});
var opaqueBytes = Bytes();
var optionOpaque = Option(opaqueBytes);
var opaqueOpaqueBytes = Tuple(compact, opaqueBytes);
var decAnyMetadata = (input) => {
  try {
    return metadata.dec(input);
  } catch (_) {
  }
  try {
    return metadata.dec(optionOpaque.dec(input));
  } catch (_) {
  }
  try {
    return metadata.dec(opaqueBytes.dec(input));
  } catch (_) {
  }
  try {
    return metadata.dec(opaqueOpaqueBytes.dec(input)[1]);
  } catch (_) {
  }
  throw null;
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/blake2.mjs
var len32 = { dkLen: 32 };
var Blake2256 = (encoded) => blake2b(encoded, len32);
var len16 = { dkLen: 16 };
var Blake2128 = (encoded) => blake2b(encoded, len16);
var Blake2128Concat = (encoded) => mergeUint82(Blake2128(encoded), encoded);

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/blake3.js
var B3_Flags = {
  CHUNK_START: 1,
  CHUNK_END: 2,
  PARENT: 4,
  ROOT: 8,
  KEYED_HASH: 16,
  DERIVE_KEY_CONTEXT: 32,
  DERIVE_KEY_MATERIAL: 64
};
var B3_IV = SHA256_IV.slice();
var B3_SIGMA = (() => {
  const Id = Array.from({ length: 16 }, (_, i) => i);
  const permute = (arr2) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr2[i]);
  const res = [];
  for (let i = 0, v = Id; i < 7; i++, v = permute(v))
    res.push(...v);
  return Uint8Array.from(res);
})();
var BLAKE3 = class _BLAKE3 extends BLAKE2 {
  constructor(opts = {}, flags = 0) {
    super(64, opts.dkLen === void 0 ? 32 : opts.dkLen);
    this.chunkPos = 0;
    this.chunksDone = 0;
    this.flags = 0 | 0;
    this.stack = [];
    this.posOut = 0;
    this.bufferOut32 = new Uint32Array(16);
    this.chunkOut = 0;
    this.enableXOF = true;
    const { key, context } = opts;
    const hasContext = context !== void 0;
    if (key !== void 0) {
      if (hasContext)
        throw new Error('Only "key" or "context" can be specified at same time');
      const k = toBytes(key).slice();
      abytes(k, 32);
      this.IV = u32(k);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.KEYED_HASH;
    } else if (hasContext) {
      const ctx = toBytes(context);
      const contextKey = new _BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
      this.IV = u32(contextKey);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
    } else {
      this.IV = B3_IV.slice();
      this.flags = flags;
    }
    this.state = this.IV.slice();
    this.bufferOut = u8(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(counter, flags, buf, bufPos = 0) {
    const { state: s, pos } = this;
    const { h, l } = fromBig(BigInt(counter), true);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 } = compress(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);
    s[0] = v0 ^ v8;
    s[1] = v1 ^ v9;
    s[2] = v2 ^ v10;
    s[3] = v3 ^ v11;
    s[4] = v4 ^ v12;
    s[5] = v5 ^ v13;
    s[6] = v6 ^ v142;
    s[7] = v7 ^ v152;
  }
  compress(buf, bufPos = 0, isLast = false) {
    let flags = this.flags;
    if (!this.chunkPos)
      flags |= B3_Flags.CHUNK_START;
    if (this.chunkPos === 15 || isLast)
      flags |= B3_Flags.CHUNK_END;
    if (!isLast)
      this.pos = this.blockLen;
    this.b2Compress(this.chunksDone, flags, buf, bufPos);
    this.chunkPos += 1;
    if (this.chunkPos === 16 || isLast) {
      let chunk = this.state;
      this.state = this.IV.slice();
      for (let last2, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
        if (!(last2 = this.stack.pop()))
          break;
        this.buffer32.set(last2, 0);
        this.buffer32.set(chunk, 8);
        this.pos = this.blockLen;
        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
        chunk = this.state;
        this.state = this.IV.slice();
      }
      this.chunksDone++;
      this.chunkPos = 0;
      this.stack.push(chunk);
    }
    this.pos = 0;
  }
  _cloneInto(to) {
    to = super._cloneInto(to);
    const { IV, flags, state: state3, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
    to.state.set(state3.slice());
    to.stack = stack.map((i) => Uint32Array.from(i));
    to.IV.set(IV);
    to.flags = flags;
    to.chunkPos = chunkPos;
    to.chunksDone = chunksDone;
    to.posOut = posOut;
    to.chunkOut = chunkOut;
    to.enableXOF = this.enableXOF;
    to.bufferOut32.set(this.bufferOut32);
    return to;
  }
  destroy() {
    this.destroyed = true;
    clean(this.state, this.buffer32, this.IV, this.bufferOut32);
    clean(...this.stack);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;
    const { h, l } = fromBig(BigInt(this.chunkOut++));
    swap32IfBE(buffer32);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 } = compress(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);
    out32[0] = v0 ^ v8;
    out32[1] = v1 ^ v9;
    out32[2] = v2 ^ v10;
    out32[3] = v3 ^ v11;
    out32[4] = v4 ^ v12;
    out32[5] = v5 ^ v13;
    out32[6] = v6 ^ v142;
    out32[7] = v7 ^ v152;
    out32[8] = s[0] ^ v8;
    out32[9] = s[1] ^ v9;
    out32[10] = s[2] ^ v10;
    out32[11] = s[3] ^ v11;
    out32[12] = s[4] ^ v12;
    out32[13] = s[5] ^ v13;
    out32[14] = s[6] ^ v142;
    out32[15] = s[7] ^ v152;
    swap32IfBE(buffer32);
    swap32IfBE(out32);
    this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    clean(this.buffer.subarray(this.pos));
    let flags = this.flags | B3_Flags.ROOT;
    if (this.stack.length) {
      flags |= B3_Flags.PARENT;
      swap32IfBE(this.buffer32);
      this.compress(this.buffer32, 0, true);
      swap32IfBE(this.buffer32);
      this.chunksDone = 0;
      this.pos = this.blockLen;
    } else {
      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
    }
    this.flags = flags;
    this.b2CompressOut();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const { blockLen, bufferOut } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.b2CompressOut();
      const take2 = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
      this.posOut += take2;
      pos += take2;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.enableXOF = false;
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
};
var blake3 = createXOFer((opts) => new BLAKE3(opts));

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/blake3.mjs
var len322 = { dkLen: 32 };
var Blake3256 = (encoded) => blake3(encoded, len322);
var Blake3256Concat = (encoded) => mergeUint82(Blake3256(encoded), encoded);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/identity.mjs
var Identity = (encoded) => encoded;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/h64.mjs
var bigintFromU16 = (v0, v1, v2, v3) => new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true);
var MASK_64 = 2n ** 64n - 1n;
var rotl = (input, nBits) => input << nBits & MASK_64 | input >> 64n - nBits;
var multiply = (a, b) => a * b & MASK_64;
var add = (a, b) => a + b & MASK_64;
var PRIME64_1 = 11400714785074694791n;
var PRIME64_2 = 14029467366897019727n;
var PRIME64_3 = 1609587929392839161n;
var PRIME64_4 = 9650029242287828579n;
var PRIME64_5 = 2870177450012600261n;
function h64(input, seed = 0n) {
  let v1 = add(add(seed, PRIME64_1), PRIME64_2);
  let v2 = add(seed, PRIME64_2);
  let v3 = seed;
  let v4 = seed - PRIME64_1;
  let totalLen = input.length;
  let memsize = 0;
  let memory = null;
  (function update() {
    let p2 = 0;
    let bEnd = p2 + totalLen;
    if (!totalLen) return;
    memory = new Uint8Array(32);
    if (totalLen < 32) {
      memory.set(input.subarray(0, totalLen), memsize);
      memsize += totalLen;
      return;
    }
    if (p2 <= bEnd - 32) {
      const limit = bEnd - 32;
      do {
        let other;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
      } while (p2 <= limit);
    }
    if (p2 < bEnd) {
      memory.set(input.subarray(p2, bEnd), memsize);
      memsize = bEnd - p2;
    }
  })();
  input = memory || input;
  let result;
  let p = 0;
  if (totalLen >= 32) {
    result = rotl(v1, 1n);
    result = add(result, rotl(v2, 7n));
    result = add(result, rotl(v3, 12n));
    result = add(result, rotl(v4, 18n));
    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v1;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v2;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v3;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v4;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
  } else {
    result = add(seed, PRIME64_5);
  }
  result = add(result, BigInt(totalLen));
  while (p <= memsize - 8) {
    let temp2 = bigintFromU16(
      input[p + 1] << 8 | input[p],
      input[p + 3] << 8 | input[p + 2],
      input[p + 5] << 8 | input[p + 4],
      input[p + 7] << 8 | input[p + 6]
    );
    temp2 = multiply(rotl(multiply(temp2, PRIME64_2), 31n), PRIME64_1);
    result = add(multiply(rotl(result ^ temp2, 27n), PRIME64_1), PRIME64_4);
    p += 8;
  }
  if (p + 4 <= memsize) {
    let temp2 = multiply(
      bigintFromU16(
        input[p + 1] << 8 | input[p],
        input[p + 3] << 8 | input[p + 2],
        0,
        0
      ),
      PRIME64_1
    );
    result = add(multiply(rotl(result ^ temp2, 23n), PRIME64_2), PRIME64_3);
    p += 4;
  }
  while (p < memsize) {
    const temp2 = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5);
    result = multiply(rotl(result ^ temp2, 11n), PRIME64_1);
  }
  let temp = result >> 33n;
  result = multiply(result ^ temp, PRIME64_2);
  temp = result >> 29n;
  result = multiply(result ^ temp, PRIME64_3);
  temp = result >> 32n;
  result ^= temp;
  return result;
}

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/twoX.mjs
var Twox128 = (input) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  return result;
};
var Twox256 = (input) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  dv.setBigUint64(16, h64(input, 2n), true);
  dv.setBigUint64(24, h64(input, 3n), true);
  return result;
};
var Twox64Concat = (encoded) => mergeUint82(u64.enc(h64(encoded)), encoded);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/storage.mjs
var textEncoder5 = new TextEncoder();
var hashers2 = /* @__PURE__ */ new Map([
  [Identity, 0],
  [Twox64Concat, 8],
  [Blake2128Concat, 16],
  [Blake2128, -16],
  [Blake2256, -32],
  [Twox128, -16],
  [Twox256, -32]
]);
var Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder5.encode(pallet));
  return (name, ...encoders) => {
    const palletItemEncoded = mergeUint82(
      palledEncoded,
      Twox128(textEncoder5.encode(name))
    );
    const palletItemEncodedHex = toHex(palletItemEncoded);
    const dec3 = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (encoders.length === 0) return [];
      const argsKey = fromHex2(key.slice(palletItemEncodedHex.length));
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < encoders.length; i++) {
        const [codec, hasher] = encoders[i];
        const hBytes = hashers2.get(hasher);
        if (hBytes == null) throw new Error("Unknown hasher");
        if (hBytes < 0) {
          const opaqueBytes3 = hBytes * -1;
          result[i] = toHex(argsKey.slice(cur, cur + opaqueBytes3));
          cur += opaqueBytes3;
        } else {
          cur += hBytes;
          result[i] = codec.dec(argsKey.slice(cur));
          cur += codec.enc(result[i]).length;
        }
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc22 }, hash]) => (val) => hash(enc22(val))
    );
    const enc3 = (...args) => toHex(
      mergeUint82(palletItemEncoded, ...args.map((val, idx) => fns[idx](val)))
    );
    return {
      enc: enc3,
      dec: dec3
    };
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/utils/multisig.mjs
var PREFIX = Binary.fromText("modlpy/utilisuba").asBytes();
var getMultisigAccountId = ({
  threshold,
  signatories
}) => {
  const sortedSignatories = sortMultisigSignatories(signatories);
  const payload = mergeUint82(
    PREFIX,
    compact.enc(sortedSignatories.length),
    ...sortedSignatories,
    u16.enc(threshold)
  );
  return Blake2256(payload);
};
var sortMultisigSignatories = (signatories) => signatories.slice().sort((a, b) => {
  for (let i = 0; ; i++) {
    const overA = i >= a.length;
    const overB = i >= b.length;
    if (overA && overB) return 0;
    else if (overA) return -1;
    else if (overB) return 1;
    else if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
  }
});

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/dist/esm/typedef.mjs
var smallCompact = compactNumber;
var StructCodec = Vector2(Tuple2(str, smallCompact));
var Primitive = {
  bool: "boolean",
  str: "string",
  num: "number",
  big: "bigint",
  bits: "bitseq",
  void: "void"
};
var TerminalCodec = Variant(
  Object.fromEntries(
    Object.values(Primitive).map((p) => [p, _void])
  )
);
var EnumCodec = Vector2(
  Tuple2(
    str,
    Variant({
      inline: Self(() => TypedefCodec),
      lookup: smallCompact
    })
  )
);
var TupleCodec = Vector2(smallCompact);
var ArrayCodec = Struct2({
  typeRef: smallCompact,
  length: Option2(smallCompact)
});
var BinaryCodec = Option2(smallCompact);
var OptionCodec = smallCompact;
var ResultCodec = Struct2({
  ok: smallCompact,
  ko: smallCompact
});
var TypedefCodec = Variant({
  struct: StructCodec,
  terminal: TerminalCodec,
  enum: EnumCodec,
  tuple: TupleCodec,
  array: ArrayCodec,
  binary: BinaryCodec,
  option: OptionCodec,
  result: ResultCodec
});
var primitiveToTerminal = {
  i256: Primitive.big,
  i128: Primitive.big,
  i64: Primitive.big,
  i32: Primitive.num,
  i16: Primitive.num,
  i8: Primitive.num,
  u256: Primitive.big,
  u128: Primitive.big,
  u64: Primitive.big,
  u32: Primitive.num,
  u16: Primitive.num,
  u8: Primitive.num,
  bool: Primitive.bool,
  char: Primitive.str,
  str: Primitive.str
};
var terminal = (type) => ({
  type: "terminal",
  value: { type }
});
function mapLookupToTypedef(entry2, resolve = () => {
}) {
  switch (entry2.type) {
    case "AccountId20":
    case "AccountId32":
      return terminal(Primitive.str);
    case "array":
      if (entry2.value.type === "primitive" && entry2.value.value === "u8") {
        return { type: "binary", value: entry2.len };
      }
      resolve(entry2.value.id);
      return {
        type: "array",
        value: {
          typeRef: entry2.value.id,
          length: entry2.len
        }
      };
    case "bitSequence":
      return terminal(Primitive.bits);
    case "compact":
      return terminal(entry2.isBig ? Primitive.big : Primitive.num);
    case "enum":
      return {
        type: "enum",
        value: Object.entries(entry2.value).map(
          ([key, params2]) => {
            if (params2.type !== "lookupEntry")
              return [
                key,
                { type: "inline", value: mapLookupToTypedef(params2, resolve) }
              ];
            resolve(params2.value.id);
            return [
              key,
              {
                type: "lookup",
                value: params2.value.id
              }
            ];
          }
        )
      };
    case "struct": {
      const value2 = Object.entries(entry2.value).map(
        ([key, prop]) => [key, prop.id]
      );
      value2.forEach(([, v]) => resolve(v));
      return {
        type: "struct",
        value: value2
      };
    }
    case "tuple": {
      const value2 = entry2.value.map((v) => v.id);
      value2.forEach(resolve);
      return {
        type: "tuple",
        value: value2
      };
    }
    case "option":
      resolve(entry2.value.id);
      return {
        type: "option",
        value: entry2.value.id
      };
    case "primitive":
      return terminal(primitiveToTerminal[entry2.value]);
    case "result":
      resolve(entry2.value.ok.id);
      resolve(entry2.value.ko.id);
      return {
        type: "result",
        value: {
          ok: entry2.value.ok.id,
          ko: entry2.value.ko.id
        }
      };
    case "sequence":
      if (entry2.value.type === "primitive" && entry2.value.value === "u8") {
        return { type: "binary", value: void 0 };
      }
      resolve(entry2.value.id);
      return {
        type: "array",
        value: { typeRef: entry2.value.id }
      };
    case "void":
      return terminal(Primitive.void);
  }
}

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/dist/esm/isCompatible.mjs
function isCompatible(value2, destNode, getNode) {
  if (destNode.type === "option" && value2 == null) {
    return true;
  }
  const nextCall = (value22, destNode2) => isCompatible(value22, destNode2, getNode);
  const checkTerminal = (terminal2) => {
    switch (terminal2.value.type) {
      case Primitive.str:
      case Primitive.big:
      case Primitive.bool:
      case Primitive.num:
        return typeof value2 === terminal2.value.type;
      case Primitive.bits:
        return typeof value2 === "object" && value2 != null && typeof value2.bitsLen === "number" && value2.bytes instanceof Uint8Array;
      case Primitive.void:
        return true;
    }
  };
  switch (destNode.type) {
    case "terminal":
      return checkTerminal(destNode);
    case "binary":
      return value2 instanceof Binary && (destNode.value == null || value2.asBytes().length >= destNode.value);
    case "array":
      if (!Array.isArray(value2)) return false;
      const valueArr = value2;
      if (destNode.value.length != null && valueArr.length < destNode.value.length) {
        return false;
      }
      return valueArr.slice(0, destNode.value.length).every((value22) => nextCall(value22, getNode(destNode.value.typeRef)));
    case "enum":
      if (!value2) return false;
      const valueEnum = value2;
      const destVariants = Object.fromEntries(destNode.value);
      if (!(valueEnum.type in destVariants)) {
        return false;
      }
      const variantValue = destVariants[valueEnum.type];
      if (variantValue == null) {
        return true;
      }
      return nextCall(
        valueEnum.value,
        variantValue.type === "inline" ? variantValue.value : getNode(variantValue.value)
      );
    case "option":
      if (value2 == null) {
        return true;
      }
      return nextCall(value2, getNode(destNode.value));
    case "struct":
      if (!value2) return false;
      return destNode.value.every(
        ([key, typeRef]) => nextCall(value2[key], getNode(typeRef))
      );
    case "tuple":
      if (!value2) return false;
      return destNode.value.every(
        (typeRef, idx) => nextCall(value2[idx], getNode(typeRef))
      );
    case "result":
      if (!("success" in value2 && "value" in value2)) return false;
      return nextCall(
        value2.value,
        getNode(value2.success ? destNode.value.ok : destNode.value.ko)
      );
  }
}

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/dist/esm/doubleSet.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value2) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField3 = (obj, key, value2) => __defNormalProp3(obj, key + "", value2);
var DoubleSet = class {
  constructor(values = []) {
    __publicField3(this, "value", /* @__PURE__ */ new Map());
    values.forEach(([a, b]) => this.add(a, b));
  }
  has(a, b) {
    var _a;
    return ((_a = this.value.get(a)) == null ? void 0 : _a.has(b)) ?? false;
  }
  add(a, b) {
    if (!this.value.has(a)) {
      this.value.set(a, /* @__PURE__ */ new Set());
    }
    this.value.get(a).add(b);
  }
  addAll(values) {
    values.forEach(([a, b]) => this.add(a, b));
  }
  delete(a, b) {
    if (!this.value.has(a)) return;
    const set = this.value.get(a);
    set.delete(b);
    if (!set.size) {
      this.value.delete(a);
    }
  }
  isEmpty() {
    return !this.value.size;
  }
  get values() {
    return Array.from(this.value).flatMap(
      ([a, values]) => Array.from(values).map((b) => [a, b])
    );
  }
};

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/dist/esm/isStaticCompatible.mjs
var CompatibilityLevel = ((CompatibilityLevel2) => {
  CompatibilityLevel2[CompatibilityLevel2["Incompatible"] = 0] = "Incompatible";
  CompatibilityLevel2[CompatibilityLevel2["Partial"] = 1] = "Partial";
  CompatibilityLevel2[CompatibilityLevel2["BackwardsCompatible"] = 2] = "BackwardsCompatible";
  CompatibilityLevel2[CompatibilityLevel2["Identical"] = 3] = "Identical";
  return CompatibilityLevel2;
})(CompatibilityLevel || {});
function isStaticCompatible(originNode, getOriginNode, destNode, getDestNode, cache) {
  if (!destNode && !originNode) {
    return unconditional(
      3
      /* Identical */
    );
  }
  if (!destNode) return unconditional(
    2
    /* BackwardsCompatible */
  );
  if (!originNode)
    return unconditional(
      destNode.type === "option" ? 2 : 0
      /* Incompatible */
    );
  if (!cache.has(destNode)) {
    cache.set(destNode, /* @__PURE__ */ new Map());
  }
  const destNodeCache = cache.get(destNode);
  if (destNodeCache.has(originNode)) {
    const result2 = destNodeCache.get(originNode);
    if (result2 === null) {
      return {
        level: 3,
        assumptions: new DoubleSet([[originNode, destNode]])
      };
    }
    return unconditional(result2);
  }
  destNodeCache.set(originNode, null);
  const result = getIsStaticCompatible(
    originNode,
    destNode,
    (originNode2, destNode2) => isStaticCompatible(
      typeof originNode2 === "number" ? getOriginNode(originNode2) : originNode2,
      getOriginNode,
      typeof destNode2 === "number" ? getDestNode(destNode2) : destNode2,
      getDestNode,
      cache
    )
  );
  result.assumptions.delete(originNode, destNode);
  if (result.assumptions.isEmpty() || result.level === 0) {
    destNodeCache.set(originNode, result.level);
  } else {
    destNodeCache.delete(originNode);
  }
  return result;
}
function getIsStaticCompatible(originNode, destNode, nextCall) {
  if (originNode.type !== destNode.type) {
    if (destNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode, destNode.value),
        2
        /* BackwardsCompatible */
      );
    }
    if (originNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode.value, destNode),
        1
        /* Partial */
      );
    }
    return unconditional(
      0
      /* Incompatible */
    );
  }
  switch (destNode.type) {
    case "terminal":
      return unconditional(
        destNode.value.type === originNode.value.type ? 3 : 0
        /* Incompatible */
      );
    case "binary":
      const binaryOrigin = originNode;
      return unconditional(
        compareOptionalLengths(binaryOrigin.value, destNode.value)
      );
    case "array":
      const arrayOrigin = originNode;
      const lengthCheck = unconditional(
        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length)
      );
      return strictMerge([
        lengthCheck,
        () => nextCall(arrayOrigin.value.typeRef, destNode.value.typeRef)
      ]);
    case "enum": {
      const enumOrigin = originNode;
      const destVariants = Object.fromEntries(
        destNode.value.map(([key, value2]) => [key, value2.value])
      );
      const maxLevel2 = enumOrigin.value.length === destNode.value.length ? 3 : 2;
      return withMaxLevel(
        mergeResults(
          enumOrigin.value.map(
            ([type, value2]) => () => type in destVariants ? nextCall(value2.value, destVariants[type]) : unconditional(
              0
              /* Incompatible */
            )
          )
        ),
        maxLevel2
      );
    }
    case "option":
      return nextCall(originNode.value, destNode.value);
    case "struct":
      const structOrigin = originNode;
      const originProperties = Object.fromEntries(structOrigin.value);
      const maxLevel = structOrigin.value.length === destNode.value.length ? 3 : 2;
      return withMaxLevel(
        strictMerge(
          destNode.value.map(
            ([key, value2]) => () => nextCall(originProperties[key], value2)
          )
        ),
        maxLevel
      );
    case "tuple": {
      const tupleOrigin = originNode;
      const lengthCheck2 = unconditional(
        compareArrayLengths(tupleOrigin.value, destNode.value)
      );
      return strictMerge([
        lengthCheck2,
        ...destNode.value.map(
          (value2, idx) => () => nextCall(tupleOrigin.value[idx], value2)
        )
      ]);
    }
    case "result":
      const resultOrigin = originNode;
      return mergeResults([
        nextCall(resultOrigin.value.ok, destNode.value.ok),
        nextCall(resultOrigin.value.ko, destNode.value.ko)
      ]);
  }
}
var withMaxLevel = (result, level) => ({
  ...result,
  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result
  level: Math.min(result.level, level)
});
var noAssumptions = new DoubleSet();
var unconditional = (level) => ({
  level,
  assumptions: noAssumptions
});
var strictMerge = (results) => {
  let merged = unconditional(
    3
    /* Identical */
  );
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level === 0) return result;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return merged;
};
var mergeResults = (results) => {
  if (!results.length) return unconditional(
    3
    /* Identical */
  );
  let hasCompatibles = false;
  let merged = unconditional(
    3
    /* Identical */
  );
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level === 0) {
      merged.level = Math.min(
        merged.level,
        1
        /* Partial */
      );
      continue;
    }
    hasCompatibles = true;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return hasCompatibles ? merged : unconditional(
    0
    /* Incompatible */
  );
};
var compareArrayLengths = (origin, dest) => dest.length === origin.length ? 3 : origin.length >= dest.length ? 2 : 0;
var compareOptionalLengths = (origin, dest) => dest === origin ? 3 : dest == null || origin >= dest ? 2 : origin == null ? 1 : 0;

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/dist/esm/entryPoint.mjs
var EntryPointNodeCodec = Variant({
  lookup: compactNumber,
  typedef: TypedefCodec
});
var lookupNode = (value2) => ({
  type: "lookup",
  value: value2
});
var typedefNode = (value2) => ({
  type: "typedef",
  value: value2
});
var voidEntryPointNode = typedefNode({
  type: "terminal",
  value: { type: Primitive.void }
});
var EntryPointCodec = Struct2({
  args: EntryPointNodeCodec,
  values: EntryPointNodeCodec
});
function storageEntryPoint(storageEntry) {
  if (storageEntry.type.tag === "plain")
    return {
      args: voidEntryPointNode,
      values: lookupNode(storageEntry.type.value)
    };
  const { key, value: value2 } = storageEntry.type.value;
  return {
    args: lookupNode(key),
    values: lookupNode(value2)
  };
}
function runtimeCallEntryPoint(entry2) {
  return {
    args: typedefNode({
      type: "tuple",
      value: entry2.inputs.map((v) => v.type)
    }),
    values: lookupNode(entry2.output)
  };
}
function enumValueEntryPointNode(entry2) {
  return entry2.type === "lookupEntry" ? lookupNode(entry2.value.id) : typedefNode(mapLookupToTypedef(entry2));
}
function singleValueEntryPoint(value2) {
  return {
    args: voidEntryPointNode,
    values: lookupNode(value2)
  };
}
function entryPointsAreCompatible(descriptorEntry, getDescriptorNode, runtimeEntry, getRuntimeNode, cache) {
  const resolveNode = (node, getTypedef) => node.type === "lookup" ? getTypedef(node.value) : node.value;
  return {
    args: isStaticCompatible(
      resolveNode(descriptorEntry.args, getDescriptorNode),
      getDescriptorNode,
      resolveNode(runtimeEntry.args, getRuntimeNode),
      getRuntimeNode,
      cache
    ).level,
    values: isStaticCompatible(
      resolveNode(runtimeEntry.values, getRuntimeNode),
      getRuntimeNode,
      resolveNode(descriptorEntry.values, getDescriptorNode),
      getDescriptorNode,
      cache
    ).level
  };
}
function valueIsCompatibleWithDest(dest, getDestNode, value2) {
  const node = dest.type === "lookup" ? getDestNode(dest.value) : dest.value;
  return isCompatible(value2, node, getDestNode);
}

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/noop.mjs
var noop4 = () => {
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/methods.mjs
var chainHead = {
  body: "",
  call: "",
  continue: "",
  follow: "",
  header: "",
  stopOperation: "",
  storage: "",
  unfollow: "",
  unpin: "",
  followEvent: ""
};
var chainSpec = {
  chainName: "",
  genesisHash: "",
  properties: ""
};
var transaction = {
  broadcast: "",
  stop: ""
};
Object.entries({ chainHead, chainSpec, transaction }).forEach(
  ([fnGroupName, methods]) => {
    Object.keys(methods).forEach((methodName) => {
      methods[methodName] = `${fnGroupName}_v1_${methodName}`;
    });
  }
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/transaction/transaction.mjs
var getTransaction = (request) => (tx, error) => {
  let cancel = request(transaction.broadcast, [tx], {
    onSuccess: (subscriptionId) => {
      cancel = subscriptionId === null ? noop4 : () => {
        request(transaction.stop, [subscriptionId]);
      };
      if (subscriptionId === null) {
        error(new Error("Max # of broadcasted transactions has been reached"));
      }
    },
    onError: error
  });
  return () => {
    cancel();
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/errors.mjs
var StopError = class extends Error {
  constructor() {
    super("ChainHead stopped");
    this.name = "StopError";
  }
};
var DisjointError = class extends Error {
  constructor() {
    super("ChainHead disjointed");
    this.name = "DisjointError";
  }
};
var OperationLimitError = class extends Error {
  constructor() {
    super("ChainHead operations limit reached");
    this.name = "OperationLimitError";
  }
};
var OperationError = class extends Error {
  constructor(error) {
    super(error);
    this.name = "OperationError";
  }
};
var OperationInaccessibleError = class extends Error {
  constructor() {
    super("ChainHead operation inaccessible");
    this.name = "OperationInaccessibleError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/deferred-promise.mjs
function deferred() {
  let res = () => {
  };
  let rej = () => {
  };
  const promise = new Promise((_res, _rej) => {
    res = _res;
    rej = _rej;
  });
  return { promise, res, rej };
}

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/subscriptions-manager.mjs
var getSubscriptionsManager = () => {
  const subscriptions = /* @__PURE__ */ new Map();
  return {
    has: subscriptions.has.bind(subscriptions),
    subscribe(id, subscriber) {
      subscriptions.set(id, subscriber);
    },
    unsubscribe(id) {
      subscriptions.delete(id);
    },
    next(id, data) {
      var _a;
      (_a = subscriptions.get(id)) == null ? void 0 : _a.next(data);
    },
    error(id, e) {
      const subscriber = subscriptions.get(id);
      if (subscriber) {
        subscriptions.delete(id);
        subscriber.error(e);
      }
    },
    errorAll(e) {
      const subscribers = [...subscriptions.values()];
      subscriptions.clear();
      subscribers.forEach((s) => {
        s.error(e);
      });
    }
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/abortablePromiseFn.mjs
var abortablePromiseFn = (fn) => (...args) => new Promise((res, rej) => {
  let cancel = noop3;
  const [actualArgs, abortSignal] = args[args.length - 1] instanceof AbortSignal ? [args.slice(0, args.length - 1), args[args.length - 1]] : [args];
  const onAbort = () => {
    cancel();
    rej(new AbortError());
  };
  abortSignal == null ? void 0 : abortSignal.addEventListener("abort", onAbort, { once: true });
  const withCleanup = (fn2) => (x) => {
    cancel = noop3;
    abortSignal == null ? void 0 : abortSignal.removeEventListener("abort", onAbort);
    fn2(x);
  };
  cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs]);
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/operation-promise.mjs
var createOperationPromise = (operationName, factory) => (request) => abortablePromiseFn((res, rej, ...args) => {
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  const [requestArgs, logicCb] = factory(...args);
  request(operationName, requestArgs, {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached")
        return rej(new OperationLimitError());
      const { operationId } = response;
      const stopOperation = () => {
        request(chainHead.stopOperation, [operationId]);
      };
      if (!isRunning) return stopOperation();
      let done = noop4;
      const _res = (x) => {
        isRunning = false;
        done();
        res(x);
      };
      const _rej = (x) => {
        isRunning = false;
        done();
        rej(x);
      };
      done = followSubscription(operationId, {
        next: (e) => {
          const _e = e;
          if (_e.event === "operationError")
            rej(new OperationError(_e.error));
          else if (_e.event === "operationInaccessible")
            rej(new OperationInaccessibleError());
          else logicCb(e, _res, _rej);
        },
        error: _rej
      });
      cancel = () => {
        if (isRunning) {
          done();
          stopOperation();
        }
      };
    },
    onError: rej
  });
  return () => {
    cancel();
  };
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/body.mjs
var createBodyFn = createOperationPromise(
  chainHead.body,
  (hash) => [
    [hash],
    (e, res) => {
      res(e.value);
    }
  ]
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/call.mjs
var createCallFn = createOperationPromise(
  chainHead.call,
  (hash, fnName, callParameters) => [
    [hash, fnName, callParameters],
    (e, res) => {
      res(e.output);
    }
  ]
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/header.mjs
var createHeaderFn = (request) => (hash) => new Promise((res, rej) => {
  request(chainHead.header, [hash], {
    onSuccess: res,
    onError: rej
  });
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/storage-subscription.mjs
var createStorageCb = (request) => (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {
  if (inputs.length === 0) {
    onDone();
    return noop3;
  }
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  request(chainHead.storage, [hash, inputs, childTrie], {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached" || response.discardedItems === inputs.length)
        return onError(new OperationLimitError());
      const { operationId } = response;
      const stopOperation = () => {
        request(chainHead.stopOperation, [operationId]);
      };
      if (!isRunning) return stopOperation();
      const doneListening = followSubscription(response.operationId, {
        next: (event) => {
          switch (event.event) {
            case "operationStorageItems": {
              onItems(event.items);
              break;
            }
            case "operationStorageDone": {
              _onDone();
              break;
            }
            case "operationError": {
              _onError(new OperationError(event.error));
              break;
            }
            case "operationInaccessible": {
              _onError(new OperationInaccessibleError());
              break;
            }
            default:
              request(chainHead.continue, [event.operationId]);
          }
        },
        error: onError
      });
      cancel = () => {
        doneListening();
        request(chainHead.stopOperation, [response.operationId]);
      };
      const _onError = (e) => {
        cancel = noop3;
        doneListening();
        onError(e);
      };
      const _onDone = () => {
        cancel = noop3;
        doneListening();
        onDone();
      };
      onDiscardedItems(response.discardedItems);
    },
    onError
  });
  return () => {
    cancel();
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/storage.mjs
var createStorageFn = (request) => {
  const cbStore = createStorageCb(request);
  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {
    const isDescendants = type.startsWith("descendants");
    let result = isDescendants ? [] : null;
    const onItems = isDescendants ? (items) => {
      result.push(items);
    } : (items) => {
      var _a;
      result = (_a = items[0]) == null ? void 0 : _a[type];
    };
    const cancel = cbStore(
      hash,
      [{ key, type }],
      childTrie ?? null,
      onItems,
      reject,
      () => {
        try {
          resolve(isDescendants ? result.flat() : result);
        } catch (e) {
          reject(e);
        }
      },
      (nDiscarded) => {
        if (nDiscarded > 0) {
          cancel();
          reject(new OperationLimitError());
        }
      }
    );
    return cancel;
  });
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/unpin.mjs
var createUnpinFn = (request) => (hashes) => hashes.length > 0 ? new Promise((res, rej) => {
  request(chainHead.unpin, [hashes], {
    onSuccess() {
      res();
    },
    onError: rej
  });
}) : Promise.resolve();

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/client/DestroyedError.mjs
var DestroyedError = class extends Error {
  constructor() {
    super("Client destroyed");
    this.name = "DestroyedError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/chainhead.mjs
function isOperationEvent(event) {
  return event.operationId !== void 0;
}
function getChainHead(request) {
  return (withRuntime, onFollowEvent, onFollowError) => {
    const subscriptions = getSubscriptionsManager();
    const ongoingRequests = /* @__PURE__ */ new Set();
    const deferredFollow = deferred();
    let followSubscription = deferredFollow.promise;
    const onAllFollowEventsNext = (event) => {
      if (isOperationEvent(event)) {
        if (!subscriptions.has(event.operationId))
          console.warn("Uknown operationId on", event);
        return subscriptions.next(event.operationId, event);
      }
      if (event.event !== "stop") {
        if (event.event === "initialized") {
          return onFollowEvent({
            type: event.event,
            finalizedBlockHashes: event.finalizedBlockHashes,
            finalizedBlockRuntime: event.finalizedBlockRuntime
          });
        }
        const { event: type, ...rest } = event;
        return onFollowEvent({ type, ...rest });
      }
      onFollowError(new StopError());
      unfollow(false);
    };
    const onAllFollowEventsError = (error) => {
      onFollowError(error);
      unfollow(!(error instanceof DestroyedError));
    };
    const onFollowRequestSuccess = (subscriptionId, follow) => {
      const done = follow(subscriptionId, {
        next: onAllFollowEventsNext,
        error: onAllFollowEventsError
      });
      unfollow = (sendUnfollow = true) => {
        followSubscription = null;
        unfollow = noop4;
        done();
        sendUnfollow && request(chainHead.unfollow, [subscriptionId]);
        subscriptions.errorAll(new DisjointError());
        ongoingRequests.forEach((cb) => {
          cb();
        });
        ongoingRequests.clear();
      };
      followSubscription = subscriptionId;
      deferredFollow.res(subscriptionId);
    };
    const onFollowRequestError = (e) => {
      if (e instanceof DestroyedError) {
        unfollow(false);
      } else {
        onFollowError(e);
      }
      followSubscription = null;
      deferredFollow.res(e);
    };
    let unfollow = request(
      chainHead.follow,
      [withRuntime],
      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError }
    );
    const fRequest = (method, params2, cb) => {
      const disjoint = () => {
        cb == null ? void 0 : cb.onError(new DisjointError());
      };
      if (followSubscription === null) {
        disjoint();
        return noop4;
      }
      const onSubscription = (subscription) => {
        if (!cb) return request(method, [subscription, ...params2]);
        ongoingRequests.add(disjoint);
        const onSubscribeOperation = (operationId, subscriber) => {
          if (followSubscription === null) {
            subscriber.error(new DisjointError());
            return noop4;
          }
          subscriptions.subscribe(operationId, subscriber);
          return () => {
            subscriptions.unsubscribe(operationId);
          };
        };
        const cleanup = request(method, [subscription, ...params2], {
          onSuccess: (response) => {
            ongoingRequests.delete(disjoint);
            cb.onSuccess(response, onSubscribeOperation);
          },
          onError: (e) => {
            ongoingRequests.delete(disjoint);
            cb.onError(e);
          }
        });
        return () => {
          ongoingRequests.delete(disjoint);
          cleanup();
        };
      };
      if (typeof followSubscription === "string")
        return onSubscription(followSubscription);
      let onCancel = noop4;
      followSubscription.then((x) => {
        if (x instanceof Error) return disjoint();
        if (followSubscription) onCancel = onSubscription(x);
      });
      return () => {
        onCancel();
      };
    };
    return {
      unfollow() {
        unfollow();
        followSubscription = null;
      },
      body: createBodyFn(fRequest),
      call: createCallFn(fRequest),
      header: createHeaderFn(fRequest),
      storage: createStorageFn(fRequest),
      storageSubscription: createStorageCb(fRequest),
      unpin: createUnpinFn(fRequest),
      _request: fRequest
    };
  };
}

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/client/RpcError.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value2) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField4 = (obj, key, value2) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value2);
var RpcError = class extends Error {
  constructor(e) {
    super(e.message);
    __publicField4(this, "code");
    __publicField4(this, "data");
    this.code = e.code;
    this.data = e.data;
    this.name = "RpcError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/client/createClient.mjs
var nextClientId = 1;
var createClient = (gProvider) => {
  let clientId = nextClientId++;
  const responses = /* @__PURE__ */ new Map();
  const subscriptions = getSubscriptionsManager();
  let connection = null;
  const send = (id, method, params2) => {
    connection.send(
      JSON.stringify({
        jsonrpc: "2.0",
        id,
        method,
        params: params2
      })
    );
  };
  function onMessage(message) {
    try {
      let id, result, error, params2, subscription;
      const parsed = JSON.parse(message);
      ({ id, result, error, params: params2 } = parsed);
      if (id) {
        const cb = responses.get(id);
        if (!cb) return;
        responses.delete(id);
        return error ? cb.onError(new RpcError(error)) : cb.onSuccess(result, (opaqueId, subscriber) => {
          const subscriptionId2 = opaqueId;
          subscriptions.subscribe(subscriptionId2, subscriber);
          return () => {
            subscriptions.unsubscribe(subscriptionId2);
          };
        });
      }
      ;
      ({ subscription, result, error } = params2);
      if (!subscription || !error && !Object.hasOwn(params2, "result")) throw 0;
      const subscriptionId = subscription;
      if (error) {
        subscriptions.error(subscriptionId, new RpcError(error));
      } else {
        subscriptions.next(subscriptionId, result);
      }
    } catch (e) {
      console.warn("Error parsing incomming message: " + message);
      console.error(e);
    }
  }
  connection = gProvider(onMessage);
  const disconnect = () => {
    connection == null ? void 0 : connection.disconnect();
    connection = null;
    subscriptions.errorAll(new DestroyedError());
    responses.forEach((r) => r.onError(new DestroyedError()));
    responses.clear();
  };
  let nextId = 1;
  const request = (method, params2, cb) => {
    if (!connection) throw new Error("Not connected");
    const id = `${clientId}-${nextId++}`;
    if (cb) responses.set(id, cb);
    send(id, method, params2);
    return () => {
      responses.delete(id);
    };
  };
  return {
    request,
    disconnect
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainspec.mjs
var createGetChainSpec = (clientRequest) => {
  const request = abortablePromiseFn(
    (onSuccess, onError, method, params2) => clientRequest(method, params2, { onSuccess, onError })
  );
  let cachedPromise = null;
  return async () => {
    if (cachedPromise) return cachedPromise;
    return cachedPromise = Promise.all([
      request(chainSpec.chainName, []),
      request(chainSpec.genesisHash, []),
      request(chainSpec.properties, [])
    ]).then(([name, genesisHash, properties]) => ({
      name,
      genesisHash,
      properties
    }));
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/dist/esm/index.mjs
var clientCache = /* @__PURE__ */ new Map();
var createClient2 = (provider) => {
  const cached = clientCache.get(provider);
  if (cached) {
    cached.refCount++;
    return cached.client;
  }
  const { request, disconnect } = createClient(provider);
  const destroy = () => {
    const cached2 = clientCache.get(provider);
    if (!cached2 || cached2.refCount <= 1) {
      clientCache.delete(provider);
      disconnect();
    } else {
      cached2.refCount--;
    }
  };
  const client = {
    chainHead: getChainHead(request),
    transaction: getTransaction(request),
    getChainSpecData: createGetChainSpec(request),
    destroy,
    request: abortablePromiseFn(
      (onSuccess, onError, method, params2) => request(method, params2, { onSuccess, onError })
    ),
    _request: request
  };
  clientCache.set(provider, { client, refCount: 1 });
  return client;
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/operationLimitRecovery.mjs
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value2) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField5 = (obj, key, value2) => __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value2);
var PendingTaskQueue = class {
  constructor() {
    __publicField5(this, "first");
    __publicField5(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value2) {
    const newNode = { value: value2 };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value2) {
    this.first = { value: value2, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    var _a, _b;
    const result = (_a = this.first) == null ? void 0 : _a.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        (_b = this.first.prev) == null ? true : delete _b.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
};
var getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    var _a;
    (_a = tearDownOperations.get(observable)) == null ? void 0 : _a();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data) return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    let isOperationLimit = false;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        (isOperationLimit = e instanceof OperationLimitError) ? addTask(data, true) : observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    if (!subscription.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
        onEmptySlot();
      });
    } else if (!isOperationLimit) onEmptySlot();
  };
  const withRecovery = (topPriority = false) => (source$) => new Observable((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/errors.mjs
var BlockNotPinnedError = class extends Error {
  constructor(hash, label) {
    super(`Block ${hash} is not pinned (${label})`);
    this.name = "BlockNotPinnedError";
  }
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/optionalHash.mjs
var dynamicBlocks = /* @__PURE__ */ new Set(["best", "finalized", null]);
var operable = (source$) => {
  const result = source$.pipe(
    catchError(
      (e) => e instanceof OperationInaccessibleError ? timer(750).pipe(concatMap(() => result)) : throwError(() => e)
    )
  );
  return result;
};
var getWithOptionalhash$ = (finalized$, best$, usingBlock) => {
  return (fn) => (hash, ...args) => {
    if (!dynamicBlocks.has(hash))
      return operable(fn(hash, ...args)).pipe(
        usingBlock(hash)
      );
    const hash$ = hash === "best" ? best$ : finalized$;
    const result$ = hash$.pipe(
      take(1),
      mergeMap((h) => fn(h, ...args).pipe(usingBlock(h))),
      catchError((e) => {
        return e instanceof BlockNotPinnedError ? result$ : throwError(() => e);
      })
    );
    return operable(result$);
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/fromAbortControllerFn.mjs
var fromAbortControllerFn = (fn) => (...args) => new Observable((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value2) => {
      observer.next(value2);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/lazyFollower.mjs
var withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/withStopRecovery.mjs
function withStopRecovery(blocks$, fn, label) {
  return (hash, ...args) => {
    const source$ = fn(hash, ...args);
    return new Observable((observer) => {
      let sourceSub = null;
      let isSubscribed = false;
      const performSourceSub = () => {
        if (isSubscribed) return;
        isSubscribed = true;
        sourceSub = source$.subscribe({
          next: (v) => observer.next(v),
          error: (e) => observer.error(e),
          complete: () => observer.complete()
        });
        sourceSub.add(() => {
          isSubscribed = false;
          sourceSub = null;
        });
      };
      let isRecovering = false;
      const blockSub = blocks$.subscribe({
        next: (v) => {
          const block = v.blocks.get(hash);
          if (!block) {
            if (isRecovering) {
              observer.error(new BlockNotPinnedError(hash, label));
            }
          } else if (block.recovering) {
            sourceSub == null ? void 0 : sourceSub.unsubscribe();
          } else {
            performSourceSub();
          }
          isRecovering = v.recovering;
        },
        error: (e) => observer.error(e)
      });
      return () => {
        blockSub.unsubscribe();
        sourceSub == null ? void 0 : sourceSub.unsubscribe();
      };
    });
  };
}

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/new-blocks.mjs
var getNewBlocks$ = (pinnedBlocks$) => pinnedBlocks$.pipe(
  scan(
    ({ reportedBlocks: prevReportedBlocks }, { blocks }) => {
      const reportedBlocks = new Set(blocks.keys());
      const newBlocks = [];
      if (reportedBlocks.size > prevReportedBlocks.size) {
        blocks.forEach(({ hash, number, parent }) => {
          if (!prevReportedBlocks.has(hash)) {
            newBlocks.push({
              hash,
              number,
              parent
            });
          }
        });
      }
      return { reportedBlocks, newBlocks };
    },
    {
      reportedBlocks: /* @__PURE__ */ new Set(),
      newBlocks: new Array(0)
    }
  ),
  mergeMap(({ newBlocks }) => newBlocks),
  share()
);

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/storage-queries.mjs
var getRecoveralStorage$ = (getFollower, withRecovery) => {
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new Observable(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        if (nDiscarded > 0)
          observer.next(
            recoveralStorage$(
              hash,
              queries.slice(-nDiscarded),
              childTrie,
              true
            )
          );
      }
    )
  ).pipe(mergeAll(), withRecovery(isHighPriority));
  return recoveralStorage$;
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/follow.mjs
var withInitializedNumber = (getHeader) => (source$) => source$.pipe(
  concatMap((event) => {
    return event.type !== "initialized" ? of(event) : getHeader(event.finalizedBlockHashes[0]).then((header) => ({
      ...event,
      number: header.number,
      parentHash: header.parentHash
    }));
  })
);
var getFollow$ = (chainHead2) => {
  let follower = null;
  let unfollow = noop;
  const getFollower = () => {
    if (!follower) throw new Error("Missing chainHead subscription");
    return follower;
  };
  const getHeader = (hash) => getFollower().header(hash).then(blockHeader.dec);
  const follow$ = connectable(
    new Observable((observer) => {
      follower = chainHead2(
        true,
        (e) => {
          observer.next(e);
        },
        (e) => {
          follower = null;
          observer.error(e);
        }
      );
      unfollow = () => {
        observer.complete();
        follower == null ? void 0 : follower.unfollow();
      };
    }).pipe(withInitializedNumber(getHeader), retryChainHeadError())
  );
  const startFollow = () => {
    follow$.connect();
    return () => {
      unfollow();
    };
  };
  return {
    getHeader,
    getFollower,
    startFollow,
    follow$
  };
};
var retryChainHeadError = () => (source$) => new Observable((observer) => {
  const subscription = new Subscription();
  const subscribe = () => source$.subscribe({
    next: (v) => observer.next(v),
    error: (e) => {
      subscription.add(subscribe());
      if (e instanceof StopError) {
        observer.next({ type: "stop-error" });
      } else {
        console.warn("ChainHead follow request failed, retrying…", e);
      }
    },
    complete: () => observer.complete()
  });
  subscription.add(subscribe());
  return subscription;
});

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/dist/esm/lookups.mjs
var isBytes = (value2, nBytes) => value2.type === "array" && value2.len === nBytes && value2.value.type === "primitive" && value2.value.value === "u8";
var _void2 = { type: "void" };
var _denormalizeLookup = (lookupData, customMap = () => null) => {
  const lookups = /* @__PURE__ */ new Map();
  const from2 = /* @__PURE__ */ new Set();
  const withCache2 = (fn) => {
    return (id) => {
      let entry2 = lookups.get(id);
      if (entry2) return entry2;
      if (from2.has(id)) {
        const entry22 = {
          id
        };
        lookups.set(id, entry22);
        return entry22;
      }
      from2.add(id);
      const value2 = fn(id);
      entry2 = lookups.get(id);
      if (entry2) {
        Object.assign(entry2, value2);
      } else {
        entry2 = {
          id,
          ...value2
        };
        lookups.set(id, entry2);
      }
      from2.delete(id);
      return entry2;
    };
  };
  let isAccountId32SearchOn = true;
  let isAccountId20SearchOn = true;
  const getLookupEntryDef = withCache2((id) => {
    const custom = customMap(lookupData[id]);
    if (custom) return custom;
    const { def: def2, path, params: params2 } = lookupData[id];
    if (def2.tag === "composite") {
      if (def2.value.length === 0) return _void2;
      if (def2.value.length === 1) {
        const inner = getLookupEntryDef(def2.value[0].type);
        if (isAccountId32SearchOn && path.at(-1) === "AccountId32" && isBytes(inner, 32)) {
          isAccountId32SearchOn = false;
          return { type: "AccountId32" };
        }
        if (isAccountId20SearchOn && path.at(-1) === "AccountId20" && isBytes(inner, 20)) {
          isAccountId20SearchOn = false;
          return { type: "AccountId20" };
        }
        return inner;
      }
      return getComplexVar(def2.value);
    }
    if (def2.tag === "variant") {
      if (path.length === 1 && path[0] === "Option" && params2.length === 1 && params2[0].name === "T") {
        const value2 = getLookupEntryDef(params2[0].type);
        return value2.type === "void" ? (
          // Option<void> would return a Codec<undefined> which makes no sense
          // Therefore, we better treat it as a bool
          { type: "primitive", value: "bool" }
        ) : {
          type: "option",
          value: value2
        };
      }
      if (path.length === 1 && path[0] === "Result" && params2.length === 2 && params2[0].name === "T" && params2[1].name === "E") {
        return {
          type: "result",
          value: {
            ok: getLookupEntryDef(params2[0].type),
            ko: getLookupEntryDef(params2[1].type)
          }
        };
      }
      if (def2.value.length === 0) return _void2;
      const enumValue = {};
      const enumDocs = {};
      def2.value.forEach((x) => {
        const key = x.name;
        enumDocs[key] = x.docs;
        if (x.fields.length === 0) {
          enumValue[key] = { ..._void2, idx: x.index };
          return;
        }
        if (x.fields.length === 1 && !x.fields[0].name) {
          enumValue[key] = {
            type: "lookupEntry",
            value: getLookupEntryDef(x.fields[0].type),
            idx: x.index
          };
          return;
        }
        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index };
      });
      return {
        type: "enum",
        value: enumValue,
        innerDocs: enumDocs
      };
    }
    if (def2.tag === "sequence")
      return {
        type: "sequence",
        value: getLookupEntryDef(def2.value)
      };
    if (def2.tag === "array") {
      const { len } = def2.value;
      const value2 = getLookupEntryDef(def2.value.type);
      return !len || value2.type === "void" ? _void2 : len > 1 ? {
        type: "array",
        value: value2,
        len: def2.value.len
      } : value2;
    }
    if (def2.tag === "tuple") {
      if (def2.value.length === 0) return _void2;
      return def2.value.length > 1 ? getArrayOrTuple(
        def2.value.map((x) => getLookupEntryDef(x)),
        def2.value.map((x) => lookupData[x].docs)
      ) : getLookupEntryDef(def2.value[0]);
    }
    if (def2.tag === "primitive") {
      return {
        type: "primitive",
        value: def2.value.tag
      };
    }
    if (def2.tag === "compact") {
      const translated = getLookupEntryDef(def2.value);
      if (translated.type === "void") return _void2;
      const isBig = Number(translated.value.slice(1)) > 32;
      return {
        type: "compact",
        isBig,
        size: translated.value
      };
    }
    return {
      type: def2.tag
    };
  });
  const getComplexVar = (input) => {
    let allKey = true;
    const values = {};
    const innerDocs = {};
    input.forEach((x, idx) => {
      allKey = allKey && !!x.name;
      const key = x.name || idx;
      const value2 = getLookupEntryDef(x.type);
      if (value2.type !== "void") {
        values[key] = value2;
        innerDocs[key] = x.docs;
      }
    });
    return allKey ? {
      type: "struct",
      value: values,
      innerDocs
    } : getArrayOrTuple(Object.values(values), Object.values(innerDocs));
  };
  const getArrayOrTuple = (values, innerDocs) => {
    if (values.every((v) => v.id === values[0].id) && innerDocs.every((doc) => !doc.length)) {
      const [value2] = values;
      return value2.type === "void" ? _void2 : {
        type: "array",
        value: values[0],
        len: values.length
      };
    }
    return {
      type: "tuple",
      value: values,
      innerDocs
    };
  };
  return getLookupEntryDef;
};
var getLookupFn = (metadata2) => {
  const getLookupEntryDef = _denormalizeLookup(metadata2.lookup, ({ def: def2 }) => {
    if (def2.tag === "composite") {
      const moduleErrorLength = getModuleErrorLength(def2);
      if (moduleErrorLength) {
        return {
          type: "enum",
          innerDocs: {},
          value: Object.fromEntries(
            metadata2.pallets.map((p) => [
              p.name,
              p.errors == null ? { ..._void2, idx: p.index } : {
                type: "lookupEntry",
                value: getLookupEntryDef(p.errors),
                idx: p.index
              }
            ])
          ),
          byteLength: moduleErrorLength
        };
      }
    }
    return null;
  });
  function getModuleErrorLength(def2) {
    const preChecks = def2.value.length === 2 && def2.value[0].name === "index" && def2.value[1].name === "error";
    if (!preChecks) return null;
    const index = getLookupEntryDef(def2.value[0].type);
    const error = getLookupEntryDef(def2.value[1].type);
    return index.type === "primitive" && index.value === "u8" && error.type === "array" && error.value.type === "primitive" && error.value.value === "u8" ? 1 + error.len : null;
  }
  const getCall = () => {
    var _a;
    if ("outerEnums" in metadata2) {
      return metadata2.outerEnums.call;
    }
    const extrinsic3 = metadata2.lookup[(_a = metadata2.extrinsic) == null ? void 0 : _a.type];
    const call = extrinsic3 == null ? void 0 : extrinsic3.params.find((p) => p.name === "Call");
    return (call == null ? void 0 : call.type) ?? null;
  };
  return Object.assign(getLookupEntryDef, { metadata: metadata2, call: getCall() });
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/dist/esm/with-cache.mjs
var withCache = (fn, onEnterCircular, onExitCircular) => (input, cache, stack, ...rest) => {
  const { id } = input;
  if (cache.has(id)) return cache.get(id);
  if (stack.has(id)) {
    const res = onEnterCircular(() => cache.get(id), input, ...rest);
    cache.set(id, res);
    return res;
  }
  stack.add(id);
  let result = fn(input, cache, stack, ...rest);
  stack.delete(id);
  if (cache.has(id))
    result = onExitCircular(result, cache.get(id), input, ...rest);
  cache.set(id, result);
  return result;
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/dist/esm/lookup-codec-builder.mjs
var _bytes2 = Bin();
var _buildCodec = (input, cache, stack, _accountId) => {
  if (input.type === "primitive") return esm_exports[input.value];
  if (input.type === "void") return _void;
  if (input.type === "AccountId32") return _accountId;
  if (input.type === "AccountId20") return ethAccount;
  if (input.type === "compact")
    return input.isBig ? compactBn : compactNumber;
  if (input.type === "bitSequence") return bitSequence;
  const buildNextCodec = (nextInput) => buildCodec(nextInput, cache, stack, _accountId);
  const buildVector = (inner2, len) => {
    const innerCodec = buildNextCodec(inner2);
    return len ? Vector2(innerCodec, len) : Vector2(innerCodec);
  };
  const buildTuple = (value2) => Tuple2(...value2.map(buildNextCodec));
  const buildStruct = (value2) => {
    const inner2 = Object.fromEntries(
      Object.entries(value2).map(([key, value22]) => [key, buildNextCodec(value22)])
    );
    return Struct2(inner2);
  };
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return _bytes2;
  }
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8")
      return Bin(input.len);
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence") return buildVector(input.value);
  if (input.type === "tuple") return buildTuple(input.value);
  if (input.type === "struct") return buildStruct(input.value);
  if (input.type === "option") return Option2(buildNextCodec(input.value));
  if (input.type === "result")
    return Result2(
      buildNextCodec(input.value.ok),
      buildNextCodec(input.value.ko)
    );
  const dependencies = Object.values(input.value).map((v) => {
    switch (v.type) {
      case "void":
        return _void;
      case "lookupEntry":
        return buildNextCodec(v.value);
      case "tuple":
        return buildTuple(v.value);
      case "struct":
        return buildStruct(v.value);
      case "array":
        return buildVector(v.value, v.len);
    }
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => {
      return [key, dependencies[idx]];
    })
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  const variantCodec = areIndexesSorted ? Variant(inner) : Variant(inner, indexes);
  return input.byteLength ? fixedSizeCodec(variantCodec, input.byteLength) : variantCodec;
};
var buildCodec = withCache(_buildCodec, Self, (res) => res);
var getLookupCodecBuilder = (lookup2, accountId = AccountId()) => {
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildCodec(lookup2(id), cache, /* @__PURE__ */ new Set(), accountId);
  return (id) => buildDefinition(id);
};
var fixedSizeCodec = (codec, size) => {
  const allBytes = Bytes(size);
  return createCodec(
    (value2) => allBytes.enc(codec.enc(value2)),
    (data) => codec.dec(allBytes.dec(data))
  );
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/dist/esm/dynamic-builder.mjs
var getDynamicBuilder = (getLookupEntryDef) => {
  var _a;
  const { metadata: metadata2 } = getLookupEntryDef;
  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef);
  const prefix = (_a = metadata2.pallets.find((x) => x.name === "System")) == null ? void 0 : _a.constants.find((x) => x.name === "SS58Prefix");
  let ss58Prefix;
  if (prefix) {
    try {
      const prefixVal = buildDefinition(prefix.type).dec(prefix.value);
      if (typeof prefixVal === "number") {
        ss58Prefix = prefixVal;
        buildDefinition = getLookupCodecBuilder(
          getLookupEntryDef,
          AccountId(prefixVal)
        );
      }
    } catch (_) {
    }
  }
  const storagePallets = /* @__PURE__ */ new Map();
  const buildStorage = (pallet, entry2) => {
    let storagePallet = storagePallets.get(pallet);
    if (!storagePallet)
      storagePallets.set(pallet, storagePallet = Storage(pallet));
    const storageEntry = metadata2.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry2);
    const storageWithFallback = (len, value22, ...args) => {
      const keys = storagePallet(...args);
      const [, ...encodersWithHash] = args;
      return {
        args: Tuple2(...encodersWithHash.map(([codec]) => codec)),
        keys,
        value: value22,
        len,
        fallback: storageEntry.modifier === 1 ? value22.dec(storageEntry.fallback) : void 0
      };
    };
    if (storageEntry.type.tag === "plain")
      return storageWithFallback(
        0,
        buildDefinition(storageEntry.type.value),
        entry2
      );
    const { key, value: value2, hashers: hashers3 } = storageEntry.type.value;
    const val = buildDefinition(value2);
    const hashes = hashers3.map((x) => esm_exports[x.tag]);
    const hashArgs = (() => {
      if (hashes.length === 1) {
        return [[buildDefinition(key), hashes[0]]];
      }
      const keyDef = getLookupEntryDef(key);
      switch (keyDef.type) {
        case "array":
          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash]);
        case "tuple":
          return keyDef.value.map((x, idx) => [
            buildDefinition(x.id),
            hashes[idx]
          ]);
        default:
          throw new Error("Invalid key type");
      }
    })();
    return storageWithFallback(hashes.length, val, entry2, ...hashArgs);
  };
  const buildEnumEntry = (entry2) => {
    switch (entry2.type) {
      case "void":
        return _void;
      case "lookupEntry":
        return buildDefinition(entry2.value.id);
      case "tuple":
        return Tuple2(
          ...Object.values(entry2.value).map((l) => buildDefinition(l.id))
        );
      case "struct":
        return Struct2(
          mapObject2(entry2.value, (x) => buildDefinition(x.id))
        );
      case "array":
        return Vector2(buildDefinition(entry2.value.id), entry2.len);
    }
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata2.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const buildVariant = (type) => (pallet, name) => {
    const palletEntry = metadata2.pallets.find((x) => x.name === pallet);
    const lookup2 = getLookupEntryDef(palletEntry[type]);
    if (lookup2.type !== "enum") throw null;
    const entry2 = lookup2.value[name];
    return {
      location: [palletEntry.index, entry2.idx],
      codec: buildEnumEntry(lookup2.value[name])
    };
  };
  const buildRuntimeCall = (api, method) => {
    var _a2;
    const entry2 = (_a2 = metadata2.apis.find((x) => x.name === api)) == null ? void 0 : _a2.methods.find((x) => x.name === method);
    if (!entry2) throw null;
    return {
      args: Tuple2(...entry2.inputs.map((x) => buildDefinition(x.type))),
      value: buildDefinition(entry2.output)
    };
  };
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildRuntimeCall,
    buildCall: buildVariant("calls"),
    buildConstant,
    ss58Prefix
  };
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/dist/esm/checksum-builder.mjs
var textEncoder6 = new TextEncoder();
var encodeText = textEncoder6.encode.bind(textEncoder6);
var runtimePrimitiveIds = {
  undefined: 0n,
  number: 1n,
  string: 2n,
  bigint: 3n,
  boolean: 4n,
  bitSequence: 5n,
  // {bitsLen: number, bytes: Uint8Array}
  byteSequence: 6n,
  // Binary
  accountId32: 7n,
  // SS58String
  accountId20: 8n
  // EthAccount
};
var metadataPrimitiveIds = {
  bool: runtimePrimitiveIds.boolean,
  char: runtimePrimitiveIds.string,
  str: runtimePrimitiveIds.string,
  u8: runtimePrimitiveIds.number,
  u16: runtimePrimitiveIds.number,
  u32: runtimePrimitiveIds.number,
  u64: runtimePrimitiveIds.bigint,
  u128: runtimePrimitiveIds.bigint,
  u256: runtimePrimitiveIds.bigint,
  i8: runtimePrimitiveIds.number,
  i16: runtimePrimitiveIds.number,
  i32: runtimePrimitiveIds.number,
  i64: runtimePrimitiveIds.bigint,
  i128: runtimePrimitiveIds.bigint,
  i256: runtimePrimitiveIds.bigint
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/get-runtime-creator.mjs
var v15Args = toHex(u322.enc(15));
var opaqueBytes2 = Bytes();
var optionalOpaqueBytes = Option2(opaqueBytes2);
var u32ListDecoder = Vector2(u322).dec;
var getRuntimeCreator = (call$) => {
  const getMetadata$ = (getHash) => {
    const recoverCall$ = (method, args) => {
      const hash = getHash();
      return hash ? call$(hash, method, args).pipe(
        catchError((e) => {
          if (e instanceof BlockNotPinnedError)
            return recoverCall$(method, args);
          if (e instanceof OperationInaccessibleError)
            return timer(750).pipe(
              mergeMap(() => recoverCall$(method, args))
            );
          throw e;
        })
      ) : EMPTY;
    };
    const versions = recoverCall$("Metadata_metadata_versions", "").pipe(
      map(u32ListDecoder)
    );
    const v142 = recoverCall$("Metadata_metadata", "").pipe(
      map((x) => {
        const metadataRaw = opaqueBytes2.dec(x);
        const metadata$1 = metadata.dec(metadataRaw);
        return { metadata: metadata$1.metadata.value, metadataRaw };
      })
    );
    const v152 = recoverCall$("Metadata_metadata_at_version", v15Args).pipe(
      map((x) => {
        const metadataRaw = optionalOpaqueBytes.dec(x);
        const metadata$1 = metadata.dec(metadataRaw);
        return { metadata: metadata$1.metadata.value, metadataRaw };
      })
    );
    return versions.pipe(
      catchError(() => of([14])),
      mergeMap((v) => v.includes(15) ? v152 : v142)
    );
  };
  return (getHash) => {
    const initialHash = getHash();
    const usages = /* @__PURE__ */ new Set([initialHash]);
    const runtimeContext$ = getMetadata$(
      getHash
    ).pipe(
      map(({ metadata: metadata2, metadataRaw }) => {
        const lookup2 = getLookupFn(metadata2);
        const dynamicBuilder = getDynamicBuilder(lookup2);
        const events = dynamicBuilder.buildStorage("System", "Events");
        const assetPayment = metadata2.extrinsic.signedExtensions.find(
          (x) => x.identifier === "ChargeAssetTxPayment"
        );
        let assetId = null;
        if (assetPayment) {
          const assetTxPayment = lookup2(assetPayment.type);
          if (assetTxPayment.type === "struct") {
            const optionalAssetId = assetTxPayment.value.asset_id;
            if (optionalAssetId.type === "option")
              assetId = optionalAssetId.value.id;
          }
        }
        return {
          assetId,
          metadataRaw,
          lookup: lookup2,
          dynamicBuilder,
          events: {
            key: events.keys.enc(),
            dec: events.value.dec
          },
          accountId: AccountId(dynamicBuilder.ss58Prefix)
        };
      }),
      shareReplay(1)
    );
    const result = {
      at: initialHash,
      runtime: runtimeContext$,
      addBlock: (block) => {
        usages.add(block);
        return result;
      },
      deleteBlocks: (blocks) => {
        blocks.forEach((block) => {
          usages.delete(block);
        });
        return usages.size;
      },
      usages
    };
    runtimeContext$.subscribe({
      error() {
      }
    });
    return result;
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/shareLatest.mjs
var shareLatest = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/pinned-blocks.mjs
var createRuntimeGetter = (pinned, startAt) => {
  return () => {
    const runtime = pinned.runtimes[startAt];
    if (!runtime) return pinned.blocks.has(startAt) ? startAt : null;
    const winner = [...runtime.usages].at(-1);
    return winner ?? null;
  };
};
var deleteBlock = (blocks, blockHash) => {
  var _a;
  (_a = blocks.get(blocks.get(blockHash).parent)) == null ? void 0 : _a.children.delete(blockHash);
  blocks.delete(blockHash);
};
var deleteBlocks = (blocks, toDelete) => {
  toDelete.forEach((hash) => {
    deleteBlock(blocks.blocks, hash);
  });
  Object.entries(blocks.runtimes).map(([key, value2]) => ({
    key,
    usages: value2.deleteBlocks(toDelete)
  })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unusedRuntime) => {
    delete blocks.runtimes[unusedRuntime];
  });
};
var getPinnedBlocks$ = (follow$, call$, blockUsage$, onUnpin, deleteFromCache) => {
  const cleanup$ = new Subject();
  const cleanupEvt$ = cleanup$.pipe(
    exhaustMap(() => timer(0)),
    map(
      () => ({
        type: "cleanup"
      })
    )
  );
  const pinnedBlocks$ = merge(
    blockUsage$,
    cleanupEvt$,
    follow$
  ).pipe(
    scan((acc, event) => {
      const unpinAndDelete = (toUnpin) => {
        deleteBlocks(acc, toUnpin);
        onUnpin(toUnpin);
      };
      switch (event.type) {
        case "initialized":
          if (acc.recovering) {
            const isConnected = event.finalizedBlockHashes.some(
              (hash) => acc.blocks.has(hash)
            );
            if (!isConnected) {
              acc = getInitialPinnedBlocks();
            }
          }
          const [finalizedHash] = event.finalizedBlockHashes.slice(-1);
          acc.finalized = acc.best = finalizedHash;
          const lastIdx = event.finalizedBlockHashes.length - 1;
          event.finalizedBlockHashes.forEach((hash, i) => {
            const preexistingBlock = acc.blocks.get(hash);
            if (preexistingBlock) {
              preexistingBlock.recovering = false;
              preexistingBlock.unpinnable = i !== lastIdx;
            } else {
              acc.blocks.set(hash, {
                hash,
                parent: i === 0 ? event.parentHash : event.finalizedBlockHashes[i - 1],
                children: new Set(
                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]]
                ),
                unpinnable: i !== lastIdx,
                runtime: hash,
                refCount: 0,
                number: event.number + i,
                recovering: false
              });
            }
          });
          const finalizedRuntime = Object.values(acc.runtimes).find(
            (runtime) => runtime.usages.has(finalizedHash)
          );
          acc.finalizedRuntime = finalizedRuntime ?? (acc.runtimes[finalizedHash] = getRuntime(
            createRuntimeGetter(acc, finalizedHash)
          ));
          return acc;
        case "stop-error":
          for (const block of acc.blocks.values()) {
            block.recovering = true;
          }
          acc.recovering = true;
          return acc;
        case "newBlock": {
          const { parentBlockHash: parent, blockHash: hash } = event;
          if (acc.blocks.has(hash)) {
            acc.blocks.get(hash).recovering = false;
          } else {
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash);
            const block = {
              hash,
              number: parentNode.number + 1,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: event.newRuntime ? hash : parentNode.runtime,
              unpinnable: false,
              refCount: 0,
              recovering: false
            };
            acc.blocks.set(hash, block);
            if (event.newRuntime) {
              acc.runtimes[hash] = getRuntime(createRuntimeGetter(acc, hash));
            }
            acc.runtimes[block.runtime].addBlock(hash);
          }
          return acc;
        }
        case "bestBlockChanged": {
          if (acc.recovering) {
            for (const [hash, block] of acc.blocks) {
              if (block.recovering) {
                deleteBlock(acc.blocks, hash);
                deleteFromCache(hash);
              }
            }
            acc.recovering = false;
          }
          acc.best = event.bestBlockHash;
          return acc;
        }
        case "finalized": {
          acc.finalized = event.finalizedBlockHashes.slice(-1)[0];
          const { blocks } = acc;
          if (blocks.get(acc.best).number < blocks.get(acc.finalized).number)
            acc.best = acc.finalized;
          acc.finalizedRuntime = acc.runtimes[blocks.get(acc.finalized).runtime];
          event.prunedBlockHashes.forEach((hash) => {
            const block = acc.blocks.get(hash);
            if (block) {
              block.unpinnable = true;
            }
          });
          let current = blocks.get(blocks.get(acc.finalized).parent);
          while (current && !current.unpinnable) {
            current.unpinnable = true;
            current = blocks.get(current.parent);
          }
          cleanup$.next();
          return acc;
        }
        case "cleanup": {
          const toUnpin = [...acc.blocks.values()].filter(({ unpinnable, refCount: refCount2 }) => unpinnable && !refCount2).map(({ hash }) => hash);
          unpinAndDelete(toUnpin);
          return acc;
        }
        case "blockUsage": {
          if (!acc.blocks.has(event.value.hash)) return acc;
          const block = acc.blocks.get(event.value.hash);
          block.refCount += event.value.type === "hold" ? 1 : -1;
          if (block.refCount === 0 && !block.recovering && block.unpinnable) {
            const toUnpin = [block.hash];
            unpinAndDelete(toUnpin);
          }
          return acc;
        }
      }
    }, getInitialPinnedBlocks()),
    filter((x) => !!x.finalizedRuntime.runtime),
    map((x) => ({ ...x })),
    shareLatest
  );
  const getRuntime = getRuntimeCreator(
    withStopRecovery(pinnedBlocks$, call$, "pinned-blocks")
  );
  return pinnedBlocks$;
};
var getInitialPinnedBlocks = () => ({
  best: "",
  finalized: "",
  runtimes: {},
  blocks: /* @__PURE__ */ new Map(),
  finalizedRuntime: {},
  recovering: false
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/track-tx.mjs
var getTrackTx = (blocks$, getBody, getIsValid, getEvents) => {
  const whileBlockPresent = (hash) => takeUntil(blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))));
  const analyzeBlock = (hash, tx, alreadyPresent) => {
    if (alreadyPresent)
      return of({ hash, found: { type: false, validity: null } });
    const whilePresent = whileBlockPresent(hash);
    return getBody(hash).pipe(
      mergeMap((txs) => {
        const index = txs.indexOf(tx);
        return index > -1 ? whilePresent(getEvents(hash)).pipe(
          map((events) => ({
            hash,
            found: {
              type: true,
              index,
              events
            }
          }))
        ) : getIsValid(hash, tx).pipe(
          map((validity) => ({
            hash,
            found: { type: false, validity }
          }))
        );
      }),
      whilePresent
    );
  };
  const findInBranch = (hash, tx, alreadyPresent) => analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(
    mergeMap((analyzed) => {
      var _a;
      const { found } = analyzed;
      return found.type || ((_a = found.validity) == null ? void 0 : _a.success) === false ? of(analyzed) : blocks$.pipe(
        whileBlockPresent(hash),
        mergeMap((x) => x.blocks.get(hash).children),
        distinct(),
        mergeMap((hash2) => findInBranch(hash2, tx, alreadyPresent))
      );
    })
  );
  return (tx) => blocks$.pipe(
    take(1),
    mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys())))
  );
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/validate-tx.mjs
var external = new Uint8Array([2]);
var getValidateTxArgs = (tx, hash) => toHex(mergeUint82(external, fromHex2(tx), fromHex2(hash)));
var TaggedTransactionQueue = "TaggedTransactionQueue";
var validateTransaction = "validate_transaction";
var [, defaultInvalidTxDecoder] = Variant({
  InvalidTransaction: Variant({
    Call: _void,
    Payment: _void,
    Future: _void,
    Stale: _void,
    BadProof: _void,
    AncientBirthBlock: _void,
    ExhaustsResources: _void,
    Custom: u82,
    BadMandatory: _void,
    MandatoryValidation: _void,
    BadSigner: _void
  }),
  UnknownTransaction: Variant({
    CannotLookup: _void,
    NoUnsignedValidator: _void,
    Custom: u82
  })
});
var defaultValidateTxDecoder = createDecoder((input) => {
  const firstByte = u82.dec(input);
  if (firstByte > 1)
    throw new Error("Unable to decode validateTransaction result");
  if (!firstByte) return { success: true, value: void 0 };
  let value2;
  try {
    value2 = defaultInvalidTxDecoder(input);
  } catch (_) {
    value2 = {
      type: "UnknownInvalidTx"
    };
  }
  return { success: false, value: value2 };
});
var getValidateTx = (call$, getRuntimeContext) => (blockHash, tx) => {
  const decoder$ = getRuntimeContext(blockHash).pipe(
    map((ctx) => {
      try {
        return ctx.dynamicBuilder.buildRuntimeCall(
          TaggedTransactionQueue,
          validateTransaction
        ).value[1];
      } catch (_) {
        return defaultValidateTxDecoder;
      }
    })
  );
  return call$(
    blockHash,
    `${TaggedTransactionQueue}_${validateTransaction}`,
    getValidateTxArgs(tx, blockHash)
  ).pipe(
    withLatestFrom(decoder$),
    map(([result, decoder]) => decoder(result))
  );
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/with-default-value.mjs
var withDefaultValue = (defaultValue) => (source$) => new Observable((observer) => {
  let hasEmited = false;
  const subscription = source$.subscribe({
    next(v) {
      hasEmited = true;
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  if (!hasEmited) observer.next(defaultValue);
  return subscription;
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/delay-unsubscription.mjs
var delayUnsubscription = (ms) => (source) => new Observable((observer) => {
  const subscription = source.subscribe({
    next(v) {
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  const unsubscribe = () => subscription.unsubscribe();
  return () => {
    Promise.resolve().then(unsubscribe);
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/concatMapEager.mjs
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new Observable((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    let isCompleted = false;
    let subscription = inner$.subscribe({
      next(x) {
        if (observerIdx === idx) {
          observer.next(x);
        } else {
          results.get(idx).push(x);
        }
      },
      complete() {
        isCompleted = true;
        innerSubscriptions.delete(idx);
        if (idx === observerIdx) {
          observerIdx++;
          while (results.has(observerIdx)) {
            results.get(observerIdx).forEach((x) => observer.next(x));
            results.delete(observerIdx);
            if (innerSubscriptions.has(observerIdx)) {
              break;
            }
            observerIdx++;
          }
        }
        nextSubscription();
      },
      error(e) {
        observer.error(e);
      }
    });
    if (!isCompleted) innerSubscriptions.set(idx, subscription);
  };
  topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        defer(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/chainHead.mjs
var toBlockInfo = ({ hash, number, parent }) => ({
  hash,
  number,
  parent
});
var getChainHead$ = (chainHead2) => {
  const { getFollower, startFollow, follow$, getHeader } = getFollow$(chainHead2);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new Subject();
  const holdBlock = (hash) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    return () => {
      setTimeout(() => {
        blockUsage$.next({
          type: "blockUsage",
          value: { type: "release", hash }
        });
      }, 0);
    };
  };
  const usingBlock = (blockHash) => (base) => new Observable((observer) => {
    const release = holdBlock(blockHash);
    const subscription = base.subscribe(observer);
    subscription.add(release);
    return subscription;
  });
  const withRefcount = (fn) => (hash, ...args) => fn(hash, ...args).pipe(usingBlock(hash));
  const withInMemory = (fn, label) => (hash, ...args) => new Observable((observer) => {
    let isPresent = false;
    pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {
      isPresent = blocks.blocks.has(hash);
    });
    return isPresent ? fn(hash, ...args).subscribe(observer) : observer.error(new BlockNotPinnedError(hash, label));
  });
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof DisjointError) return;
    throw e;
  });
  const commonEnhancer = (fn, label) => withInMemory(
    withRefcount(
      withStopRecovery(
        pinnedBlocks$,
        withRecoveryFn(fromAbortControllerFn(fn)),
        `stop-${label}`
      )
    ),
    label
  );
  const cache = /* @__PURE__ */ new Map();
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))),
    blockUsage$,
    (blocks) => {
      unpin(blocks);
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    },
    (block) => {
      cache.delete(block);
    }
  );
  const getRuntimeContext$ = withRefcount(
    (hash) => pinnedBlocks$.pipe(
      take(1),
      mergeMap(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      )
    )
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const hashCache = cache.get(hash) ?? /* @__PURE__ */ new Map();
    const cached = hashCache.get(key);
    if (cached) return cached;
    cache.set(hash, hashCache);
    let connector;
    const result = stream.pipe(
      share({
        connector: () => connector = new ReplaySubject()
      }),
      tap({
        complete() {
          hashCache.set(key, connector);
        }
      }),
      delayUnsubscription()
    );
    hashCache.set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    filter((x) => !x.recovering),
    distinctUntilChanged((a, b) => a.finalized === b.finalized),
    scan((acc, value2) => {
      let current = value2.blocks.get(value2.finalized);
      const result = [current];
      const latest = acc.at(-1);
      if (!latest) return result;
      while (current.number > latest.number + 1) {
        current = value2.blocks.get(current.parent);
        if (!current) break;
        result.unshift(current);
      }
      return result;
    }, []),
    mergeAll(),
    map(toBlockInfo),
    shareLatest
  );
  const best$ = pinnedBlocks$.pipe(
    distinctUntilChanged((a, b) => a.best === b.best),
    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    filter((x) => !x.recovering),
    distinctUntilChanged(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    scan((acc, pinned) => {
      const getBlockInfo = (hash) => acc.get(hash) || toBlockInfo(pinned.blocks.get(hash));
      const best = getBlockInfo(pinned.best);
      const finalized = getBlockInfo(pinned.finalized);
      const len = best.number - finalized.number + 1;
      const result = new Array(len);
      for (let i = 0, hash = best.hash; i < len; i++) {
        result[i] = getBlockInfo(hash);
        hash = result[i].parent;
      }
      return new Map(result.map((b) => [b.hash, b]));
    }, /* @__PURE__ */ new Map()),
    map((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    switchMap(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(map((x) => (x == null ? void 0 : x.lookup.metadata) ?? null));
  const withOptionalHash$ = getWithOptionalhash$(
    finalized$.pipe(map((b) => b.hash)),
    best$.pipe(map((b) => b.hash)),
    usingBlock
  );
  const _body$ = withOptionalHash$(commonEnhancer(lazyFollower("body"), "body"));
  const body$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const _storage$ = commonEnhancer(lazyFollower("storage"), "storage");
  const storage$ = withOptionalHash$(
    (hash, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.pipe(
      take(1),
      mergeMap(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      ),
      mergeMap((ctx) => {
        const key = keyMapper(ctx);
        const unMapped$ = upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}`,
          _storage$(hash, type, key, childTrie)
        );
        return mapper ? upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}-dec`,
          unMapped$.pipe(
            map((raw) => ({ raw, mapped: mapper(raw, ctx) }))
          )
        ) : unMapped$;
      })
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOptionalHash$(
    withStopRecovery(
      pinnedBlocks$,
      (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false),
      `storageQueries`
    )
  );
  const header$ = withOptionalHash$(
    withStopRecovery(
      pinnedBlocks$,
      (hash) => defer(() => getHeader(hash)),
      "header"
    )
  );
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  ).pipe(map((x) => x.mapped));
  const __call$ = commonEnhancer(lazyFollower("call"), "call");
  const call$ = withOptionalHash$(
    (hash, fn, args) => upsertCachedStream(hash, `call-${fn}-${args}`, __call$(hash, fn, args))
  );
  const validateTx$ = getValidateTx(call$, getRuntimeContext$);
  const innerBody$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$);
  const trackTxWithoutEvents$ = getTrackTx(
    pinnedBlocks$,
    innerBody$,
    validateTx$,
    () => of()
  );
  const genesis$ = runtime$.pipe(
    filter(Boolean),
    take(1),
    mergeMap((runtime) => {
      const { enc: enc3 } = runtime.dynamicBuilder.buildStorage(
        "System",
        "BlockHash"
      ).keys;
      let key;
      try {
        key = enc3(0);
      } catch {
        key = enc3(0n);
      }
      return storage$(null, "value", () => key, null);
    }),
    shareReplay(1)
  );
  merge(runtime$, bestBlocks$).subscribe({
    error() {
    }
  });
  let unfollow = noop;
  let started = false;
  let nSubscribers = 0;
  const start = (_nSubscribers) => {
    nSubscribers += _nSubscribers;
    started = true;
    unfollow = startFollow();
  };
  return [
    {
      follow$,
      finalized$,
      best$,
      bestBlocks$,
      newBlocks$: getNewBlocks$(pinnedBlocks$),
      runtime$,
      metadata$,
      genesis$,
      header$,
      body$,
      call$,
      storage$,
      storageQueries$,
      eventsAt$,
      holdBlock,
      trackTx$,
      trackTxWithoutEvents$,
      validateTx$,
      pinnedBlocks$,
      withRuntime,
      getRuntimeContext$: withOptionalHash$(getRuntimeContext$),
      unfollow: () => {
        if (started == null) return;
        nSubscribers--;
        if (started && !nSubscribers) {
          started = null;
          unfollow();
          unfollow = noop;
        }
      }
    },
    start
  ];
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/tx.mjs
var getBroadcastTx$ = (baseTransaction) => (transaction2) => new Observable(
  (observer) => baseTransaction(transaction2, (e) => {
    observer.error(e);
  })
);

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/getObservableClient.mjs
var clientCache2 = /* @__PURE__ */ new Map();
var getObservableClient = (substrateClient) => {
  const cached = clientCache2.get(substrateClient);
  if (cached) {
    cached.refCount++;
    return cached.client;
  }
  const destroy = () => {
    const cached2 = clientCache2.get(substrateClient);
    if (!cached2 || cached2.refCount <= 1) {
      clientCache2.delete(substrateClient);
      substrateClient.destroy();
    } else {
      cached2.refCount--;
    }
  };
  let cachedChainhead = null;
  let currentSubscribers = 0;
  let expectedSubscribers = null;
  const client = {
    chainHead$: (_expectedSubscribers) => {
      currentSubscribers++;
      expectedSubscribers || (expectedSubscribers = _expectedSubscribers || 1);
      cachedChainhead || (cachedChainhead = getChainHead$(substrateClient.chainHead));
      const [result, start] = cachedChainhead;
      if (expectedSubscribers === currentSubscribers) {
        const copiedCurrentSubscribers = currentSubscribers;
        currentSubscribers = 0;
        expectedSubscribers = null;
        cachedChainhead = null;
        start(copiedCurrentSubscribers);
      }
      return result;
    },
    broadcastTx$: getBroadcastTx$(substrateClient.transaction),
    destroy
  };
  clientCache2.set(substrateClient, { client, refCount: 1 });
  return client;
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/block-operations.mjs
var isBestOrFinalizedBlock = (blocks$, blockHash) => blocks$.pipe(
  takeWhile((b) => b.blocks.has(blockHash)),
  distinctUntilChanged(
    (a, b) => a.finalized === b.finalized && a.best === b.best
  ),
  map((pinned) => {
    if (pinned.blocks.get(blockHash).number > pinned.blocks.get(pinned.best).number)
      return null;
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.best);
    let isFinalized = pinned.finalized === current.hash;
    while (current.number > number) {
      current = pinned.blocks.get(current.parent);
      isFinalized = isFinalized || pinned.finalized === current.hash;
    }
    if (isFinalized) return "finalized";
    return current.hash === blockHash ? "best" : null;
  }),
  distinctUntilChanged(),
  takeWhile((x) => x !== "finalized", true)
);

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/compatibility.mjs
var RuntimeToken = class {
  constructor() {
  }
  // @ts-ignore
  _runtime(value2) {
  }
};
var CompatibilityToken = class {
  constructor() {
  }
  // @ts-ignore
  _compatibility(value2) {
  }
};
var compatibilityTokenApi = /* @__PURE__ */ new WeakMap();
var runtimeTokenApi = /* @__PURE__ */ new WeakMap();
var getCompatibilityApi = (token) => token instanceof RuntimeToken ? runtimeTokenApi.get(token) : compatibilityTokenApi.get(token);
var OpType = ((OpType2) => {
  OpType2["Storage"] = "storage";
  OpType2["Tx"] = "tx";
  OpType2["Event"] = "events";
  OpType2["Const"] = "constants";
  return OpType2;
})(OpType || {});
var EntryPointsCodec = Vector2(EntryPointCodec);
var TypedefsCodec = Vector2(TypedefCodec);
var TypesCodec = Tuple2(EntryPointsCodec, TypedefsCodec);
var createCompatibilityToken = (chainDefinition, chainHead2) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead2.runtime$.pipe(filter((v) => v != null));
    let latest = await firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = Promise.all([
    chainDefinition.metadataTypes.then(TypesCodec.dec),
    chainDefinition.descriptors,
    awaitedRuntime
  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {
    const token = new CompatibilityToken();
    compatibilityTokenApi.set(token, {
      runtime,
      getPalletEntryPoint(opType, pallet, name) {
        var _a, _b;
        const idx = (_b = (_a = descriptors[opType]) == null ? void 0 : _a[pallet]) == null ? void 0 : _b[name];
        if (idx == null)
          throw new Error(
            `Descriptor for ${opType} ${pallet}.${name} does not exist`
          );
        return entryPoints[idx];
      },
      getApiEntryPoint(name, method) {
        var _a, _b;
        const idx = (_b = (_a = descriptors.apis) == null ? void 0 : _a[name]) == null ? void 0 : _b[method];
        if (idx == null)
          throw new Error(`Descriptor for API ${name}.${method} does not exist`);
        return entryPoints[idx];
      },
      typedefNodes
    });
    return token;
  });
  return promise;
};
var createRuntimeToken = (chainHead2) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead2.runtime$.pipe(filter((v) => v != null));
    let latest = await firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = awaitedRuntime.then((runtime) => {
    const token = new RuntimeToken();
    runtimeTokenApi.set(token, {
      runtime
    });
    return token;
  });
  return promise;
};
var metadataCache = /* @__PURE__ */ new WeakMap();
var getMetadataCache = (ctx) => {
  if (!metadataCache.has(ctx.metadataRaw)) {
    metadataCache.set(ctx.metadataRaw, {
      compat: /* @__PURE__ */ new Map(),
      lookup: ctx.lookup,
      typeNodes: []
    });
  }
  return metadataCache.get(ctx.metadataRaw);
};
var compatibilityHelper = (descriptors, getDescriptorEntryPoint, getRuntimeEntryPoint) => {
  const getRuntimeTypedef = (ctx, id) => {
    var _a;
    const cache = getMetadataCache(ctx);
    return (_a = cache.typeNodes)[id] || (_a[id] = mapLookupToTypedef(cache.lookup(id)));
  };
  function getCompatibilityLevels(descriptors2, ctx) {
    if (descriptors2 instanceof RuntimeToken) {
      return {
        args: CompatibilityLevel.Identical,
        values: CompatibilityLevel.Identical
      };
    }
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    ctx || (ctx = compatibilityApi.runtime());
    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi);
    const runtimeEntryPoint = getRuntimeEntryPoint(ctx);
    if (runtimeEntryPoint == null)
      return {
        args: CompatibilityLevel.Incompatible,
        values: CompatibilityLevel.Incompatible
      };
    const descriptorNodes = compatibilityApi.typedefNodes;
    const cache = getMetadataCache(ctx);
    return entryPointsAreCompatible(
      descriptorEntryPoint,
      (id) => descriptorNodes[id],
      runtimeEntryPoint,
      (id) => getRuntimeTypedef(ctx, id),
      cache.compat
    );
  }
  const getCompatibilityLevel = withOptionalToken(
    descriptors,
    (runtime) => minCompatLevel(getCompatibilityLevels(runtime))
  );
  const isCompatible2 = withOptionalToken(
    descriptors,
    (threshold, runtime) => getCompatibilityLevel(runtime) >= threshold
  );
  const compatibleRuntime$ = (chainHead2, hash) => combineLatest([descriptors, chainHead2.getRuntimeContext$(hash)]);
  const withCompatibleRuntime = (chainHead2, mapper) => (source$) => combineLatest([
    source$.pipe(chainHead2.withRuntime(mapper)),
    descriptors
  ]).pipe(map(([[x, ctx], descriptors2]) => [x, descriptors2, ctx]));
  const argsAreCompatible = (descriptors2, ctx, args) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const levels = getCompatibilityLevels(descriptors2, ctx);
    if (levels.args === CompatibilityLevel.Incompatible) return false;
    if (levels.args > CompatibilityLevel.Partial) return true;
    if (levels.values === CompatibilityLevel.Incompatible) return false;
    const entryPoint = getRuntimeEntryPoint(ctx);
    if (entryPoint == null) return false;
    return valueIsCompatibleWithDest(
      entryPoint.args,
      (id) => getRuntimeTypedef(ctx, id),
      args
    );
  };
  const valuesAreCompatible = (descriptors2, ctx, values) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const level = getCompatibilityLevels(descriptors2, ctx).values;
    if (level === CompatibilityLevel.Incompatible) return false;
    if (level > CompatibilityLevel.Partial) return true;
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    const entryPoint = getDescriptorEntryPoint(compatibilityApi);
    return valueIsCompatibleWithDest(
      entryPoint.values,
      (id) => compatibilityApi.typedefNodes[id],
      values
    );
  };
  return {
    isCompatible: isCompatible2,
    getCompatibilityLevel,
    getCompatibilityLevels,
    descriptors,
    withCompatibleRuntime,
    compatibleRuntime$,
    argsAreCompatible,
    valuesAreCompatible,
    getRuntimeTypedef
  };
};
var minCompatLevel = (levels) => Math.min(levels.args, levels.values);
var withOptionalToken = (compatibilityToken, fn) => (...args) => {
  const lastElement = args.at(-1);
  if (lastElement instanceof CompatibilityToken || lastElement instanceof RuntimeToken) {
    return fn(...args);
  }
  return compatibilityToken.then((token) => fn(...args, token));
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/constants.mjs
var createConstantEntry = (palletName, name, {
  valuesAreCompatible,
  descriptors,
  isCompatible: isCompatible2,
  getCompatibilityLevel
}) => {
  const cachedResults = /* @__PURE__ */ new WeakMap();
  const getValueWithContext = (ctx) => {
    if (cachedResults.has(ctx)) {
      return cachedResults.get(ctx);
    }
    const pallet = ctx.lookup.metadata.pallets.find(
      (p) => p.name === palletName
    );
    const constant = pallet == null ? void 0 : pallet.constants.find((c) => c.name === name);
    if (constant == null)
      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`);
    const result = ctx.dynamicBuilder.buildConstant(palletName, name).dec(constant.value);
    cachedResults.set(ctx, result);
    return result;
  };
  const fn = (token) => {
    if (token) {
      const ctx = getCompatibilityApi(token).runtime();
      const value2 = getValueWithContext(ctx);
      if (!valuesAreCompatible(token, ctx, value2))
        throw new Error(
          `Incompatible runtime entry Constant(${palletName}.${name})`
        );
      return value2;
    }
    return descriptors.then(fn);
  };
  return Object.assign(fn, { isCompatible: isCompatible2, getCompatibilityLevel });
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/shareLatest.mjs
var shareLatest2 = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/event.mjs
var createEventEntry = (pallet, name, chainHead2, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  withCompatibleRuntime,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  const shared$ = chainHead2.finalized$.pipe(
    withCompatibleRuntime(chainHead2, (x) => x.hash),
    map(([block, runtime, ctx]) => {
      var _a;
      const eventsIdx = (_a = ctx.lookup.metadata.pallets.find(
        (p) => p.name === pallet
      )) == null ? void 0 : _a.events;
      if (eventsIdx == null || ctx.lookup.metadata.lookup[eventsIdx].def.tag !== "variant" || ctx.lookup.metadata.lookup[eventsIdx].def.value.find(
        (ev) => ev.name === name
      ) == null)
        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`);
      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError();
      return [block, runtime, ctx];
    }),
    concatMapEager(
      ([block, runtime, ctx]) => chainHead2.eventsAt$(block.hash).pipe(
        map((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))
              throw compatibilityError();
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      )
    ),
    shareLatest2
  );
  const watch = (f) => shared$.pipe(mergeMap((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => firstValueFrom(shared$);
  const filter2 = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter: filter2, getCompatibilityLevel, isCompatible: isCompatible2 };
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/firstValueFromWithSignal.mjs
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    let subscription = null;
    let isDone = false;
    const onAbort = signal ? () => {
      subscription == null ? void 0 : subscription.unsubscribe();
      reject(new AbortError());
    } : noop;
    subscription = source.subscribe({
      next: (value2) => {
        resolve(value2);
        subscription == null ? void 0 : subscription.unsubscribe();
        isDone = true;
      },
      error: (e) => {
        signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        reject(e);
        isDone = true;
      },
      complete: () => {
        signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        reject(new Error("Observable completed without emitting"));
        isDone = true;
      }
    });
    if (!isDone) signal == null ? void 0 : signal.addEventListener("abort", onAbort);
  });
}

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/optional-arg.mjs
var isOptionalArg = (lastArg) => typeof lastArg === "object" && lastArg !== null && Object.entries(lastArg).every(
  ([k, v]) => k === "at" && (v === void 0 || typeof v === "string") || k === "signal" && (v === void 0 || v instanceof AbortSignal)
);

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/runtime-call.mjs
var createRuntimeCallEntry = (api, method, chainHead2, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const callName = `${api}_${method}`;
  const compatibilityError = () => new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead2, at).pipe(
      mergeMap(([runtime, ctx]) => {
        let codecs;
        try {
          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        } catch {
          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        return chainHead2.call$(at, callName, toHex(codecs.args.enc(args))).pipe(
          map(codecs.value.dec),
          map((value2) => {
            if (!valuesAreCompatible(runtime, ctx, value2))
              throw compatibilityError();
            return value2;
          })
        );
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible: isCompatible2 });
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/lossLessExhaustMap.mjs
var EMPTY_VALUE = Symbol("EMPTY_VALUE");
var lossLessExhaustMap = (mapper) => (source$) => new Observable((observer) => {
  let idx = 0;
  let innerSubscription = null;
  let queuedValue = EMPTY_VALUE;
  let isOutterDone = false;
  const setInnerSubscription = () => {
    const observable = mapper(queuedValue, idx++);
    queuedValue = EMPTY_VALUE;
    innerSubscription = observable.subscribe({
      next(vv) {
        observer.next(vv);
      },
      error(ee) {
        observer.error(ee);
      },
      complete() {
        if (queuedValue !== EMPTY_VALUE) setInnerSubscription();
        else {
          innerSubscription = null;
          if (isOutterDone) observer.complete();
        }
      }
    });
  };
  const subscription = source$.subscribe({
    next(v) {
      queuedValue = v;
      if (!innerSubscription) setInnerSubscription();
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (!innerSubscription) observer.complete();
      isOutterDone = true;
    }
  });
  return () => {
    innerSubscription == null ? void 0 : innerSubscription.unsubscribe();
    subscription.unsubscribe();
  };
});

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/storage.mjs
var toMapped = map((x) => x.mapped);
var createStorageEntry = (pallet, name, chainHead2, getWatchEntries, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  getCompatibilityLevels,
  descriptors: descriptorsPromise,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const isBlockHash = pallet === "System" && name === "BlockHash";
  const sysNumberMapper$ = chainHead2.runtime$.pipe(
    filter(Boolean),
    take(1),
    map(
      ({ dynamicBuilder }) => typeof dynamicBuilder.buildStorage("System", "Number").value.dec(new Uint8Array(32)) === "bigint" ? BigInt : identity
    ),
    shareReplay()
  );
  const bigIntOrNumber = pipe(
    combineLatestWith(sysNumberMapper$),
    map(([input, mapper]) => mapper(input))
  );
  const incompatibleError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const getCodec = (ctx) => {
    try {
      return ctx.dynamicBuilder.buildStorage(pallet, name);
    } catch (e) {
      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`);
    }
  };
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const isBest = target === "best";
    const actualArgs = isBest || target === "finalized" ? args.slice(0, -1) : args;
    return chainHead2[isBest ? "best$" : "finalized$"].pipe(
      lossLessExhaustMap(
        () => getRawValue$(...actualArgs, isBest ? { at: "best" } : {})
      ),
      distinctUntilChanged((a, b) => a.raw === b.raw),
      toMapped
    );
  };
  const getRawValue$ = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    if (isSystemNumber)
      return chainHead2.pinnedBlocks$.pipe(
        map((blocks) => {
          const hash = at === "finalized" || !at ? blocks.finalized : at === "best" ? blocks.best : at;
          const block = blocks.blocks.get(hash);
          if (!block) {
            throw new BlockNotPinnedError(hash, "System.Number");
          }
          return block.number;
        }),
        distinctUntilChanged(),
        bigIntOrNumber,
        map((mapped) => ({ raw: mapped, mapped }))
      );
    if (isBlockHash && Number(args[0]) === 0) {
      return chainHead2.genesis$.pipe(
        map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) }))
      );
    }
    return from(descriptorsPromise).pipe(
      mergeMap(
        (descriptors) => chainHead2.storage$(
          at,
          "value",
          (ctx) => {
            const codecs = getCodec(ctx);
            const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
            if (args !== actualArgs && !isLastArgOptional)
              throw invalidArgs(args);
            if (!argsAreCompatible(descriptors, ctx, actualArgs))
              throw incompatibleError();
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (data, ctx) => {
            const codecs = getCodec(ctx);
            const value2 = data === null ? codecs.fallback : codecs.value.dec(data);
            if (!valuesAreCompatible(descriptors, ctx, value2))
              throw incompatibleError();
            return value2;
          }
        )
      )
    );
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal } = isLastArgOptional ? lastArg : {};
    return firstValueFromWithSignal(
      getRawValue$(...args).pipe(toMapped),
      signal
    );
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const descriptors = await descriptorsPromise;
    const result$ = chainHead2.storage$(
      at,
      "descendantsValues",
      (ctx) => {
        const codecs = getCodec(ctx);
        if (minCompatLevel(getCompatibilityLevels(descriptors, ctx)) === CompatibilityLevel.Incompatible)
          throw incompatibleError();
        if (args.length > codecs.len) throw invalidArgs(args);
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs(args);
        return codecs.keys.enc(...actualArgs);
      },
      null,
      (values, ctx) => {
        const codecs = getCodec(ctx);
        const decodedValues = values.map(({ key, value: value2 }) => ({
          keyArgs: codecs.keys.dec(key),
          value: codecs.value.dec(value2)
        }));
        if (decodedValues.some(
          ({ value: value2 }) => !valuesAreCompatible(descriptors, ctx, value2)
        ))
          throw incompatibleError();
        return decodedValues;
      }
    ).pipe(toMapped);
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  const watchEntries = (...args) => {
    const lastArg = args.at(-1);
    const isLastArgOptional = isOptionalArg(lastArg);
    return getWatchEntries(
      pallet,
      name,
      isLastArgOptional ? args.slice(0, -1) : args,
      isLastArgOptional && lastArg.at === "best"
    );
  };
  return {
    isCompatible: isCompatible2,
    getCompatibilityLevel,
    getValue,
    getValues,
    getEntries,
    watchValue,
    watchEntries
  };
};

// node_modules/.pnpm/@polkadot-api+signers-common@0.1.7/node_modules/@polkadot-api/signers-common/dist/esm/v4.mjs
var versionCodec = enhanceEncoder(
  u82.enc,
  (value2) => +!!value2.signed << 7 | value2.version
);
var unkownSignerType = () => new Error("Unkown signer");
var getSignerType = (metadata2) => {
  const { extrinsic: extrinsic3 } = metadata2;
  const getLookup = getLookupFn(metadata2);
  let address;
  let signature;
  if ("address" in extrinsic3) {
    address = getLookup(extrinsic3.address);
    signature = getLookup(extrinsic3.signature);
  } else {
    const extProps = Object.fromEntries(
      metadata2.lookup[extrinsic3.type].params.filter((x) => x.type != null).map((x) => [x.name, getLookup(x.type)])
    );
    address = extProps["Address"];
    signature = extProps["Signature"];
    if (!address || !signature) throw unkownSignerType();
  }
  if (address.type === "AccountId20" && signature.type === "array" && signature.len === 65 && signature.value.type === "primitive" && signature.value.value === "u8")
    return [1, []];
  if (signature.type !== "enum" || ["Ecdsa", "Ed25519", "Sr25519"].some((x) => !(x in signature.value)))
    throw unkownSignerType();
  if (address.type === "enum") {
    const id = address.value["Id"];
    if (id.type === "lookupEntry" && id.value.type === "AccountId32")
      return [0, [id.idx]];
  } else if (address.type === "AccountId32") return [0, []];
  throw unkownSignerType();
};
var signingTypeId = {
  Ed25519: 0,
  Sr25519: 1,
  Ecdsa: 2
};
var createV4Tx = (metadata2, publicKey, signed, extra, callData, signingType) => {
  const [signerType, addressPrefix] = getSignerType(metadata2);
  const preResult = mergeUint82(
    versionCodec({ signed: true, version: 4 }),
    // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`
    signerType === 1 ? publicKey : new Uint8Array([...addressPrefix, ...publicKey]),
    signerType === 1 || !signingType ? signed : new Uint8Array([signingTypeId[signingType], ...signed]),
    ...extra,
    callData
  );
  return mergeUint82(compact.enc(preResult.length), preResult);
};

// node_modules/.pnpm/@polkadot-api+signers-common@0.1.7/node_modules/@polkadot-api/signers-common/dist/esm/sign-bytes.mjs
var [preBytes, postBytes] = ["<Bytes>", "</Bytes>"].map(
  (str2) => Binary.fromText(str2).asBytes()
);
var getSignBytes = (sign) => async (data) => {
  let isPadded = true;
  let i;
  for (i = 0; isPadded && i < preBytes.length; i++)
    isPadded = preBytes[i] === data[i];
  isPadded = isPadded && i === preBytes.length;
  const postDataStart = data.length - postBytes.length;
  for (i = 0; isPadded && i < postBytes.length; i++)
    isPadded = postBytes[i] === data[postDataStart + i];
  isPadded = isPadded && i === postBytes.length;
  return sign(isPadded ? data : mergeUint82(preBytes, data, postBytes));
};

// node_modules/.pnpm/@polkadot-api+signer@0.1.16/node_modules/@polkadot-api/signer/dist/esm/from-raw-signer.mjs
function getPolkadotSigner(publicKey, signingType, sign) {
  const signTx = async (callData, signedExtensions, metadata2, _, hasher = Blake2256) => {
    let decMeta;
    try {
      const tmpMeta = decAnyMetadata(metadata2);
      if (tmpMeta.metadata.tag !== "v14" && tmpMeta.metadata.tag !== "v15")
        throw null;
      decMeta = tmpMeta.metadata.value;
    } catch (_2) {
      throw new Error("Unsupported metadata version");
    }
    const extra = [];
    const additionalSigned2 = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed extension`);
      extra.push(signedExtension.value);
      additionalSigned2.push(signedExtension.additionalSigned);
    });
    const toSign = mergeUint82(callData, ...extra, ...additionalSigned2);
    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign);
    return createV4Tx(decMeta, publicKey, signed, extra, callData, signingType);
  };
  return {
    publicKey,
    signTx,
    signBytes: getSignBytes(sign)
  };
}

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/system-version.mjs
var getSystemVersionStruct = (lookupFn, dynamicBuilder) => {
  const constant = lookupFn.metadata.pallets.find((x) => x.name === "System").constants.find((s) => s.name === "Version");
  const systemVersion = lookupFn(constant.type);
  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec;
  if (systemVersion.type !== "struct") throw new Error("not a struct");
  return systemVersionDec(constant.value);
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/mortal-enc.mjs
function trailingZeroes(n) {
  let i = 0;
  while (!(n & 1)) {
    i++;
    n >>= 1;
  }
  return i;
}
var mortal = enhanceEncoder(
  Bytes(2)[0],
  (value2) => {
    const factor = Math.max(value2.period >> 12, 1);
    const left = Math.min(Math.max(trailingZeroes(value2.period) - 1, 1), 15);
    const right = value2.phase / factor << 4;
    return u16[0](left | right);
  }
);

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/charge-asset-tx-enc.mjs
var [ChargeAssetTxPaymentEnc] = Struct2({
  tip: compact,
  asset: Option2(Bytes(Infinity))
});

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/sign-extensions.mjs
var empty2 = new Uint8Array();
var zero = Uint8Array.from([0]);
var value = (value2) => ({
  value: value2,
  additionalSigned: empty2
});
var additionalSigned = (additionalSigned2) => ({
  value: empty2,
  additionalSigned: additionalSigned2
});
var both = (value2, additionalSigned2) => ({
  value: value2,
  additionalSigned: additionalSigned2
});
var getSignExtensionsCreator = (genesis, lookupFn, dynamicBuilder) => {
  const signedExtensionsEncoders = {};
  lookupFn.metadata.extrinsic.signedExtensions.forEach(
    ({ identifier, type, additionalSigned: additionalSigned2 }) => {
      signedExtensionsEncoders[identifier] = [type, additionalSigned2].map(
        (x) => dynamicBuilder.buildDefinition(x)[0]
      );
    }
  );
  return ({
    mortality,
    tip = 0n,
    nonce,
    customSignedExtensions = {},
    ...rest
  }) => {
    const invalidKeys = [];
    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder);
    const getFromCustomEntry = (key) => {
      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key];
      const customEntry = customSignedExtensions[key];
      try {
        return mapObject2(
          {
            value: valueEnc,
            additionalSigned: additionalEnc
          },
          (encoder, key2) => {
            const input = customEntry == null ? void 0 : customEntry[key2];
            return input instanceof Uint8Array ? input : encoder(input);
          }
        );
      } catch {
        invalidKeys.push(key);
        return null;
      }
    };
    const result = mapObject2(
      signedExtensionsEncoders,
      ([valueEnc, additionalEnc], key) => {
        if (customSignedExtensions[key]) return getFromCustomEntry(key);
        switch (key) {
          case "CheckNonce":
            return value(valueEnc(nonce));
          case "CheckMortality":
            return mortality.mortal ? both(
              mortal({
                period: mortality.period,
                phase: mortality.startAtBlock.height % mortality.period
              }),
              fromHex2(mortality.startAtBlock.hash)
            ) : both(zero, genesis);
          case "ChargeTransactionPayment":
            return value(valueEnc(tip));
          case "ChargeAssetTxPayment":
            return value(
              ChargeAssetTxPaymentEnc({
                tip,
                asset: rest.asset
              })
            );
          case "CheckGenesis":
            return additionalSigned(genesis);
          case "CheckMetadataHash":
            return both(zero, zero);
          case "CheckSpecVersion":
            return additionalSigned(
              additionalEnc(systemVersion["spec_version"])
            );
          case "CheckTxVersion":
            return additionalSigned(
              additionalEnc(systemVersion["transaction_version"])
            );
          default:
            return getFromCustomEntry(key);
        }
      }
    );
    invalidKeys.forEach((key) => {
      delete result[key];
    });
    return mapObject2(result, (x, identifier) => ({ ...x, identifier }));
  };
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/create-tx.mjs
var NONCE_RUNTIME_CALL = "AccountNonceApi_account_nonce";
var lenToDecoder = {
  1: u82.dec,
  2: u16.dec,
  4: u322.dec,
  8: u64.dec
};
var getNonceAtBlock$ = (call$, from2, at) => call$(at, NONCE_RUNTIME_CALL, from2).pipe(
  map((result) => {
    const bytes = fromHex2(result);
    const decoder = lenToDecoder[bytes.length];
    if (!decoder)
      throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`);
    return decoder(bytes);
  })
);
var createTx = (chainHead2, signer, callData, atBlock, customSignedExtensions, hinted = {}) => combineLatest([
  hinted.nonce ? of(hinted.nonce) : getNonce$(chainHead2, toHex(signer.publicKey)),
  chainHead2.getRuntimeContext$(atBlock.hash),
  chainHead2.genesis$
]).pipe(
  take(1),
  mergeMap(([nonce, ctx, genesis]) => {
    const signExtCreator = getSignExtensionsCreator(
      fromHex2(genesis),
      ctx.lookup,
      ctx.dynamicBuilder
    );
    const mortality = hinted.mortality ?? { period: 64, mortal: true };
    const signExtensions = signExtCreator({
      nonce,
      tip: hinted.tip ?? 0n,
      mortality: mortality.mortal ? {
        mortal: true,
        period: mortality.period,
        startAtBlock: {
          height: atBlock.number,
          hash: atBlock.hash
        }
      } : { mortal: false },
      customSignedExtensions
    });
    return signer.signTx(
      callData,
      signExtensions,
      ctx.metadataRaw,
      atBlock.number
    );
  })
);
var getNonce$ = (chainHead2, from2) => {
  const followHead$ = (head) => chainHead2.newBlocks$.pipe(
    scan((acc, block) => block.parent === acc ? block.hash : acc, head),
    startWith(head),
    distinctUntilChanged()
  );
  const followNonce$ = (head) => followHead$(head).pipe(
    take(2),
    switchMap((hash) => getNonceAtBlock$(chainHead2.call$, from2, hash))
  );
  const getHeadsNonce$ = (heads) => combineLatest(
    heads.map(
      (head) => followNonce$(head).pipe(
        map((value2) => ({
          success: true,
          value: value2
        })),
        catchError(
          (err) => of({
            success: false,
            value: err
          })
        )
      )
    )
  ).pipe(take(1));
  return chainHead2.pinnedBlocks$.pipe(
    filter((v) => !v.recovering && v.blocks.size > 0),
    take(1),
    map(({ blocks, best }) => {
      const bestBlock = blocks.get(best);
      return [...blocks.values()].filter(
        (v) => !v.unpinnable && v.children.size === 0 && v.number >= bestBlock.number
      ).map((v) => v.hash);
    }),
    switchMap(getHeadsNonce$),
    map((result) => {
      const winner = result.reduce(
        (acc, v) => v.success ? v.value >= (acc ?? 0) ? v.value : acc : acc,
        null
      );
      if (winner == null) {
        throw result[0].value;
      }
      return winner;
    })
  );
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/continue-with.mjs
var NOTIN = {};
var continueWith = (mapper) => (source) => new Observable((observer) => {
  let latestValue = NOTIN;
  let subscription = source.subscribe({
    next(v) {
      observer.next(latestValue = v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (latestValue === NOTIN) observer.complete();
      else subscription = mapper(latestValue).subscribe(observer);
    }
  });
  return () => {
    subscription.unsubscribe();
  };
});

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/submit-fns.mjs
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value2) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField6 = (obj, key, value2) => __defNormalProp6(obj, key + "", value2);
var hashFromTx = (tx) => toHex(Blake2256(fromHex2(tx)));
var computeState = (analized$, blocks$) => new Observable((observer) => {
  const analyzedBlocks = /* @__PURE__ */ new Map();
  let pinnedBlocks;
  let latestState;
  const computeNextState = () => {
    var _a;
    let current = pinnedBlocks.best;
    let analyzed = analyzedBlocks.get(current);
    let analyzedNumber = pinnedBlocks.blocks.get(current).number;
    while (!analyzed) {
      const block = pinnedBlocks.blocks.get(current);
      if (!block) break;
      analyzed = analyzedBlocks.get(current = block.parent);
      analyzedNumber--;
    }
    if (!analyzed) return;
    const isFinalized = analyzedNumber <= pinnedBlocks.blocks.get(pinnedBlocks.finalized).number;
    const found = analyzed.found.type;
    if (found && (latestState == null ? void 0 : latestState.found) && latestState.hash === analyzed.hash) {
      if (isFinalized) observer.complete();
      return;
    }
    observer.next(
      latestState = analyzed.found.type ? {
        found,
        hash: analyzed.hash,
        number: analyzedNumber,
        index: analyzed.found.index,
        events: analyzed.found.events
      } : {
        found,
        validity: analyzed.found.validity
      }
    );
    if (isFinalized) {
      if (found) observer.complete();
      else if (((_a = analyzed.found.validity) == null ? void 0 : _a.success) === false)
        observer.error(new InvalidTxError(analyzed.found.validity.value));
    }
  };
  const subscription = blocks$.pipe(
    distinctUntilChanged(
      (a, b) => a.finalized === b.finalized && a.best === b.best
    )
  ).subscribe({
    next: (pinned) => {
      pinnedBlocks = pinned;
      if (analyzedBlocks.size === 0) return;
      computeNextState();
    },
    error(e) {
      observer.error(e);
    }
  });
  subscription.add(
    analized$.subscribe({
      next: (block) => {
        analyzedBlocks.set(block.hash, block);
        computeNextState();
      },
      error(e) {
        observer.error(e);
      }
    })
  );
  return subscription;
}).pipe(distinctUntilChanged((a, b) => a === b));
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => ({ ...x.event, topics: x.topics }));
  const lastEvent = events[events.length - 1];
  if (lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicFailed") {
    return {
      ok: false,
      events,
      dispatchError: lastEvent.value.value.dispatch_error
    };
  }
  return { ok: true, events };
};
var InvalidTxError = class extends Error {
  // likely to be a `TransactionValidityError`
  constructor(e) {
    super(
      JSON.stringify(
        e,
        (_, value2) => {
          if (typeof value2 === "bigint") return value2.toString();
          return value2 instanceof Binary ? value2.asHex() : value2;
        },
        2
      )
    );
    __publicField6(this, "error");
    this.name = "InvalidTxError";
    this.error = e;
  }
};
var submit$ = (chainHead2, broadcastTx$, tx, at, emitSign = false) => {
  const txHash = hashFromTx(tx);
  const getTxEvent = (type, rest) => ({
    type,
    txHash,
    ...rest
  });
  const at$ = chainHead2.pinnedBlocks$.pipe(
    take(1),
    map((blocks) => {
      const block = blocks.blocks.get(at);
      return block ? block.hash : blocks.finalized;
    })
  );
  const validate$ = at$.pipe(
    mergeMap(
      (at2) => chainHead2.validateTx$(at2, tx).pipe(
        filter((x) => !x.success),
        map((x) => {
          throw new InvalidTxError(x.value);
        })
      )
    )
  );
  const track$ = new Observable((observer) => {
    const subscription = chainHead2.trackTx$(tx).subscribe(observer);
    subscription.add(
      broadcastTx$(tx).subscribe({
        error(e) {
          observer.error(e);
        }
      })
    );
    return subscription;
  });
  const bestBlockState$ = computeState(track$, chainHead2.pinnedBlocks$).pipe(
    map((x) => {
      var _a;
      if (!x.found)
        return getTxEvent("txBestBlocksState", {
          found: false,
          isValid: ((_a = x.validity) == null ? void 0 : _a.success) !== false
        });
      return getTxEvent("txBestBlocksState", {
        found: true,
        block: {
          index: x.index,
          number: x.number,
          hash: x.hash
        },
        ...getTxSuccessFromSystemEvents(x.events, x.index)
      });
    })
  );
  return concat(
    emitSign ? of(getTxEvent("signed", {})) : EMPTY,
    validate$,
    of(getTxEvent("broadcasted", {})),
    bestBlockState$.pipe(
      continueWith(
        ({ found, type, ...rest }) => found ? of(getTxEvent("finalized", rest)) : EMPTY
      )
    )
  );
};
var submit = async (chainHead2, broadcastTx$, transaction2, at) => lastValueFrom(submit$(chainHead2, broadcastTx$, transaction2, at)).then((x) => {
  if (x.type !== "finalized") throw null;
  const result = { ...x };
  delete result.type;
  return result;
});

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/tx.mjs
var accountIdEnc = AccountId().enc;
var fakeSignature = new Uint8Array(64);
var fakeSignatureEth = new Uint8Array(65);
var getFakeSignature = (isEth) => () => isEth ? fakeSignatureEth : fakeSignature;
var [, queryInfoDecFallback] = Struct2({
  weight: Struct2({
    ref_time: compactBn,
    proof_size: compactBn
  }),
  class: Variant({
    Normal: _void,
    Operational: _void,
    Mandatory: _void
  }),
  partial_fee: u128
});
var createTxEntry = (pallet, name, chainHead2, broadcast, {
  isCompatible: isCompatibleHelper,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  getRuntimeTypedef
}, checkCompatibility) => {
  const fn = (arg) => {
    const getCallDataWithContext = (runtime, arg2, txOptions = {}) => {
      const ctx = getCompatibilityApi(runtime).runtime();
      const { dynamicBuilder, assetId, lookup: lookup2 } = ctx;
      let codecs;
      try {
        codecs = dynamicBuilder.buildCall(pallet, name);
      } catch {
        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
      }
      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg2))
        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
      let returnOptions = txOptions;
      if (txOptions.asset) {
        if (assetId == null || !isCompatible(
          txOptions.asset,
          mapLookupToTypedef(lookup2(assetId)),
          (id) => getRuntimeTypedef(ctx, id)
        ))
          throw new Error(`Incompatible runtime asset`);
        returnOptions = {
          ...txOptions,
          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset)
        };
      }
      const { location, codec } = codecs;
      return {
        callData: Binary.fromBytes(
          mergeUint82(new Uint8Array(location), codec.enc(arg2))
        ),
        options: returnOptions
      };
    };
    const getCallData$ = (arg2, options = {}) => compatibleRuntime$(chainHead2, null).pipe(
      map(([runtime]) => getCallDataWithContext(runtime, arg2, options))
    );
    const getEncodedData = (token) => {
      if (!token)
        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)));
      return getCallDataWithContext(token, arg).callData;
    };
    const sign$ = (from2, { ..._options }, atBlock) => getCallData$(arg, _options).pipe(
      mergeMap(
        ({ callData, options }) => createTx(
          chainHead2,
          from2,
          callData.asBytes(),
          atBlock,
          _options.customSignedExtensions || {},
          options
        )
      )
    );
    const _sign = (from2, { at, ..._options } = {}) => {
      return (!at || at === "finalized" ? chainHead2.finalized$ : at === "best" ? chainHead2.best$ : chainHead2.bestBlocks$.pipe(
        map((x) => x.find((b) => b.hash === at))
      )).pipe(
        take(1),
        mergeMap(
          (atBlock) => atBlock ? sign$(from2, _options, atBlock).pipe(
            map((signed) => ({
              tx: toHex(signed),
              block: atBlock
            }))
          ) : throwError(() => new Error(`Uknown block ${at}`))
        )
      );
    };
    const sign = (from2, options) => firstValueFrom(_sign(from2, options)).then((x) => x.tx);
    const signAndSubmit = (from2, _options) => firstValueFrom(_sign(from2, _options)).then(
      ({ tx, block }) => submit(chainHead2, broadcast, tx, block.hash)
    );
    const signSubmitAndWatch = (from2, _options) => _sign(from2, _options).pipe(
      mergeMap(
        ({ tx, block }) => submit$(chainHead2, broadcast, tx, block.hash, true)
      )
    );
    const getPaymentInfo = async (from2, _options) => {
      if (typeof from2 === "string")
        from2 = from2.startsWith("0x") ? fromHex2(from2) : accountIdEnc(from2);
      const isEth = from2.length === 20;
      const fakeSigner = getPolkadotSigner(
        from2,
        isEth ? "Ecdsa" : "Sr25519",
        getFakeSignature(isEth)
      );
      const encoded = fromHex2(await sign(fakeSigner, _options));
      const args = toHex(mergeUint82(encoded, u322.enc(encoded.length)));
      const decoder$ = chainHead2.getRuntimeContext$(null).pipe(
        map((ctx) => {
          try {
            return ctx.dynamicBuilder.buildRuntimeCall(
              "TransactionPaymentApi",
              "query_info"
            ).value[1];
          } catch {
            return queryInfoDecFallback;
          }
        })
      );
      const call$ = chainHead2.call$(
        null,
        "TransactionPaymentApi_query_info",
        args
      );
      return firstValueFrom(
        combineLatest([call$, decoder$]).pipe(
          map(([result, decoder]) => decoder(result))
        )
      );
    };
    const getEstimatedFees = async (from2, _options) => (await getPaymentInfo(from2, _options)).partial_fee;
    return {
      getPaymentInfo,
      getEstimatedFees,
      decodedCall: {
        type: pallet,
        value: Enum2(name, arg)
      },
      getEncodedData,
      sign,
      signSubmitAndWatch,
      signAndSubmit
    };
  };
  return Object.assign(fn, {
    getCompatibilityLevel,
    isCompatible: isCompatibleHelper
  });
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/self-dependent.mjs
var selfDependent = () => {
  const activeSubject = new BehaviorSubject(
    new Subject()
  );
  return [
    activeSubject.pipe(switchAll()),
    () => tap({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new Subject());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new Subject());
      }
    })
  ];
};

// node_modules/.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/dist/rxstate.core.es2017.js
var __defProp7 = Object.defineProperty;
var __defNormalProp7 = (obj, key, value2) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField7 = (obj, key, value2) => {
  __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var SUSPENSE = Symbol("SUSPENSE");
var StatePromise = class extends Promise {
  constructor(cb) {
    super(cb);
  }
};
var NoSubscribersError = class extends Error {
  constructor() {
    super();
    this.name = "NoSubscribersError";
  }
};
var EmptyObservableError = class extends Error {
  constructor() {
    super();
    this.name = "EmptyObservableError";
  }
};
var EMPTY_VALUE2 = {};
var StateObservable = class extends Observable {
  constructor(source$, defaultValue, teardown = noop) {
    super((subscriber) => {
      const subscriberWithoutComplete = new Subscriber({
        next: subscriber.next.bind(subscriber),
        error: subscriber.error.bind(subscriber),
        complete: noop
      });
      this.refCount++;
      let innerSub;
      subscriber.add(() => {
        var _a;
        this.refCount--;
        innerSub.unsubscribe();
        if (this.refCount === 0) {
          this.currentValue = EMPTY_VALUE2;
          if (this.subscription) {
            this.subscription.unsubscribe();
          }
          teardown();
          (_a = this.subject) == null ? void 0 : _a.complete();
          this.subject = null;
          this.subscription = null;
          if (this.promise) {
            this.promise.rej(new NoSubscribersError());
            this.promise = null;
          }
        }
      });
      if (!this.subject) {
        this.subject = new Subject();
        innerSub = this.subject.subscribe(subscriberWithoutComplete);
        this.subscription = null;
        this.subscription = new Subscriber({
          next: (value2) => {
            if (this.promise && value2 !== SUSPENSE) {
              this.promise.res(value2);
              this.promise = null;
            }
            this.subject.next(this.currentValue = value2);
          },
          error: (err) => {
            var _a;
            this.subscription = null;
            const subject = this.subject;
            this.subject = null;
            this.currentValue = EMPTY_VALUE2;
            const rej = (_a = this.promise) == null ? void 0 : _a.rej;
            if (rej && err === SUSPENSE) {
              this.promise.rej = () => {
                rej(err);
              };
            }
            subject.error(err);
            if (rej && this.promise) {
              this.promise.rej = rej;
            }
          },
          complete: () => {
            this.subscription = null;
            if (this.promise) {
              this.promise.rej(new EmptyObservableError());
              this.promise = null;
            }
            if (this.currentValue !== EMPTY_VALUE2)
              return this.subject.complete();
            if (defaultValue === EMPTY_VALUE2) {
              const subject = this.subject;
              this.subject = null;
              return subject.error(new EmptyObservableError());
            }
            this.subject.next(this.currentValue = defaultValue);
            this.subject.complete();
          }
        });
        source$.subscribe(this.subscription);
        if (defaultValue !== EMPTY_VALUE2 && this.currentValue === EMPTY_VALUE2) {
          this.subject.next(this.currentValue = defaultValue);
        }
      } else {
        innerSub = this.subject.subscribe(subscriberWithoutComplete);
        if (this.currentValue !== EMPTY_VALUE2) {
          subscriber.next(this.currentValue);
        }
      }
    });
    this.defaultValue = defaultValue;
    __publicField7(this, "subject", null);
    __publicField7(this, "subscription", null);
    __publicField7(this, "refCount", 0);
    __publicField7(this, "currentValue", EMPTY_VALUE2);
    __publicField7(this, "promise", null);
    __publicField7(this, "pipeState", (...ops) => {
      const result = super.pipe(...ops);
      return result instanceof StateObservable ? result : new StateObservable(result, EMPTY_VALUE2);
    });
    __publicField7(this, "getRefCount", () => {
      return this.refCount;
    });
    __publicField7(this, "getValue", () => {
      if (this.promise)
        return this.promise.p;
      if (this.currentValue !== EMPTY_VALUE2 && this.currentValue !== SUSPENSE)
        return this.currentValue;
      if (this.defaultValue !== EMPTY_VALUE2)
        return this.defaultValue;
      if (this.refCount === 0)
        throw new NoSubscribersError();
      const promise = new StatePromise((res, rej) => {
        this.promise = { res, rej, p: null };
      });
      this.promise.p = promise;
      return promise;
    });
    __publicField7(this, "getDefaultValue", () => {
      return this.defaultValue;
    });
    if (defaultValue === EMPTY_VALUE2) {
      delete this.getDefaultValue;
    }
  }
};
function cloneProps(internal, external2) {
  external2.getValue = internal.getValue;
  external2.getRefCount = internal.getRefCount;
  external2.pipeState = internal.pipeState;
  if (internal.getDefaultValue) {
    ;
    external2.getDefaultValue = internal.getDefaultValue;
  }
}
function connectFactoryObservable(getObservable, defaultValue) {
  const cache = new NestedMap();
  const getDefaultValue = typeof defaultValue === "function" ? defaultValue : () => defaultValue;
  const getSharedObservables$ = (input) => {
    for (let i = input.length - 1; input[i] === void 0 && i > -1; i--) {
      input.splice(-1);
    }
    const keys = [input.length, ...input];
    const cachedVal = cache.get(keys);
    if (cachedVal !== void 0) {
      return cachedVal;
    }
    const sharedObservable$ = new StateObservable(getObservable(...input), getDefaultValue(...input), () => {
      cache.delete(keys);
    });
    const publicShared$ = new Observable((subscriber) => {
      const inCache = cache.get(keys);
      let source$ = sharedObservable$;
      if (!inCache) {
        cache.set(keys, result);
      } else if (inCache !== publicShared$) {
        source$ = inCache;
        cloneProps(source$, publicShared$);
      }
      return source$.subscribe(subscriber);
    });
    cloneProps(sharedObservable$, publicShared$);
    const result = publicShared$;
    cache.set(keys, result);
    return result;
  };
  return (...input) => getSharedObservables$(input);
}
var NestedMap = class {
  constructor() {
    __publicField7(this, "root");
    this.root = /* @__PURE__ */ new Map();
  }
  get(keys) {
    let current = this.root;
    for (let i = 0; i < keys.length; i++) {
      current = current.get(keys[i]);
      if (!current)
        return void 0;
    }
    return current;
  }
  set(keys, value2) {
    let current = this.root;
    let i;
    for (i = 0; i < keys.length - 1; i++) {
      let nextCurrent = current.get(keys[i]);
      if (!nextCurrent) {
        nextCurrent = /* @__PURE__ */ new Map();
        current.set(keys[i], nextCurrent);
      }
      current = nextCurrent;
    }
    current.set(keys[i], value2);
  }
  delete(keys) {
    const maps = [this.root];
    let current = this.root;
    for (let i = 0; i < keys.length - 1; i++) {
      maps.push(current = current.get(keys[i]));
    }
    let mapIdx = maps.length - 1;
    maps[mapIdx].delete(keys[mapIdx]);
    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {
      maps[mapIdx].delete(keys[mapIdx]);
    }
  }
};
function state(observable, defaultValue) {
  return new StateObservable(observable, defaultValue);
}
var state2 = (...args) => (typeof args[0] === "function" ? connectFactoryObservable : state)(args[0], args.length > 1 ? args[1] : EMPTY_VALUE2);

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/watch-entries.mjs
var getDiff = (_prev, _current, patch) => {
  const current = new Map(_current.map((x) => [x.key, x]));
  const prev = new Map(_prev.map((x) => [x.key, x]));
  const upserted = /* @__PURE__ */ new Map();
  const deleted = [];
  _current.forEach((value2) => {
    const { key } = value2;
    const prevVal = prev.get(key);
    if (!prevVal || prevVal.value !== value2.value)
      upserted.set(key, patch(value2));
  });
  _prev.forEach((x) => {
    if (!current.has(x.key)) deleted.push(x);
  });
  return {
    deltas: {
      deleted,
      upserted: [...upserted.values()]
    },
    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key))
  };
};
var findPrevious = (start, state22, pinned, includeStart = false) => {
  try {
    let target = includeStart ? start : pinned.blocks.get(start).parent;
    while (target && !state22[target]) target = pinned.blocks.get(target).parent;
    if (!target) return null;
    return state22[target];
  } catch {
    return null;
  }
};
var getPatcherFromRuntime = (pallet, entry2) => (runtime) => {
  const { keys, value: value2 } = runtime.dynamicBuilder.buildStorage(pallet, entry2);
  return (x) => {
    x.dec = {
      value: value2.dec(x.value),
      args: keys.dec(x.key)
    };
    return x;
  };
};
var createWatchEntries = (blocks$, storage2, withRuntime) => {
  const getMemoryBlocks$ = state2(
    (pallet, entry2, storageKey) => {
      const getPatcher = getPatcherFromRuntime(pallet, entry2);
      const getNextMemoryBlock$ = (prev, block) => {
        const isNotCanonical$ = isBestOrFinalizedBlock(
          blocks$,
          block.hash
        ).pipe(
          filter((x) => !x),
          take(1)
        );
        return storage2(
          block.hash,
          "closestDescendantMerkleValue",
          () => storageKey
        ).pipe(
          mergeMap((rootHash) => {
            if (rootHash === (prev == null ? void 0 : prev.rootHash))
              return of({
                ...prev,
                block,
                deltas: null,
                prev: prev.block.hash
              });
            return storage2(
              block.hash,
              "descendantsValues",
              () => storageKey
            ).pipe(
              withRuntime(() => block.hash),
              map(
                ([entries, runtimeCtx]) => [entries, getPatcher(runtimeCtx)]
              ),
              map(
                ([entries, patcher]) => ({
                  prev: prev && prev.block.hash,
                  rootHash,
                  block,
                  ...getDiff(
                    (prev == null ? void 0 : prev.entries) ?? [],
                    entries,
                    patcher
                  )
                })
              )
            );
          }),
          takeUntil(isNotCanonical$),
          catchError(
            (e) => e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e)
          )
        );
      };
      const initial$ = blocks$.pipe(
        distinctUntilChanged((a, b) => a.finalized === b.finalized),
        lossLessExhaustMap(
          ({ blocks, finalized }) => getNextMemoryBlock$(null, blocks.get(finalized))
        ),
        take(1),
        map(
          (x) => ({
            blocks: { [x.block.hash]: x },
            finalized: x.block.hash
          })
        )
      );
      const [_memoryBlocks$, connectMemoryBlocks] = selfDependent();
      const updates$ = blocks$.pipe(
        distinctUntilChanged((a, b) => a.best === b.best),
        withLatestFrom(_memoryBlocks$),
        lossLessExhaustMap(([pinned, memoryBlocks]) => {
          const { best } = pinned;
          const { blocks } = memoryBlocks;
          let target = !blocks[best] ? best : null;
          if (!target) return EMPTY;
          const previous = findPrevious(target, blocks, pinned);
          if (previous)
            return getNextMemoryBlock$(
              previous,
              pinned.blocks.get(target)
            ).pipe(
              map((x) => {
                blocks[target] = x;
                return memoryBlocks;
              })
            );
          target = pinned.finalized;
          return getNextMemoryBlock$(
            blocks[memoryBlocks.finalized],
            pinned.blocks.get(target)
          ).pipe(
            map((x) => {
              x.prev = null;
              return {
                blocks: { [target]: x },
                finalized: target
              };
            })
          );
        })
      );
      return merge(initial$, updates$).pipe(connectMemoryBlocks());
    }
  );
  const getBestOrFinalized = (isFinalized) => (pallet, entry2, storageKey) => {
    const memoryBlocks$ = getMemoryBlocks$(pallet, entry2, storageKey);
    const getPatcher = getPatcherFromRuntime(pallet, entry2);
    const prop = isFinalized ? "finalized" : "best";
    return combineLatest([
      memoryBlocks$.pipe(delay(0)),
      blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop]))
    ]).pipe(
      map(
        ([state22, blocks]) => findPrevious(blocks[prop], state22.blocks, blocks, true)
      ),
      filter(Boolean),
      distinctUntilChanged(),
      startWith(null),
      pairwise(),
      withLatestFrom(memoryBlocks$),
      withRuntime(([[, _latest]]) => _latest.block.hash),
      map(
        ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) => [
          prevUpdate,
          latest,
          memoryBlocks,
          getPatcher(runtimeCtx)
        ]
      ),
      mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {
        if (!prevUpdate) return [latest];
        let ancestor = latest;
        const updates = [];
        while (ancestor && ancestor.block.number > prevUpdate.block.number) {
          updates.unshift(ancestor);
          ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null;
        }
        if (isFinalized) {
          memoryBlocks.finalized = latest.block.hash;
          if (updates.length) {
            const { blocks } = memoryBlocks;
            Object.keys(blocks).forEach((key) => {
              if (blocks[key].block.number < updates[0].block.number)
                delete blocks[key];
            });
          }
        }
        if (prevUpdate === ancestor) return updates;
        return [
          {
            ...latest,
            ...prevUpdate.rootHash === latest.rootHash ? {
              entries: prevUpdate.entries,
              deltas: null
            } : getDiff(prevUpdate.entries, latest.entries, patcher)
          }
        ];
      })
    );
  };
  const getFinalized$ = state2(getBestOrFinalized(true));
  const getBest$ = state2(getBestOrFinalized(false));
  return (pallet, entry2, args, atBest) => {
    const fn = atBest ? getBest$ : getFinalized$;
    const storageKey$ = blocks$.pipe(
      take(1),
      mergeMap(
        (b) => b.runtimes[b.blocks.get(b[atBest ? "best" : "finalized"]).runtime].runtime
      ),
      map(
        (runtime) => runtime.dynamicBuilder.buildStorage(pallet, entry2).keys.enc(...args)
      )
    );
    return storageKey$.pipe(
      take(1),
      mergeMap((storageKey) => fn(pallet, entry2, storageKey)),
      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {
        const actualDeltas = idx > 0 ? deltas : { deleted: [], upserted: entries };
        return {
          block: { hash, number, parent },
          entries: entries.map(toDec),
          deltas: actualDeltas && {
            deleted: actualDeltas.deleted.map(toDec),
            upserted: actualDeltas.upserted.map(toDec)
          }
        };
      })
    );
  };
};
var toDec = (x) => x.dec;

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/client.mjs
var createApi = (compatibilityToken, chainHead2, broadcast$) => {
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const getPallet = (ctx, name) => ctx.lookup.metadata.pallets.find((p) => p.name === name);
  const getWatchEntries = createWatchEntries(
    chainHead2.pinnedBlocks$,
    chainHead2.storage$,
    chainHead2.withRuntime
  );
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead2,
      getWatchEntries,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Storage, pallet, name),
        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.
        (ctx) => {
          var _a, _b;
          const item = (_b = (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.storage) == null ? void 0 : _b.items.find(
            (s) => s.name === name
          );
          return item == null ? null : storageEntryPoint(item);
        }
      )
    )
  );
  const getEnumEntry = (ctx, side, id, name) => {
    if (id == null) return null;
    const entry2 = ctx.lookup(id);
    if (entry2.type !== "enum") throw new Error("Expected enum");
    if (entry2.value[name] == null) return null;
    const node = enumValueEntryPointNode(entry2.value[name]);
    return {
      args: side === "args" ? node : voidEntryPointNode,
      values: side === "args" ? voidEntryPointNode : node
    };
  };
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainHead2,
      broadcast$,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Tx, pallet, name),
        (ctx) => {
          var _a;
          return getEnumEntry(ctx, "args", (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.calls, name);
        }
      ),
      true
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead2,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Event, pallet, name),
        (ctx) => {
          var _a;
          return getEnumEntry(ctx, "values", (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.events, name);
        }
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Const, pallet, name),
        (ctx) => {
          var _a, _b;
          const item = (_b = (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.constants.find(
            (c) => c.name === name
          )) == null ? void 0 : _b.type;
          return item == null ? null : singleValueEntryPoint(item);
        }
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead2,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getApiEntryPoint(api, method),
        (ctx) => runtimeCallEntryPoint(
          ctx.lookup.metadata.apis.find((a) => a.name === api).methods.find((m) => m.name === method)
        )
      )
    )
  );
  const _callDataTx = (callData, token) => {
    const { lookup: lookup2, dynamicBuilder } = getCompatibilityApi(token).runtime();
    try {
      const decoded = dynamicBuilder.buildDefinition(lookup2.call).dec(callData.asBytes());
      const pallet = decoded.type;
      const call = decoded.value.type;
      const args = decoded.value.value;
      return createTxEntry(
        pallet,
        call,
        chainHead2,
        broadcast$,
        compatibilityHelper(
          compatibilityToken,
          (r) => r.getPalletEntryPoint(OpType.Tx, pallet, call),
          (ctx) => {
            var _a;
            return getEnumEntry(ctx, "args", (_a = getPallet(ctx, pallet)) == null ? void 0 : _a.calls, call);
          }
        ),
        false
      )(args);
    } catch {
      throw new Error("createTx: invalid call data");
    }
  };
  return {
    query,
    txFromCallData: (callData, token) => token ? _callDataTx(callData, token) : compatibilityToken.then((t) => _callDataTx(callData, t)),
    tx,
    event,
    apis,
    constants
  };
};
function createClient3(provider) {
  const rawClient = createClient2(provider);
  const client = getObservableClient(rawClient);
  const { getChainSpecData } = rawClient;
  const { genesis$, ..._chainHead } = client.chainHead$();
  const chainHead2 = {
    ..._chainHead,
    genesis$: defer(getChainSpecData).pipe(
      map(({ genesisHash }) => genesisHash),
      catchError(() => genesis$),
      shareReplay(1)
    )
  };
  const _request = rawClient.request;
  let runtimeToken;
  const compatibilityToken = /* @__PURE__ */ new WeakMap();
  const getChainToken = (chainDefinition) => {
    const result = compatibilityToken.get(chainDefinition) || createCompatibilityToken(chainDefinition, chainHead2);
    compatibilityToken.set(chainDefinition, result);
    return result;
  };
  const getRuntimeToken = () => runtimeToken ?? (runtimeToken = createRuntimeToken(chainHead2));
  const { broadcastTx$ } = client;
  return {
    getChainSpecData,
    blocks$: chainHead2.newBlocks$,
    finalizedBlock$: chainHead2.finalized$,
    getFinalizedBlock: () => firstValueFrom(chainHead2.finalized$),
    bestBlocks$: chainHead2.bestBlocks$,
    getBestBlocks: () => firstValueFrom(chainHead2.bestBlocks$),
    watchBlockBody: chainHead2.body$,
    getBlockBody: (hash) => firstValueFrom(chainHead2.body$(hash)),
    getBlockHeader: (hash) => firstValueFrom(chainHead2.header$(hash ?? null)),
    submit: (...args) => submit(chainHead2, broadcastTx$, ...args),
    submitAndWatch: (...args) => submit$(chainHead2, broadcastTx$, ...args),
    getTypedApi: (chainDefinition) => {
      const token = getChainToken(chainDefinition);
      return Object.assign(
        createApi(token, chainHead2, broadcastTx$),
        { compatibilityToken: token }
      );
    },
    getUnsafeApi: () => {
      const token = getRuntimeToken();
      return Object.assign(createApi(token, chainHead2, broadcastTx$), {
        runtimeToken: token
      });
    },
    destroy: () => {
      chainHead2.unfollow();
      client.destroy();
    },
    _request
  };
}

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/offline.mjs
var createOfflineTxEntry = (pallet, name, metadataRaw, dynamicBuilder, signExtensionCreator) => {
  let codecs;
  try {
    codecs = dynamicBuilder.buildCall(pallet, name);
  } catch {
    throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
  }
  const { location, codec } = codecs;
  const locationBytes = new Uint8Array(location);
  return (arg) => {
    const encodedData = Binary.fromBytes(
      mergeUint82(locationBytes, codec.enc(arg))
    );
    return {
      encodedData,
      decodedCall: Enum2(pallet, Enum2(name, arg)),
      sign: async (from2, extensions) => toHex(
        await from2.signTx(
          encodedData.asBytes(),
          signExtensionCreator(extensions),
          metadataRaw,
          extensions.mortality.mortal ? extensions.mortality.startAtBlock.height : 0
        )
      )
    };
  };
};
var getOfflineApi = async ({ genesis: genesisHex, getMetadata }) => {
  if (!genesisHex) throw new Error("Missing genesis hash");
  const genesis = fromHex2(genesisHex);
  const metadataRaw = await getMetadata();
  const metadata$1 = metadata.dec(metadataRaw).metadata.value;
  const lookupFn = getLookupFn(metadata$1);
  const dynamicBuilder = getDynamicBuilder(lookupFn);
  const signExtensionCreator = getSignExtensionsCreator(
    genesis,
    lookupFn,
    dynamicBuilder
  );
  const getPallet = (name) => metadata$1.pallets.find((p) => p.name === name);
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const constants = createProxyPath((pallet, name) => {
    var _a;
    const constant = (_a = getPallet(pallet)) == null ? void 0 : _a.constants.find((c) => c.name === name);
    if (!constant)
      throw new Error(`Runtime entry Constant(${pallet}.${name}) not found`);
    return dynamicBuilder.buildConstant(pallet, name).dec(constant.value);
  });
  const tx = createProxyPath(
    (pallet, name) => createOfflineTxEntry(
      pallet,
      name,
      metadataRaw,
      dynamicBuilder,
      signExtensionCreator
    )
  );
  return { constants, tx };
};

// node_modules/.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/typed-codecs/typed-codecs.mjs
var withError = (builder, errName) => (pallet, name) => {
  try {
    return builder(pallet, name);
  } catch {
    throw new Error(`Runtime entry ${errName}(${pallet}.${name}) not found`);
  }
};
var getTypedCodecs = async (descriptors) => {
  const metadata2 = decAnyMetadata(await descriptors.getMetadata()).metadata.value;
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const lookup2 = getLookupFn(metadata2);
  const {
    buildRuntimeCall,
    buildStorage,
    buildConstant,
    buildCall,
    buildEvent
  } = getDynamicBuilder(lookup2);
  return {
    query: createProxyPath((...a) => {
      const { value: value2, args } = withError(buildStorage, "Storage")(...a);
      return { value: value2, args };
    }),
    tx: createProxyPath((...a) => withError(buildCall, "Call")(...a).codec),
    event: createProxyPath(
      (...args) => withError(buildEvent, "Event")(...args).codec
    ),
    apis: createProxyPath(withError(buildRuntimeCall, "Runtime API")),
    constants: createProxyPath(withError(buildConstant, "Constant"))
  };
};

export {
  getSs58AddressInfo,
  AccountId,
  Binary,
  FixedSizeBinary,
  Enum2 as Enum,
  _Enum,
  CompatibilityLevel,
  InvalidTxError,
  createClient3 as createClient,
  getOfflineApi,
  getTypedCodecs
};
//# sourceMappingURL=chunk-JOLGTPHR.js.map
