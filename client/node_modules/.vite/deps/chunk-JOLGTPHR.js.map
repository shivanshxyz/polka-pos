{
  "version": 3,
  "sources": ["../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/dist/esm/index.mjs", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/internal/toInternalBytes.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/internal/mergeUint8.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/internal/mapObject.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/utils.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/fixed-width-ints.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/bool.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/compact.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/str.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/void.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Bytes.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Enum.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Option.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Result.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Tuple.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Struct.ts", "../../.pnpm/scale-ts@1.6.1/node_modules/scale-ts/src/codecs/Vector.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/utils/ss58-util.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/AccountId.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/hex.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/mapObject.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/mergeUint8.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/noop.ts", "../../.pnpm/@polkadot-api+utils@0.1.2/node_modules/@polkadot-api/utils/src/AbortError.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/Binary.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/compact.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/bitSequence.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/char.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/Hex.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/fixed-str.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/Self.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/types/enum.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/with-inner.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/Variant.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/ethAccount.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/scale/shaped.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/blockHeader.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/docs.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/lookup.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/pallets.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/v14.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/runtime-api.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/v15.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/codecs/metadata/metadata.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/blake2.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/blake3.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/blake3.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/identity.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/h64.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/hashes/twoX.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/storage.ts", "../../.pnpm/@polkadot-api+substrate-bindings@0.12.0/node_modules/@polkadot-api/substrate-bindings/src/utils/multisig.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/src/typedef.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/src/isCompatible.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/src/doubleSet.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/src/isStaticCompatible.ts", "../../.pnpm/@polkadot-api+metadata-compatibility@0.2.1/node_modules/@polkadot-api/metadata-compatibility/src/entryPoint.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/internal-utils/noop.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/methods.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/transaction/transaction.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/errors.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/internal-utils/deferred-promise.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/internal-utils/subscriptions-manager.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/internal-utils/abortablePromiseFn.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/operation-promise.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/body.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/call.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/header.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/storage-subscription.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/storage.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/unpin.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/client/DestroyedError.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainhead/chainhead.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/client/RpcError.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/client/createClient.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/chainspec.ts", "../../.pnpm/@polkadot-api+substrate-client@0.3.0/node_modules/@polkadot-api/substrate-client/src/index.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/operationLimitRecovery.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/errors.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/optionalHash.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/fromAbortControllerFn.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/lazyFollower.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/enhancers/withStopRecovery.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/new-blocks.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/storage-queries.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/streams/follow.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/src/lookups.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/src/with-cache.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/src/lookup-codec-builder.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/src/dynamic-builder.ts", "../../.pnpm/@polkadot-api+metadata-builders@0.11.0/node_modules/@polkadot-api/metadata-builders/src/checksum-builder.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/streams/get-runtime-creator.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/utils/shareLatest.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/streams/pinned-blocks.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/track-tx.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/validate-tx.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/utils/with-default-value.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/utils/delay-unsubscription.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/utils/concatMapEager.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/chainHead.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/tx.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/getObservableClient.ts", "../../.pnpm/@polkadot-api+observable-client@0.9.0_@polkadot-api+substrate-client@0.3.0_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/src/chainHead/streams/block-operations.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/compatibility.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/constants.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/utils/shareLatest.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/event.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/utils/firstValueFromWithSignal.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/utils/optional-arg.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/runtime-call.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/utils/lossLessExhaustMap.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/storage.ts", "../../.pnpm/@polkadot-api+signers-common@0.1.7/node_modules/@polkadot-api/signers-common/src/v4.ts", "../../.pnpm/@polkadot-api+signers-common@0.1.7/node_modules/@polkadot-api/signers-common/src/sign-bytes.ts", "../../.pnpm/@polkadot-api+signer@0.1.16/node_modules/@polkadot-api/signer/src/from-raw-signer.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/tx/signed-extensions/system-version.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/tx/signed-extensions/mortal-enc.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/tx/signed-extensions/charge-asset-tx-enc.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/tx/signed-extensions/sign-extensions.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/tx/create-tx.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/utils/continue-with.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/tx/submit-fns.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/tx/tx.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/utils/self-dependent.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/SUSPENSE.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/StatePromise.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/errors.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/internal/empty-value.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/state/stateFactory.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/internal/state-observable.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/state/stateSingle.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/state/index.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/withDefault.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/effects/sinkSuspense.ts", "../../.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/src/effects/liftSuspense.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/watch-entries.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/client.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/offline.ts", "../../.pnpm/polkadot-api@1.10.0_jiti@2.4.2_postcss@8.5.3_rxjs@7.8.2/node_modules/polkadot-api/src/typed-codecs/typed-codecs.ts"],
  "sourcesContent": ["export { AccountId } from './codecs/scale/AccountId.mjs';\nexport { Bin, Binary, FixedSizeBinary } from './codecs/scale/Binary.mjs';\nexport { bitSequence } from './codecs/scale/bitSequence.mjs';\nexport { char } from './codecs/scale/char.mjs';\nexport { compactBn, compactNumber } from './codecs/scale/compact.mjs';\nexport { Hex } from './codecs/scale/Hex.mjs';\nexport { fixedStr } from './codecs/scale/fixed-str.mjs';\nexport { Bytes, _void, bool, compact, createCodec, createDecoder, enhanceCodec, enhanceDecoder, enhanceEncoder, i128, i16, i256, i32, i64, i8, str, u128, u16, u256, u32, u64, u8 } from 'scale-ts';\nexport { Self, selfDecoder, selfEncoder } from './codecs/scale/Self.mjs';\nexport { ScaleEnum, Variant } from './codecs/scale/Variant.mjs';\nexport { ethAccount } from './codecs/scale/ethAccount.mjs';\nexport { Option, Result, Struct, Tuple, Vector } from './codecs/scale/shaped.mjs';\nexport { blockHeader } from './codecs/blockHeader.mjs';\nexport { decAnyMetadata, metadata } from './codecs/metadata/metadata.mjs';\nexport { v14 } from './codecs/metadata/v14.mjs';\nexport { v15 } from './codecs/metadata/v15.mjs';\nexport { lookup as v14Lookup } from './codecs/metadata/lookup.mjs';\nexport { Blake2128, Blake2128Concat, Blake2256 } from './hashes/blake2.mjs';\nexport { Blake3256, Blake3256Concat } from './hashes/blake3.mjs';\nexport { Identity } from './hashes/identity.mjs';\nexport { Twox128, Twox256, Twox64Concat } from './hashes/twoX.mjs';\nexport { h64 } from './hashes/h64.mjs';\nexport { Storage } from './storage.mjs';\nexport { Enum, _Enum } from './types/enum.mjs';\nexport { fromBufferToBase58, getSs58AddressInfo } from './utils/ss58-util.mjs';\nexport { getMultisigAccountId, sortMultisigSignatories } from './utils/multisig.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { Decoder } from \"../types\"\n\n// https://jsben.ch/URe1X\nconst HEX_MAP: Record<string, number> = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n}\nexport function fromHex(hexString: string): Uint8Array {\n  const isOdd = hexString.length % 2\n  /* istanbul ignore next */\n  const base = (hexString[1] === \"x\" ? 2 : 0) + isOdd\n  const nBytes = (hexString.length - base) / 2 + isOdd\n  const bytes = new Uint8Array(nBytes)\n\n  if (isOdd) bytes[0] = 0 | HEX_MAP[hexString[2]]\n\n  for (let i = 0; i < nBytes; ) {\n    const idx = base + i * 2\n    const a = HEX_MAP[hexString[idx]]\n    const b = HEX_MAP[hexString[idx + 1]]\n    bytes[isOdd + i++] = (a << 4) | b\n  }\n\n  return bytes\n}\n\nclass InternalUint8Array extends Uint8Array {\n  i: number = 0\n  v: DataView\n\n  constructor(buffer: ArrayBuffer) {\n    super(buffer)\n    this.v = new DataView(buffer)\n  }\n}\n\nexport const toInternalBytes =\n  <T>(fn: (input: InternalUint8Array) => T): Decoder<T> =>\n  (buffer: string | ArrayBuffer | Uint8Array | InternalUint8Array) =>\n    fn(\n      buffer instanceof InternalUint8Array\n        ? buffer\n        : new InternalUint8Array(\n            buffer instanceof Uint8Array\n              ? buffer.buffer\n              : typeof buffer === \"string\"\n              ? fromHex(buffer).buffer\n              : buffer,\n          ),\n    )\n", "export const mergeUint8 = (inputs: Array<Uint8Array>): Uint8Array => {\n  const len = inputs.length\n  let totalLen = 0\n  for (let i = 0; i < len; i++) totalLen += inputs[i].length\n  const result = new Uint8Array(totalLen)\n\n  for (let idx = 0, at = 0; idx < len; idx++) {\n    const current = inputs[idx]\n    result.set(current, at)\n    at += current.byteLength\n  }\n\n  return result\n}\n", "export function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k: K) => O,\n): Record<K, O>\n\nexport function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k?: K) => O,\n): Record<K, O> {\n  const keys = Object.keys(input) as Array<K>\n  const len = keys.length\n\n  const result: Record<K, O> = {} as any\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    result[key] = mapper(input[key], key)\n  }\n\n  return result\n}\n", "import type { Codec, Decoder, Encoder } from \"./types\"\nimport { toInternalBytes } from \"./internal\"\n\nexport const createDecoder: <T>(fn: (input: Uint8Array) => T) => Decoder<T> =\n  toInternalBytes as any\n\nexport const createCodec = <T>(\n  encoder: Encoder<T>,\n  decoder: Decoder<T>,\n): Codec<T> => {\n  const result = [encoder, decoder] as any\n  result.enc = encoder\n  result.dec = decoder\n  return result\n}\n\nexport const enhanceEncoder =\n  <I, O>(encoder: Encoder<I>, mapper: (value: O) => I): Encoder<O> =>\n  (value) =>\n    encoder(mapper(value))\n\nexport const enhanceDecoder =\n  <I, O>(decoder: Decoder<I>, mapper: (value: I) => O): Decoder<O> =>\n  (value) =>\n    mapper(decoder(value))\n\nexport const enhanceCodec = <I, O>(\n  [encoder, decoder]: Codec<I>,\n  toFrom: (value: O) => I,\n  fromTo: (value: I) => O,\n): Codec<O> =>\n  createCodec(enhanceEncoder(encoder, toFrom), enhanceDecoder(decoder, fromTo))\n", "import { createCodec } from \"../utils\"\nimport { Codec, Decoder, Encoder } from \"../types\"\nimport { toInternalBytes } from \"../internal\"\n\nfunction decodeInt(nBytes: 8, getter: keyof DataView): Decoder<bigint>\nfunction decodeInt(nBytes: number, getter: keyof DataView): Decoder<number>\nfunction decodeInt(\n  nBytes: number,\n  getter: keyof DataView,\n): Decoder<number> | Decoder<bigint> {\n  return toInternalBytes((bytes) => {\n    const result = (bytes.v[getter] as any)(bytes.i, true) as number\n    bytes.i += nBytes\n    return result\n  })\n}\n\nfunction encodeInt(nBytes: 8, setter: keyof DataView): Encoder<bigint>\nfunction encodeInt(nBytes: number, setter: keyof DataView): Encoder<number>\nfunction encodeInt(\n  nBytes: number,\n  setter: keyof DataView,\n): Encoder<number> | Encoder<bigint> {\n  return (input: number | bigint) => {\n    const result = new Uint8Array(nBytes)\n    const dv = new DataView(result.buffer)\n    ;(dv[setter] as any)(0, input, true)\n    return result\n  }\n}\n\nfunction intCodec(\n  nBytes: 8,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<bigint>\nfunction intCodec(\n  nBytes: number,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<number>\nfunction intCodec(\n  nBytes: number,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<bigint> | Codec<number> {\n  return createCodec(encodeInt(nBytes, setter), decodeInt(nBytes, getter))\n}\n\nexport const u8 = intCodec(1, \"getUint8\", \"setUint8\")\nexport const u16 = intCodec(2, \"getUint16\", \"setUint16\")\nexport const u32 = intCodec(4, \"getUint32\", \"setUint32\")\nexport const u64 = intCodec(8, \"getBigUint64\", \"setBigUint64\")\nexport const i8 = intCodec(1, \"getInt8\", \"setInt8\")\nexport const i16 = intCodec(2, \"getInt16\", \"setInt16\")\nexport const i32 = intCodec(4, \"getInt32\", \"setInt32\")\nexport const i64 = intCodec(8, \"getBigInt64\", \"setBigInt64\")\n\nconst x128Enc: Encoder<bigint> = (value) => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n  dv.setBigInt64(0, value, true)\n  dv.setBigInt64(8, value >> 64n, true)\n  return result\n}\n\nconst create128Dec = (\n  method: \"getBigInt64\" | \"getBigUint64\",\n): Decoder<bigint> =>\n  toInternalBytes((input) => {\n    const { v, i } = input\n    const right = v.getBigUint64(i, true)\n    const left = v[method](i + 8, true)\n    input.i += 16\n    return (left << 64n) | right\n  })\n\nexport const u128 = createCodec(x128Enc, create128Dec(\"getBigUint64\"))\nexport const i128 = createCodec(x128Enc, create128Dec(\"getBigInt64\"))\n\nconst x256Enc: Encoder<bigint> = (value) => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n  dv.setBigInt64(0, value, true)\n  dv.setBigInt64(8, value >> 64n, true)\n  dv.setBigInt64(16, value >> 128n, true)\n  dv.setBigInt64(24, value >> 192n, true)\n  return result\n}\n\nconst create256Dec = (\n  method: \"getBigInt64\" | \"getBigUint64\",\n): Decoder<bigint> =>\n  toInternalBytes((input) => {\n    let result = input.v.getBigUint64(input.i, true)\n    input.i += 8\n\n    result |= input.v.getBigUint64(input.i, true) << 64n\n    input.i += 8\n\n    result |= input.v.getBigUint64(input.i, true) << 128n\n    input.i += 8\n\n    result |= input.v[method](input.i, true) << 192n\n    input.i += 8\n\n    return result\n  })\nexport const u256 = createCodec(x256Enc, create256Dec(\"getBigUint64\"))\nexport const i256 = createCodec(x256Enc, create256Dec(\"getBigInt64\"))\n", "import { Codec } from \"../types\"\nimport { enhanceCodec } from \"../\"\nimport { u8 } from \"./fixed-width-ints\"\n\nexport const bool: Codec<boolean> = enhanceCodec(\n  u8,\n  (value: boolean) => (value ? 1 : 0),\n  Boolean,\n)\n", "import { createCodec } from \"../\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { u8, u16, u32, u64 } from \"./fixed-width-ints\"\nimport { Decoder, Encoder, Codec } from \"../types\"\n\nconst decoders = [u8[1], u16[1], u32[1]] as const\nconst compactDec: Decoder<number | bigint> = toInternalBytes<number | bigint>(\n  (bytes) => {\n    const init = bytes[bytes.i]\n\n    const kind = init & 3\n    if (kind < 3) return decoders[kind](bytes) >>> 2\n\n    const nBytes = (init >>> 2) + 4\n    bytes.i++\n\n    let result = 0n\n\n    const nU64 = (nBytes / 8) | 0\n    let shift = 0n\n    for (let i = 0; i < nU64; i++) {\n      result = (u64[1](bytes) << shift) | result\n      shift += 64n\n    }\n\n    let nReminders = nBytes % 8\n    if (nReminders > 3) {\n      result = (BigInt(u32[1](bytes)) << shift) | result\n      shift += 32n\n      nReminders -= 4\n    }\n\n    if (nReminders > 1) {\n      result = (BigInt(u16[1](bytes)) << shift) | result\n      shift += 16n\n      nReminders -= 2\n    }\n\n    if (nReminders) result = (BigInt(u8[1](bytes)) << shift) | result\n\n    return result\n  },\n)\n\nconst MIN_U64 = 1n << 56n\nconst MIN_U32 = 1 << 24\nconst MIN_U16 = 256\nconst U32_MASK = 4294967295n\n\nconst SINGLE_BYTE_MODE_LIMIT = 1 << 6\nconst TWO_BYTE_MODE_LIMIT = 1 << 14\nconst FOUR_BYTE_MODE_LIMIT = 1 << 30\n\nconst compactEnc: Encoder<number | bigint> = (input) => {\n  if (input < 0) throw new Error(`Wrong compact input (${input})`)\n\n  const nInput = Number(input) << 2\n  if (input < SINGLE_BYTE_MODE_LIMIT) return u8[0](nInput)\n  if (input < TWO_BYTE_MODE_LIMIT) return u16[0](nInput | 1)\n  if (input < FOUR_BYTE_MODE_LIMIT) return u32[0](nInput | 2)\n\n  let buffers: Array<Uint8Array> = [new Uint8Array(1)]\n  let bigValue = BigInt(input)\n  while (bigValue >= MIN_U64) {\n    buffers.push(u64[0](bigValue))\n    bigValue >>= 64n\n  }\n\n  if (bigValue >= MIN_U32) {\n    buffers.push(u32[0](Number(bigValue & U32_MASK)))\n    bigValue >>= 32n\n  }\n\n  let smValue = Number(bigValue)\n  if (smValue >= MIN_U16) {\n    buffers.push(u16[0](smValue))\n    smValue >>= 16\n  }\n\n  smValue && buffers.push(u8[0](smValue))\n\n  const result = mergeUint8(buffers)\n  result[0] = ((result.length - 5) << 2) | 3\n\n  return result\n}\n\nexport const compact: Codec<number | bigint> = createCodec(\n  compactEnc,\n  compactDec,\n)\n", "import { createCodec, Decoder, Encoder } from \"../\"\nimport { toInternalBytes, mergeUint8 } from \"../internal\"\nimport { compact } from \"./compact\"\n\nconst textEncoder = new TextEncoder()\nconst strEnc: Encoder<string> = (str) => {\n  const val = textEncoder.encode(str)\n  return mergeUint8([compact.enc(val.length), val])\n}\n\nconst textDecoder = new TextDecoder()\nconst strDec: Decoder<string> = toInternalBytes((bytes) => {\n  let nElements = compact.dec(bytes) as number\n  const dv = new DataView(bytes.buffer, bytes.i, nElements)\n  bytes.i += nElements\n  return textDecoder.decode(dv)\n})\n\nexport const str = createCodec(strEnc, strDec)\n", "import { Codec } from \"../types\"\nimport { createCodec } from \"../\"\n\nconst noop = (() => {}) as () => undefined\nconst emptyArr = new Uint8Array(0)\nexport const _void: Codec<undefined> = createCodec(() => emptyArr, noop)\n", "import { Encoder, Decoder, Codec } from \"../types\"\nimport { createCodec } from \"../\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { compact } from \"./compact\"\n\nconst BytesEnc = (nBytes?: number): Encoder<Uint8Array> =>\n  nBytes === undefined\n    ? (bytes) => mergeUint8([compact.enc(bytes.length), bytes])\n    : (bytes) => (bytes.length === nBytes ? bytes : bytes.slice(0, nBytes))\n\nconst BytesDec = (nBytes?: number): Decoder<Uint8Array> =>\n  toInternalBytes((bytes) => {\n    const len =\n      nBytes === undefined\n        ? (compact.dec(bytes) as number)\n        : nBytes !== Infinity\n        ? nBytes\n        : bytes.byteLength - bytes.i\n\n    const result = new Uint8Array(bytes.buffer.slice(bytes.i, bytes.i + len))\n    bytes.i += len\n    return result\n  })\n\nexport const Bytes = (nBytes?: number): Codec<Uint8Array> =>\n  createCodec(BytesEnc(nBytes), BytesDec(nBytes))\n\nBytes.enc = BytesEnc\nBytes.dec = BytesDec\n", "import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  StringRecord,\n} from \"../types\"\nimport { toInternalBytes, mapObject, mergeUint8 } from \"../internal\"\nimport { createCodec, u8 } from \"../\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> = UnionToIntersection<\n  T extends any ? () => T : never\n> extends () => infer R\n  ? R\n  : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\nconst enumEnc = <O extends StringRecord<Encoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O>,\n): Encoder<\n  {\n    [K in keyof O]: { tag: K; value: EncoderType<O[K]> }\n  }[keyof O]\n> => {\n  const keys = Object.keys(inner)\n  const mappedKeys = new Map<keyof O, number>(\n    x?.map((actualIdx, idx) => [keys[idx], actualIdx]) ??\n      keys.map((key, idx) => [key, idx]),\n  )\n  const getKey = (key: keyof O) => mappedKeys.get(key)!\n\n  return ({ tag, value }) =>\n    mergeUint8([u8.enc(getKey(tag)), (inner as any)[tag](value)])\n}\n\nconst enumDec = <O extends StringRecord<Decoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O>,\n): Decoder<\n  {\n    [K in keyof O]: { tag: K; value: DecoderType<O[K]> }\n  }[keyof O]\n> => {\n  const keys = Object.keys(inner)\n  const mappedKeys = new Map<number, string>(\n    x?.map((actualIdx, idx) => [actualIdx, keys[idx]]) ??\n      keys.map((key, idx) => [idx, key]),\n  )\n\n  return toInternalBytes((bytes) => {\n    const idx = u8.dec(bytes)\n    const tag = mappedKeys.get(idx)!\n    const innerDecoder = inner[tag]\n    return {\n      tag,\n      value: innerDecoder(bytes),\n    }\n  })\n}\n\nexport const Enum = <O extends StringRecord<Codec<any>>>(\n  inner: O,\n  ...args: [indexes?: RestrictedLenTuple<number, O>]\n): Codec<\n  {\n    [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n  }[keyof O]\n> =>\n  createCodec(\n    enumEnc(\n      mapObject(inner, ([encoder]) => encoder) as StringRecord<\n        O[keyof O][\"enc\"]\n      >,\n      ...(args as any[]),\n    ) as Encoder<\n      {\n        [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n      }[keyof O]\n    >,\n    enumDec(\n      mapObject(inner, ([, decoder]) => decoder) as StringRecord<\n        O[keyof O][\"dec\"]\n      >,\n      ...(args as any[]),\n    ) as Decoder<\n      {\n        [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n      }[keyof O]\n    >,\n  )\n\nEnum.enc = enumEnc\nEnum.dec = enumDec\n", "import { Decoder, Encoder, Codec } from \"../types\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { createCodec } from \"../utils\"\nimport { u8 } from \"./fixed-width-ints\"\n\nconst OptionDec = <T>(inner: Decoder<T>): Decoder<T | undefined> =>\n  toInternalBytes<T | undefined>((bytes) =>\n    u8[1](bytes) > 0 ? inner(bytes) : undefined,\n  )\n\nconst OptionEnc =\n  <T>(inner: Encoder<T>): Encoder<T | undefined> =>\n  (value) => {\n    const result = new Uint8Array(1)\n    if (value === undefined) return result\n    result[0] = 1\n    return mergeUint8([result, inner(value)])\n  }\n\nexport const Option = <T>(inner: Codec<T>): Codec<T | undefined> =>\n  createCodec(OptionEnc(inner[0]), OptionDec(inner[1]))\n\nOption.enc = OptionEnc\nOption.dec = OptionDec\n", "import { createCodec } from \"../utils\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { Decoder, Encoder, Codec } from \"../types\"\nimport { u8 } from \"./fixed-width-ints\"\n\nexport type ResultPayload<OK, KO> =\n  | { success: true; value: OK }\n  | { success: false; value: KO }\n\nconst ResultDec = <OK, KO>(\n  okDecoder: Decoder<OK>,\n  koDecoder: Decoder<KO>,\n): Decoder<ResultPayload<OK, KO>> =>\n  toInternalBytes((bytes) => {\n    const success = u8[1](bytes) === 0\n    const decoder = success ? okDecoder : koDecoder\n    const value = decoder(bytes)\n    return { success, value } as ResultPayload<OK, KO>\n  })\n\nconst ResultEnc =\n  <OK, KO>(\n    okEncoder: Encoder<OK>,\n    koEncoder: Encoder<KO>,\n  ): Encoder<ResultPayload<OK, KO>> =>\n  ({ success, value }) =>\n    mergeUint8([\n      u8[0](success ? 0 : 1),\n      (success ? okEncoder : koEncoder)(value as any),\n    ])\n\nexport const Result = <OK, KO>(\n  okCodec: Codec<OK>,\n  koCodec: Codec<KO>,\n): Codec<ResultPayload<OK, KO>> =>\n  createCodec(\n    ResultEnc(okCodec[0], koCodec[0]),\n    ResultDec(okCodec[1], koCodec[1]),\n  )\n\nResult.dec = ResultDec\nResult.enc = ResultEnc\n", "import { Codec, Decoder, Encoder } from \"../types\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { createCodec } from \"../utils\"\n\nconst TupleDec = <A extends Array<Decoder<any>>>(\n  ...decoders: A\n): Decoder<{ [K in keyof A]: A[K] extends Decoder<infer D> ? D : unknown }> =>\n  toInternalBytes((bytes) => decoders.map((decoder) => decoder(bytes)) as any)\n\nconst TupleEnc =\n  <A extends Array<Encoder<any>>>(\n    ...encoders: A\n  ): Encoder<{ [K in keyof A]: A[K] extends Encoder<infer D> ? D : unknown }> =>\n  (values) =>\n    mergeUint8(encoders.map((enc, idx) => enc(values[idx])))\n\nexport const Tuple = <A extends Array<Codec<any>>>(\n  ...codecs: A\n): Codec<{ [K in keyof A]: A[K] extends Codec<infer D> ? D : unknown }> =>\n  createCodec(\n    TupleEnc(...codecs.map(([encoder]) => encoder)),\n    TupleDec(...codecs.map(([, decoder]) => decoder)),\n  ) as any\n\nTuple.enc = TupleEnc\nTuple.dec = TupleDec\n", "import { mapObject } from \"../internal\"\nimport {\n  Codec,\n  EncoderType,\n  DecoderType,\n  CodecType,\n  Decoder,\n  Encoder,\n  StringRecord,\n} from \"../types\"\nimport { createCodec, enhanceDecoder, enhanceEncoder } from \"../utils\"\nimport { Tuple } from \"./Tuple\"\n\nconst StructEnc = <A extends StringRecord<Encoder<any>>>(\n  encoders: A,\n): Encoder<{ [K in keyof A]: EncoderType<A[K]> }> => {\n  const keys = Object.keys(encoders)\n  return enhanceEncoder(\n    Tuple.enc(...Object.values(encoders)),\n    (input: { [K in keyof A]: EncoderType<A[K]> }) => keys.map((k) => input[k]),\n  )\n}\n\nconst StructDec = <A extends StringRecord<Decoder<any>>>(\n  decoders: A,\n): Decoder<{ [K in keyof A]: DecoderType<A[K]> }> => {\n  const keys = Object.keys(decoders)\n  return enhanceDecoder(\n    Tuple.dec(...Object.values(decoders)),\n    (tuple: Array<any>) =>\n      Object.fromEntries(tuple.map((value, idx) => [keys[idx], value])) as any,\n  )\n}\n\nexport const Struct = <A extends StringRecord<Codec<any>>>(\n  codecs: A,\n): Codec<{ [K in keyof A]: CodecType<A[K]> }> =>\n  createCodec(\n    StructEnc(\n      mapObject(codecs, (x) => x[0]) as StringRecord<A[keyof A][0]>,\n    ) as any,\n    StructDec(\n      mapObject(codecs, (x) => x[1]) as StringRecord<A[keyof A][1]>,\n    ) as any,\n  )\n\nStruct.enc = StructEnc\nStruct.dec = StructDec\n", "import { toInternalBytes, mergeUint8 } from \"../internal\"\nimport { createCodec } from \"../utils\"\nimport { Codec, Decoder, Encoder } from \"../types\"\nimport { compact } from \"./compact\"\n\nconst VectorEnc = <T>(inner: Encoder<T>, size?: number): Encoder<Array<T>> =>\n  size! >= 0\n    ? (value) => mergeUint8(value.map(inner))\n    : (value) =>\n        mergeUint8([compact.enc(value.length), mergeUint8(value.map(inner))])\n\nconst VectorDec = <T>(getter: Decoder<T>, size?: number): Decoder<Array<T>> =>\n  toInternalBytes((bytes) => {\n    const nElements = size! >= 0 ? size! : compact.dec(bytes)\n    const result = new Array(nElements as number)\n\n    for (let i = 0; i < nElements; i++) {\n      result[i] = getter(bytes)\n    }\n\n    return result\n  })\n\nexport const Vector = <T>(inner: Codec<T>, size?: number): Codec<Array<T>> =>\n  createCodec(VectorEnc(inner[0], size), VectorDec(inner[1], size))\n\nVector.enc = VectorEnc\nVector.dec = VectorDec\n", "import { base58 } from \"@scure/base\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\n\nconst SS58_PREFIX = new TextEncoder().encode(\"SS58PRE\")\nconst CHECKSUM_LENGTH = 2\n\nexport type SS58String = string & { __SS58String?: unknown }\nexport type SS58AddressInfo =\n  | { isValid: false }\n  | { isValid: true; ss58Format: number; publicKey: Uint8Array }\n\nexport const getSs58AddressInfo = (address: SS58String): SS58AddressInfo => {\n  try {\n    const decoded = base58.decode(address)\n    const prefixBytes = decoded.subarray(0, decoded[0] & 0b0100_0000 ? 2 : 1)\n    const publicKey = decoded.subarray(\n      prefixBytes.length,\n      decoded.length - CHECKSUM_LENGTH,\n    )\n\n    const checksum = decoded.subarray(prefixBytes.length + publicKey.length)\n    const expectedChecksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n\n    const isChecksumValid =\n      checksum[0] === expectedChecksum[0] && checksum[1] === expectedChecksum[1]\n\n    if (!isChecksumValid) return { isValid: false }\n\n    return {\n      isValid: true,\n      ss58Format: prefixBytesToNumber(prefixBytes),\n      publicKey: publicKey.slice(),\n    }\n  } catch (_) {\n    return { isValid: false }\n  }\n}\n\nconst prefixBytesToNumber = (bytes: Uint8Array) => {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0)\n}\n\nexport const fromBufferToBase58 = (ss58Format: number) => {\n  const prefixBytes =\n    ss58Format < 64\n      ? Uint8Array.of(ss58Format)\n      : Uint8Array.of(\n          ((ss58Format & 0b0000_0000_1111_1100) >> 2) | 0b0100_0000,\n          (ss58Format >> 8) | ((ss58Format & 0b0000_0000_0000_0011) << 6),\n        )\n\n  return (publicKey: Uint8Array): SS58String => {\n    const checksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n    return base58.encode(\n      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum),\n    )\n  }\n}\n", "import { Bytes, enhanceCodec } from \"scale-ts\"\nimport {\n  getSs58AddressInfo,\n  SS58String,\n  fromBufferToBase58,\n} from \"@/utils/ss58-util\"\n\nfunction fromBase58ToBuffer(nBytes: number, _ss58Format: number) {\n  return (address: SS58String) => {\n    const info = getSs58AddressInfo(address)\n    if (!info.isValid) throw new Error(\"Invalid checksum\")\n    const { publicKey } = info\n    if (publicKey.length !== nBytes)\n      throw new Error(\"Invalid public key length\")\n\n    return publicKey\n  }\n}\n\nexport const AccountId = (ss58Format: number = 42, nBytes: 32 | 33 = 32) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    fromBase58ToBuffer(nBytes, ss58Format),\n    fromBufferToBase58(ss58Format),\n  )\n", "// https://jsben.ch/uWZw3\nconst HEX_STR = \"0123456789abcdef\"\nexport function toHex(bytes: Uint8Array): string {\n  const result = new Array<string>(bytes.length + 1)\n\n  result[0] = \"0x\"\n\n  for (let i = 0; i < bytes.length; ) {\n    const b = bytes[i++]\n    result[i] = HEX_STR[b >> 4] + HEX_STR[b & 15]\n  }\n\n  return result.join(\"\")\n}\n\n// https://jsben.ch/URe1X\nconst HEX_MAP: Record<string, number> = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n}\nexport function fromHex(hexString: string): Uint8Array {\n  const isOdd = hexString.length % 2\n  const base = (hexString[1] === \"x\" ? 2 : 0) + isOdd\n  const nBytes = (hexString.length - base) / 2 + isOdd\n  const bytes = new Uint8Array(nBytes)\n\n  if (isOdd) bytes[0] = 0 | HEX_MAP[hexString[2]]\n\n  for (let i = 0; i < nBytes; ) {\n    const idx = base + i * 2\n    const a = HEX_MAP[hexString[idx]]\n    const b = HEX_MAP[hexString[idx + 1]]\n    bytes[isOdd + i++] = (a << 4) | b\n  }\n\n  return bytes\n}\n", "export function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k: K) => O,\n): Record<K, O>\n\nexport function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k?: K) => O,\n): Record<K, O> {\n  return Object.fromEntries(\n    Object.entries(input).map(\n      ([key, value]: any) => [key, mapper(value, key)] as const,\n    ),\n  ) as any\n}\n\nexport type StringRecord<T> = {\n  [Sym: symbol]: never\n  [Num: number]: never\n  [Str: string]: T\n}\n\nexport const mapStringRecord = <I, O>(\n  input: StringRecord<I>,\n  mapper: (value: I, key: string) => O,\n): StringRecord<O> =>\n  Object.fromEntries(\n    Object.entries(input).map(([key, value]) => [key, mapper(value, key)]),\n  ) as StringRecord<O>\n", "export const mergeUint8 = (...inputs: Array<Uint8Array>): Uint8Array => {\n  const totalLen = inputs.reduce((acc, a) => acc + a.byteLength, 0)\n  const result = new Uint8Array(totalLen)\n\n  for (let idx = 0, at = 0; idx < inputs.length; idx++) {\n    const current = inputs[idx]\n    result.set(current, at)\n    at += current.byteLength\n  }\n\n  return result\n}\n", "export const noop: () => void = Function.prototype as any\n", "export class AbortError extends Error {\n  constructor() {\n    super(\"Abort Error\")\n    this.name = \"AbortError\"\n  }\n}\n", "import {\n  Bytes,\n  Codec,\n  Decoder,\n  Encoder,\n  Tuple,\n  compact,\n  createCodec,\n} from \"scale-ts\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport type { HexString } from \"./Hex\"\nimport { SS58String } from \"@/utils\"\nimport { AccountId } from \"./AccountId\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\nconst opaqueBytesDec = Tuple(compact, Bytes(Infinity))[1]\n\nexport class Binary {\n  #bytes: Uint8Array\n  #opaqueBytes: Uint8Array | null = null\n  #hex: HexString | null = null\n  #opaqueHex: HexString | null = null\n  #str: string | null = null\n\n  constructor(data: Uint8Array, opaque = false) {\n    if (opaque) {\n      try {\n        const [len, bytes] = opaqueBytesDec(data)\n        if (len === bytes.length) {\n          this.#bytes = bytes\n          this.#opaqueBytes = data\n          return\n        }\n      } catch (_) {}\n      throw new Error(\"Invalid opaque bytes\")\n    } else this.#bytes = data\n  }\n\n  asText = () => (this.#str ??= textDecoder.decode(this.#bytes))\n\n  asHex = () => (this.#hex ||= toHex(this.#bytes))\n  asOpaqueHex = () => (this.#opaqueHex ||= toHex(this.asBytes()))\n\n  asBytes = () => this.#bytes\n  asOpaqueBytes = () =>\n    (this.#opaqueBytes ||= mergeUint8(\n      compact[0](this.#bytes.length),\n      this.#bytes,\n    ))\n\n  static fromText(input: string): Binary {\n    return new this(textEncoder.encode(input))\n  }\n\n  static fromHex(input: HexString): Binary {\n    return new this(fromHex(input))\n  }\n  static fromOpaqueHex(input: HexString): Binary {\n    return new this(fromHex(input), true)\n  }\n\n  static fromBytes(input: Uint8Array): Binary {\n    return new this(input)\n  }\n  static fromOpaqueBytes(input: Uint8Array): Binary {\n    return new this(input, true)\n  }\n}\n\nconst [accountIdEncoder] = AccountId()\nexport class FixedSizeBinary<_L extends number> extends Binary {\n  constructor(data: Uint8Array) {\n    super(data)\n  }\n\n  static fromArray<L extends number, I extends Array<number> & { length: L }>(\n    input: I,\n  ) {\n    return new this<L>(new Uint8Array(input))\n  }\n\n  static fromAccountId32<L extends number>(\n    input: L extends 32 ? SS58String : never,\n  ) {\n    return new this<L>(accountIdEncoder(input))\n  }\n}\n\nconst enc = (nBytes?: number): Encoder<Binary> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value) => _enc(value.asBytes())\n}\n\nconst dec = (nBytes?: number): Decoder<Binary> => {\n  const _dec = Bytes.dec(nBytes)\n  const Bin = nBytes == null ? Binary : FixedSizeBinary\n  return (value) => Bin.fromBytes(_dec(value))\n}\n\nexport const Bin = (nBytes?: number): Codec<Binary> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nBin.enc = enc\nBin.dec = dec\n", "import { compact, enhanceCodec } from \"scale-ts\"\n\nexport const compactNumber = enhanceCodec(compact, (v) => v, Number)\nexport const compactBn = enhanceCodec(compact, (v) => v, BigInt)\n", "import { Bytes, Decoder, Encoder, createCodec, createDecoder } from \"scale-ts\"\nimport { compactNumber } from \"./compact\"\n\nexport interface BitSequence {\n  bitsLen: number\n  bytes: Uint8Array\n}\n\nconst bitSequenceDecoder: Decoder<BitSequence> = createDecoder((data) => {\n  const bitsLen = compactNumber.dec(data)\n\n  const bytesLen = Math.ceil(bitsLen / 8)\n  const bytes = Bytes(bytesLen).dec(data)\n  return { bytes, bitsLen }\n})\n\nconst bitSequenceEncoder: Encoder<BitSequence> = (input) => {\n  if (input.bitsLen > input.bytes.length * 8)\n    throw new Error(\n      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`,\n    )\n\n  const lenEncoded = compactNumber.enc(input.bitsLen)\n  const result = new Uint8Array(input.bytes.length + lenEncoded.length)\n  result.set(lenEncoded, 0)\n  result.set(input.bytes, lenEncoded.length)\n  return result\n}\n\nexport const bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder)\n", "import { enhanceCodec, u8 } from \"scale-ts\"\n\nexport const char = enhanceCodec(\n  u8,\n  (str: string) => str.charCodeAt(0),\n  String.fromCharCode,\n)\n", "import { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { Bytes, Codec, Decoder, Encoder, createCodec } from \"scale-ts\"\n\nexport type HexString = string & { __hexString?: unknown }\n\nconst enc = (nBytes?: number): Encoder<HexString> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value: string) => _enc(fromHex(value))\n}\n\nconst dec = (nBytes?: number): Decoder<HexString> => {\n  const _dec = Bytes.dec(nBytes)\n  return (value) => toHex(_dec(value)) as HexString\n}\n\nexport const Hex = (nBytes?: number): Codec<HexString> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nHex.enc = enc\nHex.dec = dec\n", "import { Bytes, enhanceCodec } from \"scale-ts\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const fixedStr = (nBytes: number) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    (str: string) => textEncoder.encode(str),\n    (bytes) => textDecoder.decode(bytes),\n  )\n", "import { Codec, Decoder, Encoder, createCodec, _void } from \"scale-ts\"\n\nexport const selfEncoder = <T>(value: () => Encoder<T>): Encoder<T> => {\n  let cache: Encoder<T> = (x) => {\n    const encoder = value()\n    cache = encoder\n    return encoder(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const selfDecoder = <T>(value: () => Decoder<T>): Decoder<T> => {\n  let cache: Decoder<T> = (x) => {\n    const decoder = value()\n    const result = decoder\n    cache = decoder\n    return result(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const Self = <T>(value: () => Codec<T>): Codec<T> =>\n  createCodec(\n    selfEncoder(() => value().enc),\n    selfDecoder(() => value().dec),\n  )\n", "export type Enum<T extends {}> = {\n  [K in keyof T & string]: {\n    type: K\n    value: T[K]\n  }\n}[keyof T & string]\n\nexport type EnumVariant<\n  T extends { type: string; value?: any },\n  K extends T[\"type\"],\n> = T & {\n  type: K\n}\n\nexport type ExtractEnumValue<\n  T extends { type: string; value?: any },\n  K extends string,\n> = EnumVariant<T, K>[\"value\"]\n\ntype ValueArg<V> = undefined extends V ? [value?: V] : [value: V]\n\ninterface Discriminant {\n  is<T extends { type: string; value: any }, K extends T[\"type\"]>(\n    value: T,\n    type: K,\n  ): value is T & { type: K }\n  as<T extends { type: string; value: any }, K extends T[\"type\"]>(\n    value: T,\n    type: K,\n  ): ExtractEnumValue<T, K>\n}\nconst discriminant: Discriminant = {\n  is<T extends { type: string; value: any }, K extends T[\"type\"]>(\n    value: T,\n    type: K,\n  ): value is T & { type: K } {\n    return value.type === type\n  },\n  as(value, type) {\n    if (type !== value.type)\n      throw new Error(\n        `Enum.as(enum, ${type}) used with actual type ${value.type}`,\n      )\n    return value\n  },\n}\ninterface EnumFn extends Discriminant {\n  <T extends { type: string; value: any }, K extends T[\"type\"]>(\n    type: K,\n    ...[value]: ValueArg<ExtractEnumValue<T, K>>\n  ): EnumVariant<T, K>\n}\nexport const Enum: EnumFn = Object.assign((type: string, value?: any) => {\n  return {\n    type,\n    value,\n  } as any\n}, discriminant)\n\n// well-known enums\nexport type GetEnum<T extends Enum<any>> = {\n  [K in T[\"type\"]]: (\n    ...args: ExtractEnumValue<T, K> extends undefined\n      ? []\n      : [value: ExtractEnumValue<T, K>]\n  ) => EnumVariant<T, K>\n}\nexport const _Enum = new Proxy(\n  {},\n  {\n    get(_, prop: string) {\n      return (value: string) => Enum(prop, value)\n    },\n  },\n)\n\n// type Bar = Enum<{\n//   Kaka: 1\n//   Bar: 2\n// }>\n\n// type FooInput = Enum<{\n//   foo: \"foo\" | undefined\n//   bar: Bar\n//   baz: number\n//   wtf: boolean\n// }>\n\n// declare function foo(foo: FooInput): void\n// foo(Enum(\"bar\", Enum(\"Bar\", 2)))\n\n// const InputEnum: GetEnum<FooInput> = null as any;\n// InputEnum.bar(Enum('Bar', 2))\n", "export const withInner = <T, I>(codec: T, inner: I): T & { inner: I } => {\n  const result: T & { inner: I } = codec as any\n  result.inner = inner\n  return result\n}\n", "import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  Enum as OEnum,\n  StringRecord,\n  createCodec,\n} from \"scale-ts\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport { Enum } from \"@/types/enum\"\nimport { withInner } from \"./with-inner\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> =\n  UnionToIntersection<T extends any ? () => T : never> extends () => infer R\n    ? R\n    : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\nconst VariantEnc: <O extends StringRecord<Encoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O> | undefined,\n) => Encoder<\n  Enum<{\n    [K in keyof O]: EncoderType<O[K]>\n  }>\n> & { inner: O } = (...args) => {\n  const enc = OEnum.enc(...(args as [any, any]))\n  return withInner((v: any) => enc({ tag: v.type, value: v.value }), args[0])\n}\n\nconst VariantDec: <O extends StringRecord<Decoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O> | undefined,\n) => Decoder<\n  Enum<{\n    [K in keyof O]: DecoderType<O[K]>\n  }>\n> & { inner: O } = (...args) => {\n  const dec = OEnum.dec(...(args as [any]))\n  return withInner((v: any) => {\n    const { tag, value } = dec(v)\n    return Enum(tag as any, value as any) as any\n  }, args[0])\n}\n\nexport const Variant: {\n  <O extends StringRecord<Codec<any>>>(\n    inner: O,\n    indexes?: RestrictedLenTuple<number, O> | undefined,\n  ): Codec<\n    Enum<{\n      [K in keyof O]: CodecType<O[K]>\n    }>\n  > & { inner: O }\n  enc: <O_1 extends StringRecord<Encoder<any>>>(\n    inner: O_1,\n    x?: RestrictedLenTuple<number, O_1> | undefined,\n  ) => Encoder<\n    Enum<{\n      [K in keyof O_1]: EncoderType<O_1[K]>\n    }>\n  > & { inner: O_1 }\n  dec: <O_2 extends StringRecord<Decoder<any>>>(\n    inner: O_2,\n    x?: RestrictedLenTuple<number, O_2> | undefined,\n  ) => Decoder<\n    Enum<{\n      [K in keyof O_2]: DecoderType<O_2[K]>\n    }>\n  > & { inner: O_2 }\n} = (inner, ...args) =>\n  withInner(\n    createCodec(\n      VariantEnc(\n        mapObject(inner, ([encoder]) => encoder) as any,\n        ...(args as any[]),\n      ),\n      VariantDec(\n        mapObject(inner, ([, decoder]) => decoder) as any,\n        ...(args as any[]),\n      ) as any,\n    ),\n    inner,\n  ) as any\nVariant.enc = VariantEnc\nVariant.dec = VariantDec\n\nexport const ScaleEnum: {\n  <O extends StringRecord<Codec<any>>>(\n    inner: O,\n    indexes?: RestrictedLenTuple<number, O> | undefined,\n  ): Codec<\n    {\n      [K in keyof O]: {\n        tag: K\n        value: CodecType<O[K]>\n      }\n    }[keyof O]\n  > & { inner: O }\n  enc: <O_1 extends StringRecord<Encoder<any>>>(\n    inner: O_1,\n    x?: RestrictedLenTuple<number, O_1> | undefined,\n  ) => Encoder<\n    {\n      [K_1 in keyof O_1]: {\n        tag: K_1\n        value: EncoderType<O_1[K_1]>\n      }\n    }[keyof O_1]\n  > & { inner: O_1 }\n  dec: <O_2 extends StringRecord<Decoder<any>>>(\n    inner: O_2,\n    x?: RestrictedLenTuple<number, O_2> | undefined,\n  ) => Decoder<\n    {\n      [K_2 in keyof O_2]: {\n        tag: K_2\n        value: DecoderType<O_2[K_2]>\n      }\n    }[keyof O_2]\n  > & { inner: O_2 }\n} = (inner, ...args) => withInner(OEnum(inner, ...(args as any[])), inner)\nScaleEnum.enc = (inner, ...rest) =>\n  withInner(OEnum.enc(inner, ...(rest as any[])), inner)\nScaleEnum.dec = (inner, ...rest) =>\n  withInner(OEnum.dec(inner, ...(rest as any[])), inner)\n", "import { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { Bytes, createCodec, createDecoder } from \"scale-ts\"\nimport { keccak_256 as keccak } from \"@noble/hashes/sha3\"\n\nconst getFormattedAddress = (hexAddress: string) => {\n  const nonChecksum = hexAddress.slice(2)\n  const hashedAddress = toHex(keccak(nonChecksum)).slice(2)\n\n  const result = new Array(40)\n\n  for (let i = 0; i < 40; i++) {\n    const checksumVal = parseInt(hashedAddress[i], 16)\n    const char = nonChecksum[i]\n    result[i] = checksumVal > 7 ? char.toUpperCase() : char\n  }\n\n  return `0x${result.join(\"\")}`\n}\n\nconst bytes20Dec = Bytes(20)[1]\n\nexport const ethAccount = createCodec<string>(\n  (input: string) => {\n    const bytes = fromHex(input)\n    if (bytes.length !== 20)\n      throw new Error(`Invalid length found on EthAddress(${input})`)\n\n    const hexAddress = toHex(bytes)\n    if (input === hexAddress || input === hexAddress.toUpperCase()) return bytes\n\n    if (getFormattedAddress(hexAddress) !== input)\n      throw new Error(`Invalid checksum found on EthAddress(${input})`)\n\n    return bytes\n  },\n  createDecoder((bytes) => getFormattedAddress(toHex(bytes20Dec(bytes)))),\n)\n", "import {\n  Struct as OStruct,\n  Tuple as OTuple,\n  Vector as OVector,\n  Result as OResult,\n  Option as OOption,\n  Codec,\n  Encoder,\n  Decoder,\n  StringRecord,\n  CodecType,\n  EncoderType,\n  DecoderType,\n  ResultPayload,\n} from \"scale-ts\"\nimport { withInner } from \"./with-inner\"\n\nexport const Struct: {\n  <A extends StringRecord<Codec<any>>>(\n    codecs: A,\n  ): Codec<{ [K in keyof A]: CodecType<A[K]> }> & { inner: A }\n  enc: <A_1 extends StringRecord<Encoder<any>>>(\n    encoders: A_1,\n  ) => Encoder<{ [K_1 in keyof A_1]: EncoderType<A_1[K_1]> }> & { inner: A_1 }\n  dec: <A_2 extends StringRecord<Decoder<any>>>(\n    decoders: A_2,\n  ) => Decoder<{ [K_2 in keyof A_2]: DecoderType<A_2[K_2]> }> & { inner: A_2 }\n} = (codecs) => withInner(OStruct(codecs), codecs)\nStruct.enc = (x) => withInner(OStruct.enc(x), x)\nStruct.dec = (x) => withInner(OStruct.dec(x), x)\n\nexport const Tuple: {\n  <A extends Codec<any>[]>(\n    ...inner: A\n  ): Codec<{ [K in keyof A]: A[K] extends Codec<infer D> ? D : unknown }> & {\n    inner: A\n  }\n  enc: <A_1 extends Encoder<any>[]>(\n    ...encoders: A_1\n  ) => Encoder<{\n    [K_1 in keyof A_1]: A_1[K_1] extends Encoder<infer D_1> ? D_1 : unknown\n  }> & { inner: A_1 }\n  dec: <A_2 extends Decoder<any>[]>(\n    ...decoders: A_2\n  ) => Decoder<{\n    [K_2 in keyof A_2]: A_2[K_2] extends Decoder<infer D_2> ? D_2 : unknown\n  }> & { inner: A_2 }\n} = (...inner) => withInner(OTuple(...inner), inner)\nTuple.enc = (...inner) => withInner(OTuple.enc(...inner), inner)\nTuple.dec = (...inner) => withInner(OTuple.dec(...inner), inner)\n\nexport const Vector: {\n  <T>(\n    inner: Codec<T>,\n    size?: number | undefined,\n  ): Codec<T[]> & { inner: Codec<T> }\n  enc: <T_1>(\n    inner: Encoder<T_1>,\n    size?: number | undefined,\n  ) => Encoder<T_1[]> & { inner: Encoder<T_1> }\n  dec: <T_2>(\n    getter: Decoder<T_2>,\n    size?: number | undefined,\n  ) => Decoder<T_2[]> & { inner: Decoder<T_2> }\n} = (inner, ...rest) => withInner(OVector(inner, ...rest), inner)\nVector.enc = (inner, ...rest) => withInner(OVector.enc(inner, ...rest), inner)\nVector.dec = (inner, ...rest) => withInner(OVector.dec(inner, ...rest), inner)\n\nexport const Result: {\n  <OK, KO>(\n    okCodec: Codec<OK>,\n    koCodec: Codec<KO>,\n  ): Codec<ResultPayload<OK, KO>> & { inner: { ok: Codec<OK>; ko: Codec<KO> } }\n  dec: <OK_1, KO_1>(\n    okDecoder: Decoder<OK_1>,\n    koDecoder: Decoder<KO_1>,\n  ) => Decoder<ResultPayload<OK_1, KO_1>> & {\n    inner: { ok: Decoder<OK_1>; ko: Decoder<KO_1> }\n  }\n  enc: <OK_2, KO_2>(\n    okEncoder: Encoder<OK_2>,\n    koEncoder: Encoder<KO_2>,\n  ) => Encoder<ResultPayload<OK_2, KO_2>> & {\n    inner: { ok: Encoder<OK_2>; ko: Encoder<KO_2> }\n  }\n} = (ok, ko) => withInner(OResult(ok, ko), { ok, ko })\nResult.enc = (ok, ko) => withInner(OResult.enc(ok, ko), { ok, ko })\nResult.dec = (ok, ko) => withInner(OResult.dec(ok, ko), { ok, ko })\n\nexport const Option: {\n  <T>(inner: Codec<T>): Codec<T | undefined> & { inner: Codec<T> }\n  enc: <T_1>(\n    inner: Encoder<T_1>,\n  ) => Encoder<T_1 | undefined> & { inner: Encoder<T_1> }\n  dec: <T_2>(\n    inner: Decoder<T_2>,\n  ) => Decoder<T_2 | undefined> & { inner: Decoder<T_2> }\n} = (inner) => withInner(OOption(inner), inner)\nOption.enc = (inner) => withInner(OOption.enc(inner), inner)\nOption.dec = (inner) => withInner(OOption.dec(inner), inner)\n", "import {\n  Bytes,\n  CodecType,\n  Struct,\n  Vector,\n  _void,\n  enhanceCodec,\n  Hex,\n  Variant,\n  compactNumber,\n} from \"./scale\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst fourChars = enhanceCodec(\n  Bytes(4),\n  textEncoder.encode.bind(textEncoder),\n  textDecoder.decode.bind(textDecoder),\n)\n\nconst diggestVal = Struct({\n  engine: fourChars,\n  payload: Hex(),\n})\n\nconst diggest = Variant(\n  {\n    consensus: diggestVal,\n    seal: diggestVal,\n    preRuntime: diggestVal,\n    runtimeUpdated: _void,\n  },\n  [4, 5, 6, 8],\n)\n\nconst hex32 = Hex(32)\nexport const blockHeader = Struct({\n  parentHash: hex32,\n  number: compactNumber,\n  stateRoot: hex32,\n  extrinsicRoot: hex32,\n  digests: Vector(diggest),\n})\n\nexport type BlockHeader = CodecType<typeof blockHeader>\n", "import { Vector, str } from \"scale-ts\"\n\nexport const docs = Vector(str)\n", "import { compactNumber } from \"../scale/compact\"\nimport {\n  CodecType,\n  Enum,\n  Option,\n  Struct,\n  Vector,\n  _void,\n  str,\n  u32,\n  u8,\n} from \"scale-ts\"\nimport { docs } from \"./docs\"\n\nconst oStr = Option(str)\n\nconst primitive = Enum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\n\nconst fields = Vector(\n  Struct({\n    name: oStr,\n    type: compactNumber,\n    typeName: oStr,\n    docs,\n  }),\n)\n\nconst arr = Struct({\n  len: u32,\n  type: compactNumber,\n})\n\nconst bitSequence = Struct({\n  bitStoreType: compactNumber,\n  bitOrderType: compactNumber,\n})\n\nconst variant = Vector(\n  Struct({\n    name: str,\n    fields,\n    index: u8,\n    docs,\n  }),\n)\n\nconst def = Enum({\n  composite: fields,\n  variant,\n  sequence: compactNumber,\n  array: arr,\n  tuple: Vector(compactNumber),\n  primitive,\n  compact: compactNumber,\n  bitSequence,\n})\n\nconst param = Struct({\n  name: str,\n  type: Option(compactNumber),\n})\nconst params = Vector(param)\n\nconst entry = Struct({\n  id: compactNumber,\n  path: docs,\n  params,\n  def,\n  docs,\n})\n\nexport const lookup = Vector(entry)\nexport type V14Lookup = CodecType<typeof lookup>\n", "import { Hex, compactNumber } from \"@/codecs/scale\"\nimport { Struct, Option, Vector, u8, str, Enum, _void } from \"scale-ts\"\nimport { docs } from \"./docs\"\n\nconst hashType = Enum({\n  Blake2128: _void,\n  Blake2256: _void,\n  Blake2128Concat: _void,\n  Twox128: _void,\n  Twox256: _void,\n  Twox64Concat: _void,\n  Identity: _void,\n})\n\nconst hashers = Vector(hashType)\n\nconst storageMap = Struct({\n  hashers,\n  key: compactNumber,\n  value: compactNumber,\n})\n\nconst storageItem = Struct({\n  name: str,\n  modifier: u8,\n  type: Enum({\n    plain: compactNumber,\n    map: storageMap,\n  }),\n  fallback: Hex(),\n  docs,\n})\n\nconst storage = Option(\n  Struct({\n    prefix: str,\n    items: Vector(storageItem),\n  }),\n)\n\nexport const v14Pallet = {\n  name: str,\n  storage,\n  calls: Option(compactNumber),\n  events: Option(compactNumber),\n  constants: Vector(\n    Struct({\n      name: str,\n      type: compactNumber,\n      value: Hex(),\n      docs,\n    }),\n  ),\n  errors: Option(compactNumber),\n  index: u8,\n}\n\nexport const v15Pallet = {\n  ...v14Pallet,\n  docs,\n}\n", "import { CodecType, Struct, Vector, createCodec, str, u8 } from \"scale-ts\"\nimport { lookup } from \"./lookup\"\nimport { compactNumber } from \"../scale\"\nimport { v14Pallet } from \"./pallets\"\nimport { runtimeApi } from \"./runtime-api\"\n\nconst empty = new Uint8Array()\nconst Always = <T>(value: T) =>\n  createCodec<T>(\n    () => empty,\n    () => value,\n  )\n\nconst extrinsic = Struct({\n  type: compactNumber,\n  version: u8,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      type: compactNumber,\n      additionalSigned: compactNumber,\n    }),\n  ),\n})\nexport type V14Extrinsic = CodecType<typeof extrinsic>\n\nexport const v14 = Struct({\n  lookup,\n  pallets: Vector(Struct({ ...v14Pallet, docs: Always([] as string[]) })),\n  extrinsic,\n  type: compactNumber,\n  apis: Always([] as Array<CodecType<typeof runtimeApi>>),\n})\nexport type V14 = CodecType<typeof v14>\n", "import { Struct, Vector, str } from \"scale-ts\"\nimport { docs } from \"./docs\"\nimport { compactNumber as ty } from \"../scale\"\n\nexport const runtimeApi = Struct({\n  name: str,\n  methods: Vector(\n    Struct({\n      name: str,\n      inputs: Vector(\n        Struct({\n          name: str,\n          type: ty,\n        }),\n      ),\n      output: ty,\n      docs,\n    }),\n  ),\n  docs,\n})\n", "import { CodecType, Struct, Tuple, Vector, str, u8 } from \"scale-ts\"\nimport { lookup } from \"./lookup\"\nimport { v15Pallet } from \"./pallets\"\nimport { Hex, compactNumber as ty } from \"../scale\"\nimport { runtimeApi } from \"./runtime-api\"\nexport type { V14Lookup } from \"./lookup\"\n\nconst extrinsic = Struct({\n  version: u8,\n  address: ty,\n  call: ty,\n  signature: ty,\n  extra: ty,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      type: ty,\n      additionalSigned: ty,\n    }),\n  ),\n})\nexport type V15Extrinsic = CodecType<typeof extrinsic>\n\nexport const v15 = Struct({\n  lookup,\n  pallets: Vector(Struct(v15Pallet)),\n  extrinsic,\n  type: ty,\n  apis: Vector(runtimeApi),\n  outerEnums: Struct({\n    call: ty,\n    event: ty,\n    error: ty,\n  }),\n  custom: Vector(Tuple(str, Struct({ type: ty, value: Hex() }))),\n})\nexport type V15 = CodecType<typeof v15>\n", "import {\n  Bytes,\n  type Codec,\n  type CodecType,\n  Enum,\n  Option,\n  Struct,\n  Tuple,\n  compact,\n  createCodec,\n  u32,\n} from \"scale-ts\"\nimport type { HexString } from \"../scale\"\nimport { v14 } from \"./v14\"\nimport { v15 } from \"./v15\"\n\nconst unsupportedFn = () => {\n  throw new Error(\"Unsupported metadata version!\")\n}\n\nconst unsupported = createCodec(\n  unsupportedFn,\n  unsupportedFn,\n) as unknown as Codec<unknown>\n\nexport const metadata = Struct({\n  magicNumber: u32,\n  metadata: Enum({\n    v0: unsupported,\n    v1: unsupported,\n    v2: unsupported,\n    v3: unsupported,\n    v4: unsupported,\n    v5: unsupported,\n    v6: unsupported,\n    v7: unsupported,\n    v8: unsupported,\n    v9: unsupported,\n    v10: unsupported,\n    v11: unsupported,\n    v12: unsupported,\n    v13: unsupported,\n    v14,\n    v15,\n  }),\n})\n\nconst opaqueBytes = Bytes()\nconst optionOpaque = Option(opaqueBytes)\nconst opaqueOpaqueBytes = Tuple(compact, opaqueBytes)\n\nexport const decAnyMetadata = (\n  input: Uint8Array | HexString,\n): CodecType<typeof metadata> => {\n  try {\n    return metadata.dec(input)\n  } catch (_) {}\n\n  // comes from metadata.metadata_at_version\n  try {\n    return metadata.dec(optionOpaque.dec(input)!)\n  } catch (_) {}\n\n  // comes from state.getMetadata\n  try {\n    return metadata.dec(opaqueBytes.dec(input))\n  } catch (_) {}\n\n  // comes from metadata.metadata\n  try {\n    return metadata.dec(opaqueOpaqueBytes.dec(input)[1])\n  } catch (_) {}\n\n  throw null\n}\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\n\nconst len32 = { dkLen: 32 }\nexport const Blake2256 = (encoded: Uint8Array) => blake2b(encoded, len32)\n\nconst len16 = { dkLen: 16 }\nexport const Blake2128 = (encoded: Uint8Array) => blake2b(encoded, len16)\n\nexport const Blake2128Concat = (encoded: Uint8Array) =>\n  mergeUint8(Blake2128(encoded), encoded)\n", "/**\n * Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC & KDF.\n *\n * It is advertised as \"the fastest cryptographic hash\". However, it isn't true in JS.\n * Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:\n *\n * * There is only 30% reduction in number of rounds from blake2s\n * * Speed-up comes from tree structure, which is parallelized using SIMD & threading.\n *   These features are not present in JS, so we only get overhead from trees.\n * * Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.\n * * It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm\n * @module\n */\nimport { SHA256_IV } from './_md.ts';\nimport { fromBig } from './_u64.ts';\nimport { BLAKE2, compress } from './blake2.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createXOFer, swap32IfBE, toBytes, u32, u8,\n  type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// Flag bitset\nconst B3_Flags = {\n  CHUNK_START: 0b1,\n  CHUNK_END: 0b10,\n  PARENT: 0b100,\n  ROOT: 0b1000,\n  KEYED_HASH: 0b10000,\n  DERIVE_KEY_CONTEXT: 0b100000,\n  DERIVE_KEY_MATERIAL: 0b1000000,\n} as const;\n\nconst B3_IV = SHA256_IV.slice();\n\nconst B3_SIGMA: Uint8Array = /* @__PURE__ */ (() => {\n  const Id = Array.from({ length: 16 }, (_, i) => i);\n  const permute = (arr: number[]) =>\n    [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);\n  const res: number[] = [];\n  for (let i = 0, v = Id; i < 7; i++, v = permute(v)) res.push(...v);\n  return Uint8Array.from(res);\n})();\n\n/**\n * Ensure to use EITHER `key` OR `context`, not both.\n *\n * * `key`: 32-byte MAC key.\n * * `context`: string for KDF. Should be hardcoded, globally unique, and application - specific.\n *   A good default format for the context string is \"[application] [commit timestamp] [purpose]\".\n */\nexport type Blake3Opts = { dkLen?: number; key?: Input; context?: Input };\n\n/** Blake3 hash. Can be used as MAC and KDF. */\nexport class BLAKE3 extends BLAKE2<BLAKE3> implements HashXOF<BLAKE3> {\n  private chunkPos = 0; // Position of current block in chunk\n  private chunksDone = 0; // How many chunks we already have\n  private flags = 0 | 0;\n  private IV: Uint32Array;\n  private state: Uint32Array;\n  private stack: Uint32Array[] = [];\n  // Output\n  private posOut = 0;\n  private bufferOut32 = new Uint32Array(16);\n  private bufferOut: Uint8Array;\n  private chunkOut = 0; // index of output chunk\n  private enableXOF = true;\n\n  constructor(opts: Blake3Opts = {}, flags = 0) {\n    super(64, opts.dkLen === undefined ? 32 : opts.dkLen);\n    const { key, context } = opts;\n    const hasContext = context !== undefined;\n    if (key !== undefined) {\n      if (hasContext) throw new Error('Only \"key\" or \"context\" can be specified at same time');\n      const k = toBytes(key).slice();\n      abytes(k, 32);\n      this.IV = u32(k);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.KEYED_HASH;\n    } else if (hasContext) {\n      const ctx = toBytes(context);\n      const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT)\n        .update(ctx)\n        .digest();\n      this.IV = u32(contextKey);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;\n    } else {\n      this.IV = B3_IV.slice();\n      this.flags = flags;\n    }\n    this.state = this.IV.slice();\n    this.bufferOut = u8(this.bufferOut32);\n  }\n  // Unused\n  protected get(): [] {\n    return [];\n  }\n  protected set(): void {}\n  private b2Compress(counter: number, flags: number, buf: Uint32Array, bufPos: number = 0) {\n    const { state: s, pos } = this;\n    const { h, l } = fromBig(BigInt(counter), true);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, bufPos, buf, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags\n      );\n    s[0] = v0 ^ v8;\n    s[1] = v1 ^ v9;\n    s[2] = v2 ^ v10;\n    s[3] = v3 ^ v11;\n    s[4] = v4 ^ v12;\n    s[5] = v5 ^ v13;\n    s[6] = v6 ^ v14;\n    s[7] = v7 ^ v15;\n  }\n  protected compress(buf: Uint32Array, bufPos: number = 0, isLast: boolean = false): void {\n    // Compress last block\n    let flags = this.flags;\n    if (!this.chunkPos) flags |= B3_Flags.CHUNK_START;\n    if (this.chunkPos === 15 || isLast) flags |= B3_Flags.CHUNK_END;\n    if (!isLast) this.pos = this.blockLen;\n    this.b2Compress(this.chunksDone, flags, buf, bufPos);\n    this.chunkPos += 1;\n    // If current block is last in chunk (16 blocks), then compress chunks\n    if (this.chunkPos === 16 || isLast) {\n      let chunk = this.state;\n      this.state = this.IV.slice();\n      // If not the last one, compress only when there are trailing zeros in chunk counter\n      // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n      // 1 (001) - leaf not finished (just push current chunk to stack)\n      // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n      // 3 (011) - last leaf not finished\n      // 4 (100) - leafs finished at depth=1 and depth=2\n      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n        if (!(last = this.stack.pop())) break;\n        this.buffer32.set(last, 0);\n        this.buffer32.set(chunk, 8);\n        this.pos = this.blockLen;\n        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);\n        chunk = this.state;\n        this.state = this.IV.slice();\n      }\n      this.chunksDone++;\n      this.chunkPos = 0;\n      this.stack.push(chunk);\n    }\n    this.pos = 0;\n  }\n  _cloneInto(to?: BLAKE3): BLAKE3 {\n    to = super._cloneInto(to) as BLAKE3;\n    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;\n    to.state.set(state.slice());\n    to.stack = stack.map((i) => Uint32Array.from(i));\n    to.IV.set(IV);\n    to.flags = flags;\n    to.chunkPos = chunkPos;\n    to.chunksDone = chunksDone;\n    to.posOut = posOut;\n    to.chunkOut = chunkOut;\n    to.enableXOF = this.enableXOF;\n    to.bufferOut32.set(this.bufferOut32);\n    return to;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state, this.buffer32, this.IV, this.bufferOut32);\n    clean(...this.stack);\n  }\n  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n  private b2CompressOut() {\n    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;\n    const { h, l } = fromBig(BigInt(this.chunkOut++));\n    swap32IfBE(buffer32);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, 0, buffer32, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags\n      );\n    out32[0] = v0 ^ v8;\n    out32[1] = v1 ^ v9;\n    out32[2] = v2 ^ v10;\n    out32[3] = v3 ^ v11;\n    out32[4] = v4 ^ v12;\n    out32[5] = v5 ^ v13;\n    out32[6] = v6 ^ v14;\n    out32[7] = v7 ^ v15;\n    out32[8] = s[0] ^ v8;\n    out32[9] = s[1] ^ v9;\n    out32[10] = s[2] ^ v10;\n    out32[11] = s[3] ^ v11;\n    out32[12] = s[4] ^ v12;\n    out32[13] = s[5] ^ v13;\n    out32[14] = s[6] ^ v14;\n    out32[15] = s[7] ^ v15;\n    swap32IfBE(buffer32);\n    swap32IfBE(out32);\n    this.posOut = 0;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(this.pos));\n    // Process last chunk\n    let flags = this.flags | B3_Flags.ROOT;\n    if (this.stack.length) {\n      flags |= B3_Flags.PARENT;\n      swap32IfBE(this.buffer32);\n      this.compress(this.buffer32, 0, true);\n      swap32IfBE(this.buffer32);\n      this.chunksDone = 0;\n      this.pos = this.blockLen;\n    } else {\n      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;\n    }\n    this.flags = flags;\n    this.b2CompressOut();\n  }\n  private writeInto(out: Uint8Array) {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const { blockLen, bufferOut } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.b2CompressOut();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    if (!this.enableXOF) throw new Error('XOF is not possible after digest call');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.enableXOF = false;\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n}\n\n/**\n * BLAKE3 hash function. Can be used as MAC and KDF.\n * @param msg - message that would be hashed\n * @param opts - `dkLen` for output length, `key` for MAC mode, `context` for KDF mode\n * @example\n * const data = new Uint8Array(32);\n * const hash = blake3(data);\n * const mac = blake3(data, { key: new Uint8Array(32) });\n * const kdf = blake3(data, { context: 'application name' });\n */\nexport const blake3: CHashXO = /* @__PURE__ */ createXOFer<BLAKE3, Blake3Opts>(\n  (opts) => new BLAKE3(opts)\n);\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { blake3 } from \"@noble/hashes/blake3\"\n\nconst len32 = { dkLen: 32 }\nexport const Blake3256 = (encoded: Uint8Array) => blake3(encoded, len32)\n\nexport const Blake3256Concat = (encoded: Uint8Array) =>\n  mergeUint8(Blake3256(encoded), encoded)\n", "export const Identity = (encoded: Uint8Array): Uint8Array => encoded\n", "// Adapted implementation based on: https://github.com/pierrec/js-xxhash/blob/7ff5ced282f97dba121109d7013e0fa80360398c/lib/xxhash64.js\n\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n\n// helper functions\nconst bigintFromU16 = (\n  v0: number,\n  v1: number,\n  v2: number,\n  v3: number,\n): bigint =>\n  new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true)\n\nconst MASK_64 = 2n ** 64n - 1n\n\nconst rotl = (input: bigint, nBits: bigint) =>\n  ((input << nBits) & MASK_64) | (input >> (64n - nBits))\n\nconst multiply = (a: bigint, b: bigint) => (a * b) & MASK_64\n\nconst add = (a: bigint, b: bigint) => (a + b) & MASK_64\n\n// constants\nconst PRIME64_1 = 11400714785074694791n\nconst PRIME64_2 = 14029467366897019727n\nconst PRIME64_3 = 1609587929392839161n\nconst PRIME64_4 = 9650029242287828579n\nconst PRIME64_5 = 2870177450012600261n\n\nexport function h64(input: Uint8Array, seed: bigint = 0n) {\n  let v1 = add(add(seed, PRIME64_1), PRIME64_2)\n  let v2 = add(seed, PRIME64_2)\n  let v3 = seed\n  let v4 = seed - PRIME64_1\n  let totalLen = input.length\n  let memsize = 0\n  let memory: Uint8Array | null = null\n\n  ;(function update() {\n    let p = 0\n    let bEnd = p + totalLen\n\n    if (!totalLen) return\n\n    memory = new Uint8Array(32)\n\n    if (totalLen < 32) {\n      memory.set(input.subarray(0, totalLen), memsize)\n\n      memsize += totalLen\n      return\n    }\n\n    if (p <= bEnd - 32) {\n      const limit = bEnd - 32\n\n      do {\n        let other\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n      } while (p <= limit)\n    }\n\n    if (p < bEnd) {\n      memory.set(input.subarray(p, bEnd), memsize)\n      memsize = bEnd - p\n    }\n  })()\n\n  input = memory || input\n\n  let result: bigint\n  let p = 0\n\n  if (totalLen >= 32) {\n    result = rotl(v1, 1n)\n    result = add(result, rotl(v2, 7n))\n    result = add(result, rotl(v3, 12n))\n    result = add(result, rotl(v4, 18n))\n\n    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v1\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v2\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v3\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v4\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n  } else {\n    result = add(seed, PRIME64_5)\n  }\n\n  result = add(result, BigInt(totalLen))\n\n  while (p <= memsize - 8) {\n    let temp = bigintFromU16(\n      (input[p + 1] << 8) | input[p],\n      (input[p + 3] << 8) | input[p + 2],\n      (input[p + 5] << 8) | input[p + 4],\n      (input[p + 7] << 8) | input[p + 6],\n    )\n    temp = multiply(rotl(multiply(temp, PRIME64_2), 31n), PRIME64_1)\n    result = add(multiply(rotl(result ^ temp, 27n), PRIME64_1), PRIME64_4)\n    p += 8\n  }\n\n  if (p + 4 <= memsize) {\n    let temp = multiply(\n      bigintFromU16(\n        (input[p + 1] << 8) | input[p],\n        (input[p + 3] << 8) | input[p + 2],\n        0,\n        0,\n      ),\n      PRIME64_1,\n    )\n\n    result = add(multiply(rotl(result ^ temp, 23n), PRIME64_2), PRIME64_3)\n    p += 4\n  }\n\n  while (p < memsize) {\n    const temp = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5)\n    result = multiply(rotl(result ^ temp, 11n), PRIME64_1)\n  }\n\n  let temp = result >> 33n\n  result = multiply(result ^ temp, PRIME64_2)\n\n  temp = result >> 29n\n  result = multiply(result ^ temp, PRIME64_3)\n\n  temp = result >> 32n\n  result ^= temp\n\n  return result\n}\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { u64 } from \"scale-ts\"\nimport { h64 } from \"./h64\"\n\nexport const Twox128 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n\n  return result\n}\n\nexport const Twox256 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n  dv.setBigUint64(16, h64(input, 2n), true)\n  dv.setBigUint64(24, h64(input, 3n), true)\n\n  return result\n}\n\nexport const Twox64Concat = (encoded: Uint8Array): Uint8Array =>\n  mergeUint8(u64.enc(h64(encoded)), encoded)\n", "import { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport type { Codec } from \"scale-ts\"\nimport {\n  Blake2128,\n  Blake2128Concat,\n  Blake2256,\n  Identity,\n  Twox128,\n  Twox256,\n  Twox64Concat,\n} from \"./hashes\"\n\nexport type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array]\n\nconst textEncoder = new TextEncoder()\n\n// the value indicates:\n// - when positive: the number of bytes to skip before reaching the transparent-encoded key\n// - when negative: the number of bytes that the opaque hasher will generate\nconst hashers: Map<(input: Uint8Array) => Uint8Array, number> = new Map([\n  [Identity, 0],\n  [Twox64Concat, 8],\n  [Blake2128Concat, 16],\n  [Blake2128, -16],\n  [Blake2256, -32],\n  [Twox128, -16],\n  [Twox256, -32],\n])\n\nexport type OpaqueKeyHash = string & { __opaqueKeyHash?: unknown }\n\nexport const Storage = (pallet: string) => {\n  const palledEncoded = Twox128(textEncoder.encode(pallet))\n  return <A extends Array<EncoderWithHash<any>>>(\n    name: string,\n    ...encoders: [...A]\n  ): {\n    enc: (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ) => string\n    dec: (value: string) => {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    }\n  } => {\n    const palletItemEncoded = mergeUint8(\n      palledEncoded,\n      Twox128(textEncoder.encode(name)),\n    )\n\n    const palletItemEncodedHex = toHex(palletItemEncoded)\n\n    const dec = (\n      key: string,\n    ): {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    } => {\n      if (!key.startsWith(palletItemEncodedHex))\n        throw new Error(`key does not match this storage (${pallet}.${name})`)\n\n      if (encoders.length === 0) return [] as any\n\n      const argsKey = fromHex(key.slice(palletItemEncodedHex.length))\n      const result = new Array<any>(encoders.length)\n      for (let i = 0, cur = 0; i < encoders.length; i++) {\n        const [codec, hasher] = encoders[i]\n        const hBytes = hashers.get(hasher)\n        if (hBytes == null) throw new Error(\"Unknown hasher\")\n        if (hBytes < 0) {\n          const opaqueBytes = hBytes * -1\n          result[i] = toHex(argsKey.slice(cur, cur + opaqueBytes))\n          cur += opaqueBytes\n        } else {\n          cur += hBytes\n          result[i] = codec.dec(argsKey.slice(cur))\n          cur += codec.enc(result[i]).length\n        }\n      }\n      return result as any\n    }\n\n    const fns = encoders.map(\n      ([{ enc }, hash]) =>\n        (val: any) =>\n          hash(enc(val)),\n    )\n\n    const enc = (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ): string =>\n      toHex(\n        mergeUint8(palletItemEncoded, ...args.map((val, idx) => fns[idx](val))),\n      )\n\n    return {\n      enc,\n      dec,\n    }\n  }\n}\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { Binary, compact, u16 } from \"../codecs\"\nimport { Blake2256 } from \"../hashes\"\n\nconst PREFIX = Binary.fromText(\"modlpy/utilisuba\").asBytes()\nexport const getMultisigAccountId = ({\n  threshold,\n  signatories,\n}: {\n  threshold: number\n  signatories: Uint8Array[]\n}) => {\n  const sortedSignatories = sortMultisigSignatories(signatories)\n  const payload = mergeUint8(\n    PREFIX,\n    compact.enc(sortedSignatories.length),\n    ...sortedSignatories,\n    u16.enc(threshold),\n  )\n  return Blake2256(payload)\n}\n\nexport const sortMultisigSignatories = (signatories: Uint8Array[]) =>\n  signatories.slice().sort((a, b) => {\n    for (let i = 0; ; i++) {\n      const overA = i >= a.length\n      const overB = i >= b.length\n\n      if (overA && overB) return 0\n      else if (overA) return -1\n      else if (overB) return 1\n      else if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1\n    }\n  })\n", "import type { MetadataPrimitives, Var } from \"@polkadot-api/metadata-builders\"\nimport {\n  Codec,\n  Enum,\n  Option,\n  Self,\n  StringRecord,\n  Struct,\n  Tuple,\n  Variant,\n  Vector,\n  _void,\n  compactNumber,\n  str,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst smallCompact = compactNumber\nexport interface StructNode {\n  type: \"struct\"\n  value: Array<[string, number]>\n}\nconst StructCodec = Vector(Tuple(str, smallCompact))\n\nexport const Primitive = {\n  bool: \"boolean\" as const,\n  str: \"string\" as const,\n  num: \"number\" as const,\n  big: \"bigint\" as const,\n  bits: \"bitseq\" as const,\n  void: \"void\" as const,\n}\nexport type PRIMITIVES = (typeof Primitive)[keyof typeof Primitive]\n\nexport interface TerminalNode {\n  type: \"terminal\"\n  value: {\n    type: PRIMITIVES\n  }\n}\nconst TerminalCodec = Variant(\n  Object.fromEntries(\n    Object.values(Primitive).map((p) => [p, _void]),\n  ) as StringRecord<Codec<undefined>>,\n) as any as Codec<TerminalNode[\"value\"]>\n\nexport interface EnumNode {\n  type: \"enum\"\n  value: Array<[string, Enum<{ inline: TypedefNode; lookup: number }>]>\n}\nconst EnumCodec: Codec<EnumNode[\"value\"]> = Vector(\n  Tuple(\n    str,\n    Variant({\n      inline: Self(() => TypedefCodec),\n      lookup: smallCompact,\n    }),\n  ),\n)\n\nexport interface TupleNode {\n  type: \"tuple\"\n  value: number[]\n}\nconst TupleCodec = Vector(smallCompact)\n\nexport interface ArrayNode {\n  type: \"array\"\n  value: {\n    typeRef: number\n    length?: number\n  }\n}\nconst ArrayCodec = Struct({\n  typeRef: smallCompact,\n  length: Option(smallCompact),\n}) as Codec<ArrayNode[\"value\"]>\n\nexport interface BinaryNode {\n  type: \"binary\"\n  value: number | undefined\n}\nconst BinaryCodec = Option(smallCompact) as Codec<BinaryNode[\"value\"]>\n\nexport interface OptionNode {\n  type: \"option\"\n  value: number\n}\nconst OptionCodec = smallCompact\n\nexport interface ResultNode {\n  type: \"result\"\n  value: {\n    ok: number\n    ko: number\n  }\n}\nconst ResultCodec = Struct({\n  ok: smallCompact,\n  ko: smallCompact,\n})\n\nexport type TypedefNode =\n  | StructNode\n  | TerminalNode\n  | EnumNode\n  | TupleNode\n  | ArrayNode\n  | BinaryNode\n  | OptionNode\n  | ResultNode\nexport const TypedefCodec: Codec<TypedefNode> = Variant({\n  struct: StructCodec,\n  terminal: TerminalCodec,\n  enum: EnumCodec,\n  tuple: TupleCodec,\n  array: ArrayCodec,\n  binary: BinaryCodec,\n  option: OptionCodec,\n  result: ResultCodec,\n})\n\nconst primitiveToTerminal: Record<MetadataPrimitives, PRIMITIVES> = {\n  i256: Primitive.big,\n  i128: Primitive.big,\n  i64: Primitive.big,\n  i32: Primitive.num,\n  i16: Primitive.num,\n  i8: Primitive.num,\n  u256: Primitive.big,\n  u128: Primitive.big,\n  u64: Primitive.big,\n  u32: Primitive.num,\n  u16: Primitive.num,\n  u8: Primitive.num,\n  bool: Primitive.bool,\n  char: Primitive.str,\n  str: Primitive.str,\n}\n\nconst terminal = (type: PRIMITIVES): TerminalNode => ({\n  type: \"terminal\",\n  value: { type },\n})\nexport function mapLookupToTypedef(\n  entry: Var,\n  resolve: (id: number) => void = () => {},\n): TypedefNode {\n  switch (entry.type) {\n    case \"AccountId20\":\n    case \"AccountId32\":\n      return terminal(Primitive.str)\n    case \"array\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: entry.len }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: {\n          typeRef: entry.value.id,\n          length: entry.len,\n        },\n      }\n    case \"bitSequence\":\n      return terminal(Primitive.bits)\n    case \"compact\":\n      return terminal(entry.isBig ? Primitive.big : Primitive.num)\n    case \"enum\":\n      return {\n        type: \"enum\",\n        value: Object.entries(entry.value).map(\n          ([key, params]): EnumNode[\"value\"][number] => {\n            if (params.type !== \"lookupEntry\")\n              return [\n                key,\n                { type: \"inline\", value: mapLookupToTypedef(params, resolve) },\n              ]\n\n            resolve(params.value.id)\n            return [\n              key,\n              {\n                type: \"lookup\",\n                value: params.value.id,\n              },\n            ]\n          },\n        ),\n      }\n    case \"struct\": {\n      const value = Object.entries(entry.value).map(\n        ([key, prop]) => [key, prop.id] satisfies [string, number],\n      )\n      value.forEach(([, v]) => resolve(v))\n      return {\n        type: \"struct\",\n        value,\n      }\n    }\n    case \"tuple\": {\n      const value = entry.value.map((v) => v.id)\n      value.forEach(resolve)\n      return {\n        type: \"tuple\",\n        value,\n      }\n    }\n    case \"option\":\n      resolve(entry.value.id)\n      return {\n        type: \"option\",\n        value: entry.value.id,\n      }\n    case \"primitive\":\n      return terminal(primitiveToTerminal[entry.value])\n    case \"result\":\n      resolve(entry.value.ok.id)\n      resolve(entry.value.ko.id)\n      return {\n        type: \"result\",\n        value: {\n          ok: entry.value.ok.id,\n          ko: entry.value.ko.id,\n        },\n      }\n    case \"sequence\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: undefined }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: { typeRef: entry.value.id },\n      }\n    case \"void\":\n      return terminal(Primitive.void)\n  }\n}\n\nexport function mapReferences(\n  node: TypedefNode,\n  mapFn: (id: number) => number,\n): TypedefNode {\n  switch (node.type) {\n    case \"array\":\n      return {\n        ...node,\n        value: {\n          ...node.value,\n          typeRef: mapFn(node.value.typeRef),\n        },\n      }\n    case \"option\":\n      return { ...node, value: mapFn(node.value) }\n    case \"result\":\n      return {\n        ...node,\n        value: { ok: mapFn(node.value.ok), ko: mapFn(node.value.ko) },\n      }\n    case \"tuple\":\n      return { ...node, value: node.value.map(mapFn) }\n    case \"struct\":\n      return {\n        ...node,\n        value: node.value.map(([k, v]) => [k, mapFn(v)] as [string, number]),\n      }\n    case \"enum\": {\n      return {\n        ...node,\n        value: node.value.map(([k, { type, value }]): EnumNode[\"value\"][0] => [\n          k,\n          type === \"lookup\"\n            ? { type, value: mapFn(value) }\n            : { type, value: mapReferences(value, mapFn) },\n        ]),\n      }\n    }\n\n    case \"binary\":\n    case \"terminal\":\n      return node\n  }\n}\n", "import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { Primitive, type TerminalNode, type TypedefNode } from \"./typedef\"\n\n// Descriptors: pallet + name => index (this._descriptors[opType][pallet][name])\n// index will be for both checksums and compatLookup\n\n// Dest type: describes types of the receiving end.\nexport function isCompatible(\n  value: any,\n  destNode: TypedefNode,\n  getNode: (id: number) => TypedefNode,\n): boolean {\n  if (destNode.type === \"option\" && value == null) {\n    return true\n  }\n\n  const nextCall = (value: any, destNode: TypedefNode) =>\n    isCompatible(value, destNode, getNode)\n\n  const checkTerminal = (terminal: TerminalNode) => {\n    switch (terminal.value.type) {\n      case Primitive.str:\n      case Primitive.big:\n      case Primitive.bool:\n      case Primitive.num:\n        return typeof value === terminal.value.type\n      case Primitive.bits:\n        return (\n          typeof value === \"object\" &&\n          value != null &&\n          typeof value.bitsLen === \"number\" &&\n          value.bytes instanceof Uint8Array\n        )\n      case Primitive.void:\n        // A void node is always compatible, since the codec ignores the input.\n        return true\n    }\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return checkTerminal(destNode)\n    case \"binary\":\n      return (\n        value instanceof Binary &&\n        (destNode.value == null || value.asBytes().length >= destNode.value)\n      )\n    case \"array\":\n      if (!Array.isArray(value)) return false\n      const valueArr = value as Array<any>\n      if (\n        destNode.value.length != null &&\n        valueArr.length < destNode.value.length\n      ) {\n        return false\n      }\n      return valueArr\n        .slice(0, destNode.value.length)\n        .every((value) => nextCall(value, getNode(destNode.value.typeRef)))\n    case \"enum\":\n      if (!value) return false\n      const valueEnum = value as { type: string; value: any }\n      const destVariants = Object.fromEntries(destNode.value)\n      if (!(valueEnum.type in destVariants)) {\n        return false\n      }\n      const variantValue = destVariants[valueEnum.type]\n      if (variantValue == null) {\n        return true\n      }\n      return nextCall(\n        valueEnum.value,\n        variantValue.type === \"inline\"\n          ? variantValue.value\n          : getNode(variantValue.value),\n      )\n    case \"option\":\n      if (value == null) {\n        return true\n      }\n      return nextCall(value, getNode(destNode.value))\n    case \"struct\":\n      if (!value) return false\n      return destNode.value.every(([key, typeRef]) =>\n        nextCall(value[key], getNode(typeRef)),\n      )\n    case \"tuple\":\n      if (!value) return false\n      // length will be checked indirectly\n      return destNode.value.every((typeRef, idx) =>\n        nextCall(value[idx], getNode(typeRef)),\n      )\n    case \"result\":\n      if (!(\"success\" in value && \"value\" in value)) return false\n      return nextCall(\n        value.value,\n        getNode(value.success ? destNode.value.ok : destNode.value.ko),\n      )\n  }\n}\n", "export class DoubleSet<T> {\n  private value: Map<T, Set<T>> = new Map()\n\n  constructor(values: Array<[T, T]> = []) {\n    values.forEach(([a, b]) => this.add(a, b))\n  }\n\n  public has(a: T, b: T) {\n    return this.value.get(a)?.has(b) ?? false\n  }\n  public add(a: T, b: T) {\n    if (!this.value.has(a)) {\n      this.value.set(a, new Set())\n    }\n    this.value.get(a)!.add(b)\n  }\n  public addAll(values: Array<[T, T]>) {\n    values.forEach(([a, b]) => this.add(a, b))\n  }\n  public delete(a: T, b: T) {\n    if (!this.value.has(a)) return\n    const set = this.value.get(a)!\n    set.delete(b)\n    if (!set.size) {\n      this.value.delete(a)\n    }\n  }\n  public isEmpty() {\n    return !this.value.size\n  }\n  public get values() {\n    return Array.from(this.value).flatMap(([a, values]) =>\n      Array.from(values).map((b) => [a, b] as [T, T]),\n    )\n  }\n}\n", "import { DoubleSet } from \"./doubleSet\"\nimport type {\n  ArrayNode,\n  BinaryNode,\n  EnumNode,\n  OptionNode,\n  ResultNode,\n  StructNode,\n  TerminalNode,\n  TupleNode,\n  TypedefNode,\n} from \"./typedef\"\n\nexport enum CompatibilityLevel {\n  // No possible value from origin will be compatible with dest\n  Incompatible = 0,\n  // Some values of origin will be compatible with dest\n  Partial,\n  // Every value from origin will be compatible with dest\n  BackwardsCompatible,\n  // Types are identical\n  Identical,\n}\n\n/*\n * We have to be careful with circular references and early returns with the cache.\n *\n * For early returns, the resulting level could be even lower when exploring other branches.\n * This means that we can't store early returns in the cache. For simplicity, the\n * initial implementation will not have early returns.\n * It should be possible to store in the cache what was the CompatibilityLevel that\n * caused the early return, so that if the same call is done with the same CompatibilityLevel\n * we could still leverage the cache.\n *\n * For circular references, the simplest solution is to assume that the circular\n * node is fully-compatible (Identical). But then any node that is reading from it\n * can't be cached because its result will be doing the assumption that the circular\n * node is `Identical`.\n * Only once the whole cycle has completed, then the circular node can actually\n * cache its own result (TODO check this assumption is fine), and then any other\n * node that referenced it can also safely cache.\n * We have to think cases where there could be two cycles:\n *         F  E\n *            \n * A  B  C  D\n *            \n *     I  H  G\n *\n * B = 4 => B = 1\n * B = 1 => B = 0\n *\n * As we're going depth-first, when we reach C from F, we will return a \"temporary\"\n * `Identical`. This means that F, E or D can't be cached. But then we continue\n * depth-first into G-H-I-B, then detect the cycle and return a \"temporary\" `Identical`.\n * Then I, H, G and C can't be cached because they actually depend on the temporary result of B.\n * B on the other hand will be able to cache its own result, and so does A.\n *\n * If a new call enters the cycle from D, then the branch G-H-I-B will be cached.\n * But the cycle D-E-F-C will make E-F-C not to cache their result yet.\n *\n *\n * => Maybe instead of having two separate [originNode, destNode] we can first merge\n * both trees into one, and then run the search? This would simplify the double-map/set stuff.\n * Can it be done lazily though? In a way that we don't need to go through the whole tree?\n */\n\nexport type StaticCompatibleResult = {\n  level: CompatibilityLevel\n  assumptions: DoubleSet<TypedefNode>\n}\nexport type CompatibilityCache = Map<\n  TypedefNode,\n  Map<TypedefNode, CompatibilityLevel | null>\n>\nexport function isStaticCompatible(\n  originNode: TypedefNode | undefined,\n  getOriginNode: (id: number) => TypedefNode,\n  destNode: TypedefNode | undefined,\n  getDestNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n): StaticCompatibleResult {\n  if (!destNode && !originNode) {\n    return unconditional(CompatibilityLevel.Identical)\n  }\n  if (!destNode) return unconditional(CompatibilityLevel.BackwardsCompatible)\n  if (!originNode)\n    return unconditional(\n      destNode.type === \"option\"\n        ? CompatibilityLevel.BackwardsCompatible\n        : CompatibilityLevel.Incompatible,\n    )\n\n  if (!cache.has(destNode)) {\n    cache.set(destNode, new Map())\n  }\n  const destNodeCache = cache.get(destNode)!\n  if (destNodeCache.has(originNode)) {\n    const result = destNodeCache.get(originNode)\n    if (result === null) {\n      // Circular reference hit, return Identical with assumption\n      return {\n        level: CompatibilityLevel.Identical,\n        assumptions: new DoubleSet([[originNode, destNode]]),\n      }\n    }\n    return unconditional(result!)\n  }\n\n  // Initialize to null for detecting circular references\n  destNodeCache.set(originNode, null)\n\n  const result = getIsStaticCompatible(\n    originNode,\n    destNode,\n    (originNode, destNode) =>\n      isStaticCompatible(\n        typeof originNode === \"number\" ? getOriginNode(originNode) : originNode,\n        getOriginNode,\n        typeof destNode === \"number\" ? getDestNode(destNode) : destNode,\n        getDestNode,\n        cache,\n      ),\n  )\n\n  result.assumptions.delete(originNode, destNode)\n  if (\n    result.assumptions.isEmpty() ||\n    result.level === CompatibilityLevel.Incompatible\n  ) {\n    destNodeCache.set(originNode, result.level)\n  } else {\n    // Remove the temporary `null` value from the cache\n    destNodeCache.delete(originNode)\n  }\n  return result\n}\n\nfunction getIsStaticCompatible(\n  originNode: TypedefNode,\n  destNode: TypedefNode,\n  nextCall: (\n    originNode: TypedefNode | number | undefined,\n    destNode: TypedefNode | number | undefined,\n  ) => StaticCompatibleResult,\n): StaticCompatibleResult {\n  if (originNode.type !== destNode.type) {\n    if (destNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode, destNode.value),\n        CompatibilityLevel.BackwardsCompatible,\n      )\n    }\n    if (originNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode.value, destNode),\n        CompatibilityLevel.Partial,\n      )\n    }\n    return unconditional(CompatibilityLevel.Incompatible)\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return unconditional(\n        destNode.value.type === (originNode as TerminalNode).value.type\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.Incompatible,\n      )\n    case \"binary\":\n      const binaryOrigin = originNode as BinaryNode\n      return unconditional(\n        compareOptionalLengths(binaryOrigin.value, destNode.value),\n      )\n    case \"array\":\n      const arrayOrigin = originNode as ArrayNode\n      const lengthCheck = unconditional(\n        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length),\n      )\n      return strictMerge([\n        lengthCheck,\n        () => nextCall(arrayOrigin.value.typeRef, destNode.value.typeRef),\n      ])\n    case \"enum\": {\n      const enumOrigin = originNode as EnumNode\n      const destVariants = Object.fromEntries(\n        destNode.value.map(([key, value]) => [key, value.value]),\n      )\n      const maxLevel =\n        enumOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      // check whether every possible `origin` value is compatible with dest\n      return withMaxLevel(\n        mergeResults(\n          enumOrigin.value.map(\n            ([type, value]) =>\n              () =>\n                type in destVariants\n                  ? nextCall(value.value, destVariants[type])\n                  : unconditional(CompatibilityLevel.Incompatible),\n          ),\n        ),\n        maxLevel,\n      )\n    }\n    case \"option\":\n      return nextCall((originNode as OptionNode).value, destNode.value)\n    case \"struct\":\n      const structOrigin = originNode as StructNode\n      const originProperties = Object.fromEntries(structOrigin.value)\n      const maxLevel =\n        structOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      return withMaxLevel(\n        strictMerge(\n          destNode.value.map(\n            ([key, value]) =>\n              () =>\n                nextCall(originProperties[key], value),\n          ),\n        ),\n        maxLevel,\n      )\n    case \"tuple\": {\n      const tupleOrigin = originNode as TupleNode\n      const lengthCheck = unconditional(\n        compareArrayLengths(tupleOrigin.value, destNode.value),\n      )\n      return strictMerge([\n        lengthCheck,\n        ...destNode.value.map(\n          (value, idx) => () => nextCall(tupleOrigin.value[idx], value),\n        ),\n      ])\n    }\n    case \"result\":\n      const resultOrigin = originNode as ResultNode\n      return mergeResults([\n        nextCall(resultOrigin.value.ok, destNode.value.ok),\n        nextCall(resultOrigin.value.ko, destNode.value.ko),\n      ])\n  }\n}\n\nconst withMaxLevel = (\n  result: StaticCompatibleResult,\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  ...result,\n  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result\n  level: Math.min(result.level, level),\n})\nconst noAssumptions = new DoubleSet<TypedefNode>()\nexport const unconditional = (\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  level,\n  assumptions: noAssumptions,\n})\n\n/**\n * Merges multiple results, following the most \"strict\" one, (semantically an\n * AND)\n */\nexport const strictMerge = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  let merged = unconditional(CompatibilityLevel.Identical)\n\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    // On early return we don't need to keep the other assumptions\n    if (result.level === CompatibilityLevel.Incompatible) return result\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return merged\n}\n\n/**\n * Merges multiple results, going to `partially` (semantically an OR)\n */\nconst mergeResults = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  if (!results.length) return unconditional(CompatibilityLevel.Identical)\n\n  let hasCompatibles = false\n\n  let merged = unconditional(CompatibilityLevel.Identical)\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    if (result.level === CompatibilityLevel.Incompatible) {\n      merged.level = Math.min(merged.level, CompatibilityLevel.Partial)\n      continue\n    }\n    hasCompatibles = true\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return hasCompatibles\n    ? merged\n    : unconditional(CompatibilityLevel.Incompatible)\n}\n\nexport const compareArrayLengths = (\n  origin: unknown[],\n  dest: unknown[],\n): CompatibilityLevel =>\n  dest.length === origin.length\n    ? CompatibilityLevel.Identical\n    : origin.length >= dest.length\n      ? CompatibilityLevel.BackwardsCompatible\n      : CompatibilityLevel.Incompatible\n\nexport const compareOptionalLengths = (\n  origin: number | undefined,\n  dest: number | undefined,\n): CompatibilityLevel =>\n  dest === origin\n    ? CompatibilityLevel.Identical\n    : dest == null || origin! >= dest\n      ? CompatibilityLevel.BackwardsCompatible\n      : origin == null\n        ? CompatibilityLevel.Partial\n        : CompatibilityLevel.Incompatible\n", "import type { EnumVar } from \"@polkadot-api/metadata-builders\"\nimport {\n  compactNumber,\n  Struct,\n  Variant,\n  type V14,\n  type V15,\n} from \"@polkadot-api/substrate-bindings\"\nimport { isCompatible } from \"./isCompatible\"\nimport { CompatibilityCache, isStaticCompatible } from \"./isStaticCompatible\"\nimport {\n  mapLookupToTypedef,\n  mapReferences,\n  Primitive,\n  TypedefCodec,\n  type TypedefNode,\n} from \"./typedef\"\n\nexport type EntryPointNode =\n  | {\n      type: \"lookup\"\n      value: number\n    }\n  | {\n      type: \"typedef\"\n      value: TypedefNode\n    }\nconst EntryPointNodeCodec = Variant({\n  lookup: compactNumber,\n  typedef: TypedefCodec,\n})\n\nconst lookupNode = (value: number): EntryPointNode => ({\n  type: \"lookup\",\n  value,\n})\nconst typedefNode = (value: TypedefNode): EntryPointNode => ({\n  type: \"typedef\",\n  value,\n})\nexport const voidEntryPointNode = typedefNode({\n  type: \"terminal\",\n  value: { type: Primitive.void },\n})\n\nexport interface EntryPoint {\n  args: EntryPointNode\n  values: EntryPointNode\n}\nexport const EntryPointCodec = Struct({\n  args: EntryPointNodeCodec,\n  values: EntryPointNodeCodec,\n})\n\nexport function storageEntryPoint(\n  storageEntry: Exclude<\n    (V15 | V14)[\"pallets\"][number][\"storage\"],\n    undefined\n  >[\"items\"][number],\n): EntryPoint {\n  if (storageEntry.type.tag === \"plain\")\n    return {\n      args: voidEntryPointNode,\n      values: lookupNode(storageEntry.type.value),\n    }\n\n  const { key, value } = storageEntry.type.value\n  return {\n    args: lookupNode(key),\n    values: lookupNode(value),\n  }\n}\n\nexport function runtimeCallEntryPoint(\n  entry: (V15 | V14)[\"apis\"][number][\"methods\"][number],\n): EntryPoint {\n  return {\n    args: typedefNode({\n      type: \"tuple\",\n      value: entry.inputs.map((v) => v.type),\n    }),\n    values: lookupNode(entry.output),\n  }\n}\n\nexport function enumValueEntryPointNode(\n  entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n): EntryPointNode {\n  return entry.type === \"lookupEntry\"\n    ? lookupNode(entry.value.id)\n    : typedefNode(mapLookupToTypedef(entry))\n}\n\nexport function singleValueEntryPoint(value: number): EntryPoint {\n  return {\n    args: voidEntryPointNode,\n    values: lookupNode(value),\n  }\n}\n\nexport function entryPointsAreCompatible(\n  descriptorEntry: EntryPoint,\n  getDescriptorNode: (id: number) => TypedefNode,\n  runtimeEntry: EntryPoint,\n  getRuntimeNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n) {\n  const resolveNode = (\n    node: EntryPointNode,\n    getTypedef: (id: number) => TypedefNode,\n  ): TypedefNode =>\n    node.type === \"lookup\" ? getTypedef(node.value) : node.value\n\n  // EntryPoint interaction \"origin -> dest\" is descriptor -> runtime for args, and runtime -> descriptor for values.\n  return {\n    args: isStaticCompatible(\n      resolveNode(descriptorEntry.args, getDescriptorNode),\n      getDescriptorNode,\n      resolveNode(runtimeEntry.args, getRuntimeNode),\n      getRuntimeNode,\n      cache,\n    ).level,\n    values: isStaticCompatible(\n      resolveNode(runtimeEntry.values, getRuntimeNode),\n      getRuntimeNode,\n      resolveNode(descriptorEntry.values, getDescriptorNode),\n      getDescriptorNode,\n      cache,\n    ).level,\n  }\n}\n\nexport function valueIsCompatibleWithDest(\n  dest: EntryPointNode,\n  getDestNode: (id: number) => TypedefNode,\n  value: unknown,\n) {\n  const node = dest.type === \"lookup\" ? getDestNode(dest.value) : dest.value\n  return isCompatible(value, node, getDestNode)\n}\n\nexport function mapEntryPointReferences(\n  entryPoint: EntryPoint,\n  mapFn: (id: number) => number,\n): EntryPoint {\n  const mapNode = (node: EntryPointNode) =>\n    node.type === \"lookup\"\n      ? lookupNode(mapFn(node.value))\n      : typedefNode(mapReferences(node.value, mapFn))\n\n  return {\n    args: mapNode(entryPoint.args),\n    values: mapNode(entryPoint.values),\n  }\n}\n", "export const noop = (): void => {}\n", "const chainHead = {\n  body: \"\",\n  call: \"\",\n  continue: \"\",\n  follow: \"\",\n  header: \"\",\n  stopOperation: \"\",\n  storage: \"\",\n  unfollow: \"\",\n  unpin: \"\",\n  followEvent: \"\",\n}\n\nconst chainSpec = {\n  chainName: \"\",\n  genesisHash: \"\",\n  properties: \"\",\n}\n\nconst transaction = {\n  broadcast: \"\",\n  stop: \"\",\n}\n\nObject.entries({ chainHead, chainSpec, transaction }).forEach(\n  ([fnGroupName, methods]) => {\n    Object.keys(methods).forEach((methodName) => {\n      ;(methods as any)[methodName] = `${fnGroupName}_v1_${methodName}`\n    })\n  },\n)\n\nexport { chainHead, transaction, chainSpec }\n", "import { noop } from \"@/internal-utils\"\nimport { type ClientRequest } from \"../client\"\nimport { transaction } from \"@/methods\"\n\nexport const getTransaction =\n  (request: ClientRequest<string, any>) =>\n  (tx: string, error: (e: Error) => void) => {\n    let cancel = request(transaction.broadcast, [tx], {\n      onSuccess: (subscriptionId) => {\n        cancel =\n          subscriptionId === null\n            ? noop\n            : () => {\n                request(transaction.stop, [subscriptionId])\n              }\n\n        if (subscriptionId === null) {\n          error(new Error(\"Max # of broadcasted transactions has been reached\"))\n        }\n      },\n      onError: error,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n", "export class StopError extends Error {\n  constructor() {\n    super(\"ChainHead stopped\")\n    this.name = \"StopError\"\n  }\n}\n\nexport class DisjointError extends Error {\n  constructor() {\n    super(\"ChainHead disjointed\")\n    this.name = \"DisjointError\"\n  }\n}\n\nexport class OperationLimitError extends Error {\n  constructor() {\n    super(\"ChainHead operations limit reached\")\n    this.name = \"OperationLimitError\"\n  }\n}\n\nexport class OperationError extends Error {\n  constructor(error: string) {\n    super(error)\n    this.name = \"OperationError\"\n  }\n}\n\nexport class OperationInaccessibleError extends Error {\n  constructor() {\n    super(\"ChainHead operation inaccessible\")\n    this.name = \"OperationInaccessibleError\"\n  }\n}\n", "export interface DeferredPromise<T> {\n  promise: Promise<T>\n  res: (value: T) => void\n  rej: (err: Error) => void\n}\n\nexport function deferred<T>(): DeferredPromise<T> {\n  let res: (value: T) => void = () => {}\n  let rej: (err: Error) => void = () => {}\n\n  const promise = new Promise<T>((_res, _rej) => {\n    res = _res\n    rej = _rej\n  })\n\n  return { promise, res, rej }\n}\n", "export interface Subscriber<T> {\n  next: (data: T) => void\n  error: (e: Error) => void\n}\n\nexport const getSubscriptionsManager = <T>() => {\n  const subscriptions = new Map<string, Subscriber<T>>()\n\n  return {\n    has: subscriptions.has.bind(subscriptions),\n    subscribe(id: string, subscriber: Subscriber<T>) {\n      subscriptions.set(id, subscriber)\n    },\n    unsubscribe(id: string) {\n      subscriptions.delete(id)\n    },\n    next(id: string, data: T) {\n      subscriptions.get(id)?.next(data)\n    },\n    error(id: string, e: Error) {\n      const subscriber = subscriptions.get(id)\n      if (subscriber) {\n        subscriptions.delete(id)\n        subscriber.error(e)\n      }\n    },\n    errorAll(e: Error) {\n      const subscribers = [...subscriptions.values()]\n      subscriptions.clear()\n      subscribers.forEach((s) => {\n        s.error(e)\n      })\n    },\n  }\n}\n\nexport type SubscriptionManager<T> = ReturnType<\n  typeof getSubscriptionsManager<T>\n>\n", "import { AbortError, noop } from \"@polkadot-api/utils\"\nimport { AbortablePromiseFn } from \"../common-types\"\n\nexport const abortablePromiseFn =\n  <T, A extends Array<any>>(\n    fn: (\n      ...args: [...[res: (x: T) => void, rej: (e: any) => void], ...A]\n    ) => () => void,\n  ): AbortablePromiseFn<A, T> =>\n  (...args): Promise<T> =>\n    new Promise((res, rej) => {\n      let cancel = noop\n\n      const [actualArgs, abortSignal] =\n        args[args.length - 1] instanceof AbortSignal\n          ? ([args.slice(0, args.length - 1), args[args.length - 1]] as [\n              A,\n              AbortSignal,\n            ])\n          : ([args] as unknown as [A])\n\n      const onAbort = () => {\n        cancel()\n        rej(new AbortError())\n      }\n\n      abortSignal?.addEventListener(\"abort\", onAbort, { once: true })\n\n      const withCleanup =\n        <T>(fn: (x: T) => void): ((x: T) => void) =>\n        (x) => {\n          cancel = noop\n          abortSignal?.removeEventListener(\"abort\", onAbort)\n          fn(x)\n        }\n\n      cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs])\n    })\n", "import { abortablePromiseFn, noop } from \"@/internal-utils\"\nimport {\n  CommonOperationEventsRpc,\n  OperationResponseRpc,\n} from \"./json-rpc-types\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\nimport { ClientInnerRequest } from \"./public-types\"\nimport { chainHead } from \"@/methods\"\n\nexport const createOperationPromise =\n  <I extends { operationId: string; event: string }, O, A extends Array<any>>(\n    operationName: string,\n    factory: (\n      ...args: A\n    ) => [\n      Array<any>,\n      (e: I, res: (x: O) => void, rej: (e: Error) => void) => void,\n    ],\n  ) =>\n  (\n    request: ClientInnerRequest<\n      OperationResponseRpc,\n      I | CommonOperationEventsRpc\n    >,\n  ) =>\n    abortablePromiseFn<O, A>((res, rej, ...args) => {\n      let isRunning = true\n      let cancel = () => {\n        isRunning = false\n      }\n\n      const [requestArgs, logicCb] = factory(...args)\n      request(operationName, requestArgs, {\n        onSuccess: (response, followSubscription) => {\n          if (response.result === \"limitReached\")\n            return rej(new OperationLimitError())\n\n          const { operationId } = response\n          const stopOperation = () => {\n            request(chainHead.stopOperation, [operationId])\n          }\n\n          if (!isRunning) return stopOperation()\n\n          let done = noop\n          const _res = (x: O) => {\n            isRunning = false\n            done()\n            res(x)\n          }\n          const _rej = (x: Error) => {\n            isRunning = false\n            done()\n            rej(x)\n          }\n\n          done = followSubscription(operationId, {\n            next: (e) => {\n              const _e = e as CommonOperationEventsRpc\n              if (_e.event === \"operationError\")\n                rej(new OperationError(_e.error))\n              else if (_e.event === \"operationInaccessible\")\n                rej(new OperationInaccessibleError())\n              else logicCb(e as I, _res, _rej)\n            },\n            error: _rej,\n          })\n\n          cancel = () => {\n            if (isRunning) {\n              done()\n              stopOperation()\n            }\n          }\n        },\n        onError: rej,\n      })\n\n      return () => {\n        cancel()\n      }\n    })\n", "import { chainHead } from \"@/methods\"\nimport type { OperationBodyDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createBodyFn = createOperationPromise(\n  chainHead.body,\n  (hash: string) => [\n    [hash],\n    (e: OperationBodyDoneRpc, res: (x: Array<string>) => void) => {\n      res(e.value)\n    },\n  ],\n)\n", "import { chainHead } from \"@/methods\"\nimport type { OperationCallDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createCallFn = createOperationPromise(\n  chainHead.call,\n  (hash: string, fnName: string, callParameters: string) => [\n    [hash, fnName, callParameters],\n    (e: OperationCallDoneRpc, res: (output: string) => void) => {\n      res(e.output)\n    },\n  ],\n)\n", "import { chainHead } from \"@/methods\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createHeaderFn =\n  (request: ClientInnerRequest<string, unknown>) => (hash: string) =>\n    new Promise<string>((res, rej) => {\n      request(chainHead.header, [hash], {\n        onSuccess: res,\n        onError: rej,\n      })\n    })\n", "import { noop } from \"@polkadot-api/utils\"\nimport type { ClientInnerRequest, FollowResponse } from \"./public-types\"\nimport {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { chainHead } from \"@/methods\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\n\nexport const createStorageCb =\n  (\n    request: ClientInnerRequest<\n      OperationStorageStartedRpc | LimitReachedRpc,\n      | CommonOperationEventsRpc\n      | OperationStorageItemsRpc\n      | OperationStorageDoneRpc\n      | OperationWaitingForContinueRpc\n    >,\n  ): FollowResponse[\"storageSubscription\"] =>\n  (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {\n    if (inputs.length === 0) {\n      onDone()\n      return noop\n    }\n\n    let isRunning = true\n    let cancel = () => {\n      isRunning = false\n    }\n\n    request(chainHead.storage, [hash, inputs, childTrie], {\n      onSuccess: (response, followSubscription) => {\n        if (\n          response.result === \"limitReached\" ||\n          response.discardedItems === inputs.length\n        )\n          return onError(new OperationLimitError())\n\n        const { operationId } = response\n        const stopOperation = () => {\n          request(chainHead.stopOperation, [operationId])\n        }\n\n        if (!isRunning) return stopOperation()\n\n        const doneListening = followSubscription(response.operationId, {\n          next: (event) => {\n            switch (event.event) {\n              case \"operationStorageItems\": {\n                onItems(event.items)\n                break\n              }\n              case \"operationStorageDone\": {\n                _onDone()\n                break\n              }\n              case \"operationError\": {\n                _onError(new OperationError(event.error))\n                break\n              }\n              case \"operationInaccessible\": {\n                _onError(new OperationInaccessibleError())\n                break\n              }\n              default:\n                request(chainHead.continue, [event.operationId])\n            }\n          },\n          error: onError,\n        })\n\n        cancel = () => {\n          doneListening()\n          request(chainHead.stopOperation, [response.operationId])\n        }\n\n        const _onError = (e: Error) => {\n          cancel = noop\n          doneListening()\n          onError(e)\n        }\n\n        const _onDone = () => {\n          cancel = noop\n          doneListening()\n          onDone()\n        }\n\n        onDiscardedItems(response.discardedItems)\n      },\n      onError,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n", "import { OperationLimitError } from \"./errors\"\nimport type {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { abortablePromiseFn } from \"@/internal-utils\"\nimport { createStorageCb } from \"./storage-subscription\"\nimport type { ClientInnerRequest, FollowResponse } from \"./public-types\"\n\nexport const createStorageFn = (\n  request: ClientInnerRequest<\n    OperationStorageStartedRpc | LimitReachedRpc,\n    | CommonOperationEventsRpc\n    | OperationStorageItemsRpc\n    | OperationStorageDoneRpc\n    | OperationWaitingForContinueRpc\n  >,\n): FollowResponse[\"storage\"] => {\n  const cbStore = createStorageCb(request)\n  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {\n    const isDescendants = type.startsWith(\"descendants\")\n    let result: any = isDescendants ? [] : null\n\n    const onItems: Parameters<typeof cbStore>[3] = isDescendants\n      ? (items) => {\n          result.push(items)\n        }\n      : (items) => {\n          result = items[0]?.[type as \"value\"]\n        }\n\n    const cancel = cbStore(\n      hash,\n      [{ key, type }],\n      childTrie ?? null,\n      onItems,\n      reject,\n      () => {\n        try {\n          resolve(isDescendants ? result.flat() : result)\n        } catch (e) {\n          reject(e)\n        }\n      },\n      (nDiscarded) => {\n        if (nDiscarded > 0) {\n          cancel()\n          reject(new OperationLimitError())\n        }\n      },\n    )\n    return cancel\n  })\n}\n", "import { chainHead } from \"@/methods\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createUnpinFn =\n  (request: ClientInnerRequest<null, unknown>) => (hashes: string[]) =>\n    hashes.length > 0\n      ? new Promise<void>((res, rej) => {\n          request(chainHead.unpin, [hashes], {\n            onSuccess() {\n              res()\n            },\n            onError: rej,\n          })\n        })\n      : Promise.resolve()\n", "export class DestroyedError extends Error {\n  constructor() {\n    super(\"Client destroyed\")\n    this.name = \"DestroyedError\"\n  }\n}\n", "import type { ClientRequest, FollowSubscriptionCb } from \"@/client\"\nimport type {\n  FollowEventWithRuntimeRpc,\n  FollowEventWithoutRuntimeRpc,\n  OperationEventsRpc,\n  StopRpc,\n} from \"./json-rpc-types\"\nimport type {\n  ChainHead,\n  ClientInnerRequest,\n  FollowEventWithoutRuntime,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"./public-types\"\nimport {\n  Subscriber,\n  getSubscriptionsManager,\n  noop,\n  deferred,\n} from \"@/internal-utils\"\nimport { createBodyFn } from \"./body\"\nimport { createCallFn } from \"./call\"\nimport { createHeaderFn } from \"./header\"\nimport { createStorageFn } from \"./storage\"\nimport { createUnpinFn } from \"./unpin\"\nimport { DisjointError, StopError } from \"./errors\"\nimport { createStorageCb } from \"./storage-subscription\"\nimport { DestroyedError } from \"@/client/DestroyedError\"\nimport { chainHead } from \"@/methods\"\n\ntype FollowEventRpc =\n  | FollowEventWithRuntimeRpc\n  | FollowEventWithoutRuntimeRpc\n  | OperationEventsRpc\n  | StopRpc\n\nfunction isOperationEvent(event: FollowEventRpc): event is OperationEventsRpc {\n  return (event as OperationEventsRpc).operationId !== undefined\n}\n\nexport function getChainHead(\n  request: ClientRequest<string, FollowEventRpc>,\n): ChainHead {\n  return (\n    withRuntime: boolean,\n    onFollowEvent:\n      | ((event: FollowEventWithoutRuntime) => void)\n      | ((event: FollowEventWithRuntime) => void),\n    onFollowError: (e: Error) => void,\n  ): FollowResponse => {\n    const subscriptions = getSubscriptionsManager<OperationEventsRpc>()\n\n    const ongoingRequests = new Set<() => void>()\n    const deferredFollow = deferred<string | Error>()\n    let followSubscription: Promise<string | Error> | string | null =\n      deferredFollow.promise\n\n    const onAllFollowEventsNext = (event: FollowEventRpc) => {\n      if (isOperationEvent(event)) {\n        if (!subscriptions.has(event.operationId))\n          console.warn(\"Uknown operationId on\", event)\n\n        return subscriptions.next(event.operationId, event)\n      }\n\n      if (event.event !== \"stop\") {\n        if (event.event === \"initialized\") {\n          return onFollowEvent({\n            type: event.event,\n            finalizedBlockHashes: event.finalizedBlockHashes,\n            finalizedBlockRuntime: (event as any).finalizedBlockRuntime,\n          })\n        }\n\n        const { event: type, ...rest } = event\n        // This is kinda dangerous, but YOLO\n        return onFollowEvent({ type, ...rest } as any)\n      }\n\n      onFollowError(new StopError())\n      unfollow(false)\n    }\n\n    const onAllFollowEventsError = (error: Error) => {\n      onFollowError(error)\n      unfollow(!(error instanceof DestroyedError))\n    }\n\n    const onFollowRequestSuccess = (\n      subscriptionId: string,\n      follow: FollowSubscriptionCb<FollowEventRpc>,\n    ) => {\n      const done = follow(subscriptionId, {\n        next: onAllFollowEventsNext,\n        error: onAllFollowEventsError,\n      })\n\n      unfollow = (sendUnfollow = true) => {\n        followSubscription = null\n        unfollow = noop\n        done()\n        sendUnfollow && request(chainHead.unfollow, [subscriptionId])\n        subscriptions.errorAll(new DisjointError())\n        ongoingRequests.forEach((cb) => {\n          cb()\n        })\n        ongoingRequests.clear()\n      }\n\n      followSubscription = subscriptionId\n      deferredFollow.res(subscriptionId)\n    }\n\n    const onFollowRequestError = (e: Error) => {\n      if (e instanceof DestroyedError) {\n        unfollow(false)\n      } else {\n        onFollowError(e)\n      }\n      followSubscription = null\n      deferredFollow.res(e)\n    }\n\n    let unfollow: (internal?: boolean) => void = request(\n      chainHead.follow,\n      [withRuntime],\n      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError },\n    )\n\n    const fRequest: ClientInnerRequest<any, any> = (method, params, cb) => {\n      const disjoint = () => {\n        cb?.onError(new DisjointError())\n      }\n\n      if (followSubscription === null) {\n        disjoint()\n        return noop\n      }\n\n      const onSubscription = (subscription: string) => {\n        if (!cb) return request(method, [subscription, ...params])\n\n        ongoingRequests.add(disjoint)\n\n        const onSubscribeOperation = (\n          operationId: string,\n          subscriber: Subscriber<any>,\n        ) => {\n          if (followSubscription === null) {\n            subscriber.error(new DisjointError())\n            return noop\n          }\n\n          subscriptions.subscribe(operationId, subscriber)\n\n          return () => {\n            subscriptions.unsubscribe(operationId)\n          }\n        }\n\n        const cleanup = request(method, [subscription, ...params], {\n          onSuccess: (response) => {\n            ongoingRequests.delete(disjoint)\n            cb.onSuccess(response, onSubscribeOperation)\n          },\n          onError: (e) => {\n            ongoingRequests.delete(disjoint)\n            cb.onError(e)\n          },\n        })\n\n        return () => {\n          ongoingRequests.delete(disjoint)\n          cleanup()\n        }\n      }\n\n      if (typeof followSubscription === \"string\")\n        return onSubscription(followSubscription)\n\n      let onCancel = noop\n      followSubscription.then((x) => {\n        if (x instanceof Error) return disjoint()\n        if (followSubscription) onCancel = onSubscription(x)\n      })\n\n      return () => {\n        onCancel()\n      }\n    }\n\n    return {\n      unfollow() {\n        unfollow()\n        followSubscription = null\n      },\n      body: createBodyFn(fRequest),\n      call: createCallFn(fRequest),\n      header: createHeaderFn(fRequest),\n      storage: createStorageFn(fRequest),\n      storageSubscription: createStorageCb(fRequest),\n      unpin: createUnpinFn(fRequest),\n      _request: fRequest,\n    }\n  }\n}\n", "export interface IRpcError {\n  code: number\n  message: string\n  data?: any\n}\n\nexport class RpcError extends Error implements IRpcError {\n  code\n  data\n  constructor(e: IRpcError) {\n    super(e.message)\n    this.code = e.code\n    this.data = e.data\n    this.name = \"RpcError\"\n  }\n}\n", "import type {\n  JsonRpcConnection,\n  JsonRpcProvider,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { UnsubscribeFn } from \"../common-types\"\nimport { RpcError, IRpcError } from \"./RpcError\"\nimport { getSubscriptionsManager, Subscriber } from \"@/internal-utils\"\nimport { DestroyedError } from \"./DestroyedError\"\n\nexport type FollowSubscriptionCb<T> = (\n  subscriptionId: string,\n  cb: Subscriber<T>,\n) => UnsubscribeFn\n\nexport type ClientRequestCb<T, TT> = {\n  onSuccess: (result: T, followSubscription: FollowSubscriptionCb<TT>) => void\n  onError: (e: Error) => void\n}\n\nexport type ClientRequest<T, TT> = (\n  method: string,\n  params: Array<any>,\n  cb?: ClientRequestCb<T, TT>,\n) => UnsubscribeFn\n\nexport interface Client {\n  disconnect: () => void\n  request: ClientRequest<any, any>\n}\n\nlet nextClientId = 1\nexport const createClient = (gProvider: JsonRpcProvider): Client => {\n  let clientId = nextClientId++\n  const responses = new Map<string, ClientRequestCb<any, any>>()\n  const subscriptions = getSubscriptionsManager()\n\n  let connection: JsonRpcConnection | null = null\n\n  const send = (\n    id: string,\n    method: string,\n    params: Array<boolean | string | number | null>,\n  ) => {\n    connection!.send(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method,\n        params,\n      }),\n    )\n  }\n\n  function onMessage(message: string): void {\n    try {\n      let id: string,\n        result,\n        error: IRpcError | undefined,\n        params: { subscription: any; result: any; error?: IRpcError },\n        subscription: string\n\n      const parsed = JSON.parse(message)\n      ;({ id, result, error, params } = parsed)\n\n      if (id) {\n        const cb = responses.get(id)\n        if (!cb) return\n\n        responses.delete(id)\n\n        return error\n          ? cb.onError(new RpcError(error))\n          : cb.onSuccess(result, (opaqueId, subscriber) => {\n              const subscriptionId = opaqueId\n              subscriptions.subscribe(subscriptionId, subscriber)\n              return () => {\n                subscriptions.unsubscribe(subscriptionId)\n              }\n            })\n      }\n\n      // at this point, it means that it should be a notification\n      ;({ subscription, result, error } = params)\n      if (!subscription || (!error && !Object.hasOwn(params, \"result\"))) throw 0\n\n      const subscriptionId = subscription\n\n      if (error) {\n        subscriptions.error(subscriptionId, new RpcError(error!))\n      } else {\n        subscriptions.next(subscriptionId, result)\n      }\n    } catch (e) {\n      console.warn(\"Error parsing incomming message: \" + message)\n      console.error(e)\n    }\n  }\n  connection = gProvider(onMessage)\n\n  const disconnect = () => {\n    connection?.disconnect()\n    connection = null\n    subscriptions.errorAll(new DestroyedError())\n    responses.forEach((r) => r.onError(new DestroyedError()))\n    responses.clear()\n  }\n\n  let nextId = 1\n  const request = <T, TT>(\n    method: string,\n    params: Array<any>,\n    cb?: ClientRequestCb<T, TT>,\n  ): UnsubscribeFn => {\n    if (!connection) throw new Error(\"Not connected\")\n    const id = `${clientId}-${nextId++}`\n\n    if (cb) responses.set(id, cb)\n    send(id, method, params)\n\n    return (): void => {\n      responses.delete(id)\n    }\n  }\n\n  return {\n    request,\n    disconnect,\n  }\n}\n", "import { ClientRequest } from \"./client\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { chainSpec } from \"./methods\"\n\nexport interface ChainSpecData {\n  name: string\n  genesisHash: string\n  properties: any\n}\n\nexport const createGetChainSpec = (clientRequest: ClientRequest<any, any>) => {\n  const request = abortablePromiseFn(\n    <T>(\n      onSuccess: (value: T) => void,\n      onError: (e: any) => void,\n      method: string,\n      params: any[],\n    ) => clientRequest(method, params, { onSuccess, onError }),\n  )\n  let cachedPromise: null | Promise<ChainSpecData> = null\n\n  return async (): Promise<ChainSpecData> => {\n    if (cachedPromise) return cachedPromise\n    return (cachedPromise = Promise.all([\n      request<string>(chainSpec.chainName, []),\n      request<string>(chainSpec.genesisHash, []),\n      request<any>(chainSpec.properties, []),\n    ]).then(([name, genesisHash, properties]) => ({\n      name,\n      genesisHash,\n      properties,\n    })))\n  }\n}\n", "import type { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport { getTransaction } from \"./transaction/transaction\"\nimport { getChainHead } from \"./chainhead\"\nimport { ClientRequestCb, createClient as createRawClient } from \"./client\"\nimport type { ChainHead } from \"./chainhead\"\nimport type { Transaction } from \"./transaction\"\nimport { UnsubscribeFn } from \"./common-types\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { ChainSpecData, createGetChainSpec } from \"./chainspec\"\n\nexport { AbortError } from \"@polkadot-api/utils\"\nexport type * from \"@polkadot-api/json-rpc-provider\"\n\nexport type * from \"./common-types\"\nexport type * from \"./client\"\nexport type * from \"./transaction\"\nexport type * from \"./chainhead\"\nexport type * from \"./chainspec\"\n\nexport { RpcError, DestroyedError } from \"./client\"\nexport {\n  StopError,\n  DisjointError,\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./chainhead\"\n\nexport interface SubstrateClient {\n  chainHead: ChainHead\n  transaction: Transaction\n  destroy: UnsubscribeFn\n  getChainSpecData: () => Promise<ChainSpecData>\n  request: <T>(\n    method: string,\n    params: any[],\n    abortSignal?: AbortSignal,\n  ) => Promise<T>\n  _request: <Reply, Notification>(\n    method: string,\n    params: any[],\n    cb?: ClientRequestCb<Reply, Notification>,\n  ) => UnsubscribeFn\n}\n\nconst clientCache = new Map<\n  JsonRpcProvider,\n  { client: SubstrateClient; refCount: number }\n>()\n\nexport const createClient = (provider: JsonRpcProvider): SubstrateClient => {\n  const cached = clientCache.get(provider)\n  if (cached) {\n    cached.refCount++\n    return cached.client\n  }\n\n  const { request, disconnect } = createRawClient(provider)\n  const destroy = () => {\n    const cached = clientCache.get(provider)\n    if (!cached || cached.refCount <= 1) {\n      clientCache.delete(provider)\n      disconnect()\n    } else {\n      cached.refCount--\n    }\n  }\n  const client: SubstrateClient = {\n    chainHead: getChainHead(request),\n    transaction: getTransaction(request),\n    getChainSpecData: createGetChainSpec(request),\n    destroy,\n    request: abortablePromiseFn(\n      <T>(\n        onSuccess: (value: T) => void,\n        onError: (e: any) => void,\n        method: string,\n        params: any[],\n      ) => request(method, params, { onSuccess, onError }),\n    ),\n    _request: request,\n  }\n  clientCache.set(provider, { client, refCount: 1 })\n  return client\n}\n", "import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    let isOperationLimit = false\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        ;(isOperationLimit = e instanceof OperationLimitError)\n          ? addTask(data, true)\n          : observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    if (!subscription.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n        onEmptySlot()\n      })\n    } else if (!isOperationLimit) onEmptySlot()\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n", "export class BlockNotPinnedError extends Error {\n  constructor(hash: string, label: string) {\n    super(`Block ${hash} is not pinned (${label})`)\n    this.name = \"BlockNotPinnedError\"\n  }\n}\n", "import {\n  MonoTypeOperatorFunction,\n  Observable,\n  catchError,\n  concatMap,\n  mergeMap,\n  take,\n  throwError,\n  timer,\n} from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\n\nconst dynamicBlocks = new Set([\"best\", \"finalized\", null])\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const getWithOptionalhash$ = (\n  finalized$: Observable<string>,\n  best$: Observable<string>,\n  usingBlock: <T>(blockHash: string) => MonoTypeOperatorFunction<T>,\n) => {\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) => {\n      if (!dynamicBlocks.has(hash))\n        return operable(fn(hash as string, ...args)).pipe(\n          usingBlock(hash as string),\n        )\n\n      const hash$ = hash === \"best\" ? best$ : finalized$\n      const result$: Observable<T> = hash$.pipe(\n        take(1),\n        mergeMap((h) => fn(h, ...args).pipe(usingBlock(h))),\n        catchError((e) => {\n          return e instanceof BlockNotPinnedError\n            ? result$\n            : throwError(() => e)\n        }),\n      )\n      return operable(result$)\n    }\n}\n", "import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n", "import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n", "import { Observable, ObservedValueOf, Subscription } from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { PinnedBlocks } from \"../streams\"\n\nexport function withStopRecovery<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n  label: string,\n) {\n  return (hash: string, ...args: A) => {\n    const source$ = fn(hash, ...args)\n\n    return new Observable<ObservedValueOf<typeof source$>>((observer) => {\n      let sourceSub: Subscription | null = null\n      let isSubscribed = false\n      const performSourceSub = () => {\n        if (isSubscribed) return\n        isSubscribed = true\n        sourceSub = source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => observer.error(e),\n          complete: () => observer.complete(),\n        })\n        sourceSub.add(() => {\n          isSubscribed = false\n          sourceSub = null\n        })\n      }\n\n      let isRecovering = false\n      const blockSub = blocks$.subscribe({\n        next: (v) => {\n          const block = v.blocks.get(hash)\n          if (!block) {\n            // This branch used to conflict with BlockPrunedError, as the block might disappear when it gets pruned\n            // We can avoid this conflict by checking that we're actually recovering.\n            if (isRecovering) {\n              observer.error(new BlockNotPinnedError(hash, label))\n            }\n          } else if (block.recovering) {\n            // Pause while it's recovering, as we don't know if the block is there\n            sourceSub?.unsubscribe()\n          } else {\n            performSourceSub()\n          }\n          isRecovering = v.recovering\n        },\n        error: (e) => observer.error(e),\n      })\n\n      return () => {\n        blockSub.unsubscribe()\n        sourceSub?.unsubscribe()\n      }\n    })\n  }\n}\n", "import { mergeMap, Observable, scan, share } from \"rxjs\"\nimport { BlockInfo } from \"./chainHead\"\nimport { PinnedBlocks } from \"./streams\"\n\nexport const getNewBlocks$ = (pinnedBlocks$: Observable<PinnedBlocks>) =>\n  pinnedBlocks$.pipe(\n    scan(\n      ({ reportedBlocks: prevReportedBlocks }, { blocks }) => {\n        const reportedBlocks = new Set<string>(blocks.keys())\n        const newBlocks: BlockInfo[] = []\n\n        if (reportedBlocks.size > prevReportedBlocks.size) {\n          blocks.forEach(({ hash, number, parent }) => {\n            if (!prevReportedBlocks.has(hash)) {\n              newBlocks.push({\n                hash,\n                number,\n                parent,\n              })\n            }\n          })\n        }\n\n        return { reportedBlocks, newBlocks }\n      },\n      {\n        reportedBlocks: new Set<string>(),\n        newBlocks: new Array<BlockInfo>(0),\n      },\n    ),\n    mergeMap(({ newBlocks }) => newBlocks),\n    share(),\n  )\n", "import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            // TODO: leave it like this b/c due to a bug on\n            // PolkadotSDK sometimes this value is `undefined`\n            // https://github.com/paritytech/polkadot-sdk/issues/6683\n            if (nDiscarded > 0)\n              observer.next(\n                recoveralStorage$(\n                  hash,\n                  queries.slice(-nDiscarded),\n                  childTrie,\n                  true,\n                ),\n              )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n", "import { BlockHeader, blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n  StopError,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ObservedValueOf,\n  Subscription,\n  concatMap,\n  connectable,\n  noop,\n  of,\n} from \"rxjs\"\n\nconst withInitializedNumber =\n  (getHeader: (hash: string) => Promise<BlockHeader>) =>\n  (source$: Observable<FollowEventWithRuntime>) =>\n    source$.pipe(\n      concatMap((event) => {\n        return event.type !== \"initialized\"\n          ? of(event)\n          : getHeader(event.finalizedBlockHashes[0]).then((header) => ({\n              ...event,\n              number: header.number,\n              parentHash: header.parentHash,\n            }))\n      }),\n    )\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse | null = null\n  let unfollow: () => void = noop\n\n  const getFollower = () => {\n    if (!follower) throw new Error(\"Missing chainHead subscription\")\n    return follower\n  }\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const follow$ = connectable(\n    new Observable<FollowEventWithRuntime>((observer) => {\n      follower = chainHead(\n        true,\n        (e) => {\n          observer.next(e)\n        },\n        (e) => {\n          follower = null\n          observer.error(e)\n        },\n      )\n      unfollow = () => {\n        observer.complete()\n        follower?.unfollow()\n      }\n    }).pipe(withInitializedNumber(getHeader), retryChainHeadError()),\n  )\n\n  const startFollow = () => {\n    follow$.connect()\n    return () => {\n      unfollow()\n    }\n  }\n\n  return {\n    getHeader,\n    getFollower,\n    startFollow,\n    follow$,\n  }\n}\n\nconst retryChainHeadError =\n  <T extends { type: string }>() =>\n  (source$: Observable<T>) =>\n    new Observable<\n      | T\n      | {\n          type: \"stop-error\"\n        }\n    >((observer) => {\n      const subscription = new Subscription()\n      const subscribe = () =>\n        source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => {\n            subscription.add(subscribe())\n            if (e instanceof StopError) {\n              observer.next({ type: \"stop-error\" })\n            } else {\n              console.warn(\"ChainHead follow request failed, retrying\", e)\n            }\n          },\n          complete: () => observer.complete(),\n        })\n      subscription.add(subscribe())\n      return subscription\n    })\n\nexport type FollowEvent =\n  | ObservedValueOf<ReturnType<ReturnType<typeof withInitializedNumber>>>\n  | { type: \"stop-error\" }\n", "import type {\n  StringRecord,\n  V14,\n  V14Lookup,\n  V15,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport type SignedPrimitive = \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"i128\" | \"i256\"\nexport type UnsignedPrimitive = \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"u256\"\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | SignedPrimitive\n  | UnsignedPrimitive\n\nexport type PrimitiveVar = {\n  type: \"primitive\"\n  value: MetadataPrimitives\n}\n\nexport type VoidVar = { type: \"void\" }\nexport type CompactVar = {\n  type: \"compact\"\n  isBig: boolean\n  size: UnsignedPrimitive\n}\nexport type BitSequenceVar = { type: \"bitSequence\" }\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type AccountId20 = { type: \"AccountId20\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | VoidVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n  | AccountId20\n\n/* Array-like vars:\n * - TupleVar: Mixed types, fixed length\n * - Sequence: One type, arbitrary length\n * - Array: One type, fixed length\n */\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<\n    (\n      | { type: \"lookupEntry\"; value: LookupEntry }\n      | VoidVar\n      | TupleVar\n      | StructVar\n      | ArrayVar\n    ) & { idx: number }\n  >\n  innerDocs: StringRecord<string[]>\n  byteLength?: number\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nconst isBytes = (value: LookupEntry, nBytes: number) =>\n  value.type === \"array\" &&\n  value.len === nBytes &&\n  value.value.type === \"primitive\" &&\n  value.value.value === \"u8\"\n\nconst _void: VoidVar = { type: \"void\" }\n\nexport interface MetadataLookup {\n  (id: number): LookupEntry\n  metadata: V14 | V15\n  call: number | null\n}\n\nconst _denormalizeLookup = (\n  lookupData: V14Lookup,\n  customMap: (value: V14Lookup[number]) => Var | null = () => null,\n): ((id: number) => LookupEntry) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  let isAccountId20SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const custom = customMap(lookupData[id])\n    if (custom) return custom\n\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return _void\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        const inner = getLookupEntryDef(def.value[0].type as number)\n\n        if (\n          isAccountId32SearchOn &&\n          path.at(-1) === \"AccountId32\" &&\n          isBytes(inner, 32)\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n\n        if (\n          isAccountId20SearchOn &&\n          path.at(-1) === \"AccountId20\" &&\n          isBytes(inner, 20)\n        ) {\n          isAccountId20SearchOn = false\n          return { type: \"AccountId20\" }\n        }\n\n        return inner\n      }\n\n      return getComplexVar(def.value)\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"void\"\n          ? // Option<void> would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return _void\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ..._void, idx: x.index }\n          return\n        }\n\n        if (x.fields.length === 1 && !x.fields[0].name) {\n          enumValue[key] = {\n            type: \"lookupEntry\",\n            value: getLookupEntryDef(x.fields[0].type),\n            idx: x.index,\n          }\n          return\n        }\n\n        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\")\n      return {\n        type: \"sequence\",\n        value: getLookupEntryDef(def.value as number),\n      }\n\n    if (def.tag === \"array\") {\n      const { len } = def.value\n      const value = getLookupEntryDef(def.value.type)\n\n      return !len || value.type === \"void\"\n        ? _void\n        : len > 1\n          ? {\n              type: \"array\",\n              value,\n              len: def.value.len,\n            }\n          : value\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return _void\n\n      return def.value.length > 1\n        ? getArrayOrTuple(\n            def.value.map((x) => getLookupEntryDef(x as number)),\n            def.value.map((x) => lookupData[x].docs),\n          )\n        : getLookupEntryDef(def.value[0] as number) // use to be a \"pointer\"\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value) as PrimitiveVar | VoidVar\n      if (translated.type === \"void\") return _void\n\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n        size: translated.value as UnsignedPrimitive,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n    }\n  })\n\n  const getComplexVar = (\n    input: Array<{ type: number; name?: string; docs: string[] }>,\n  ): TupleVar | StructVar | ArrayVar | VoidVar => {\n    let allKey = true\n\n    const values: Record<string | number, LookupEntry> = {}\n    const innerDocs: Record<string | number, string[]> = {}\n\n    input.forEach((x, idx) => {\n      allKey = allKey && !!x.name\n      const key = x.name || idx\n      const value = getLookupEntryDef(x.type as number)\n      if (value.type !== \"void\") {\n        values[key] = value\n        innerDocs[key] = x.docs\n      }\n    })\n    return allKey\n      ? {\n          type: \"struct\",\n          value: values as StringRecord<LookupEntry>,\n          innerDocs: innerDocs as StringRecord<string[]>,\n        }\n      : getArrayOrTuple(Object.values(values), Object.values(innerDocs))\n  }\n\n  const getArrayOrTuple = (\n    values: Array<LookupEntry>,\n    innerDocs: Array<string[]>,\n  ): TupleVar | ArrayVar | VoidVar => {\n    if (\n      values.every((v) => v.id === values[0].id) &&\n      innerDocs.every((doc) => !doc.length)\n    ) {\n      const [value] = values\n      return value.type === \"void\"\n        ? _void\n        : {\n            type: \"array\",\n            value: values[0],\n            len: values.length,\n          }\n    }\n    return {\n      type: \"tuple\",\n      value: values,\n      innerDocs: innerDocs,\n    }\n  }\n\n  return getLookupEntryDef\n}\n\nexport const denormalizeLookup = (lookupData: V14Lookup) =>\n  _denormalizeLookup(lookupData)\n\nexport const getLookupFn = (metadata: V14 | V15): MetadataLookup => {\n  const getLookupEntryDef = _denormalizeLookup(metadata.lookup, ({ def }) => {\n    if (def.tag === \"composite\") {\n      const moduleErrorLength = getModuleErrorLength(def)\n      if (moduleErrorLength) {\n        return {\n          type: \"enum\",\n          innerDocs: {},\n          value: Object.fromEntries(\n            metadata.pallets.map((p) => [\n              p.name,\n              p.errors == null\n                ? { ..._void, idx: p.index }\n                : {\n                    type: \"lookupEntry\" as const,\n                    value: getLookupEntryDef(p.errors),\n                    idx: p.index,\n                  },\n            ]),\n          ) as StringRecord<\n            (\n              | VoidVar\n              | {\n                  type: \"lookupEntry\"\n                  value: LookupEntry\n                }\n            ) & { idx: number }\n          >,\n          byteLength: moduleErrorLength,\n        }\n      }\n    }\n    return null\n  })\n\n  function getModuleErrorLength(def: {\n    tag: \"composite\"\n    value: {\n      name: string | undefined\n      type: number\n      typeName: string | undefined\n      docs: string[]\n    }[]\n  }) {\n    const preChecks =\n      def.value.length === 2 &&\n      def.value[0].name === \"index\" &&\n      def.value[1].name === \"error\"\n    if (!preChecks) return null\n\n    const index = getLookupEntryDef(def.value[0].type)\n    const error = getLookupEntryDef(def.value[1].type)\n\n    return index.type === \"primitive\" &&\n      index.value === \"u8\" &&\n      error.type === \"array\" &&\n      error.value.type === \"primitive\" &&\n      error.value.value === \"u8\"\n      ? 1 + error.len\n      : null\n  }\n\n  const getCall = () => {\n    if (\"outerEnums\" in metadata) {\n      return metadata.outerEnums.call\n    }\n\n    const extrinsic = metadata.lookup[metadata.extrinsic?.type]\n    const call = extrinsic?.params.find((p) => p.name === \"Call\")\n\n    return call?.type ?? null\n  }\n\n  return Object.assign(getLookupEntryDef, { metadata, call: getCall() })\n}\n", "import { LookupEntry } from \"./lookups\"\n\ntype FnWithStack<Other extends Array<any>, T> = (\n  input: LookupEntry,\n  cache: Map<number, T>,\n  stack: Set<number>,\n  ...rest: Other\n) => T\n\nexport const withCache =\n  <Other extends Array<any>, T>(\n    fn: FnWithStack<Other, T>,\n    onEnterCircular: (\n      cacheGetter: () => T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n    onExitCircular: (\n      outter: T,\n      inner: T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n  ): FnWithStack<Other, T> =>\n  (input, cache, stack, ...rest) => {\n    const { id } = input\n    if (cache.has(id)) return cache.get(id)!\n\n    if (stack.has(id)) {\n      const res = onEnterCircular(() => cache.get(id)!, input, ...rest)\n      cache.set(id, res)\n      return res\n    }\n\n    stack.add(id)\n    let result = fn(input, cache, stack, ...rest)\n    stack.delete(id)\n\n    if (cache.has(id))\n      result = onExitCircular(result, cache.get(id)!, input, ...rest)\n\n    cache.set(id, result)\n    return result\n  }\n", "import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport type { LookupEntry } from \"./lookups\"\nimport { withCache } from \"./with-cache\"\n\nconst _bytes = scale.Bin()\n\nconst _buildCodec = (\n  input: LookupEntry,\n  cache: Map<number, Codec<any>>,\n  stack: Set<number>,\n  _accountId: Codec<scale.SS58String>,\n): Codec<any> => {\n  if (input.type === \"primitive\") return scale[input.value]\n  if (input.type === \"void\") return scale._void\n  if (input.type === \"AccountId32\") return _accountId\n  if (input.type === \"AccountId20\") return scale.ethAccount\n  if (input.type === \"compact\")\n    return input.isBig ? scale.compactBn : scale.compactNumber\n  if (input.type === \"bitSequence\") return scale.bitSequence\n\n  const buildNextCodec = (nextInput: LookupEntry): Codec<any> =>\n    buildCodec(nextInput, cache, stack, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerCodec = buildNextCodec(inner)\n    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec)\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    scale.Tuple(...value.map(buildNextCodec))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    const inner = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, buildNextCodec(value)]),\n    ) as StringRecord<Codec<any>>\n    return scale.Struct(inner)\n  }\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return _bytes\n  }\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\")\n      return scale.Bin(input.len)\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\") return scale.Option(buildNextCodec(input.value))\n\n  if (input.type === \"result\")\n    return scale.Result(\n      buildNextCodec(input.value.ok),\n      buildNextCodec(input.value.ko),\n    )\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    switch (v.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildNextCodec(v.value)\n      case \"tuple\":\n        return buildTuple(v.value)\n      case \"struct\":\n        return buildStruct(v.value)\n      case \"array\":\n        return buildVector(v.value, v.len)\n    }\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => {\n      return [key, dependencies[idx]]\n    }),\n  ) as StringRecord<Codec<any>>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  const variantCodec = areIndexesSorted\n    ? scale.Variant(inner)\n    : scale.Variant(inner, indexes as any)\n  return input.byteLength\n    ? fixedSizeCodec(variantCodec, input.byteLength)\n    : variantCodec\n}\nconst buildCodec = withCache(_buildCodec, scale.Self, (res) => res)\n\nexport const getLookupCodecBuilder = (\n  lookup: (id: number) => LookupEntry,\n  accountId = scale.AccountId(),\n) => {\n  const cache = new Map()\n  const buildDefinition = (id: number) =>\n    buildCodec(lookup(id), cache, new Set(), accountId)\n\n  return (id: number) => buildDefinition(id)\n}\n\nconst fixedSizeCodec = <T>(codec: Codec<T>, size: number): Codec<T> => {\n  const allBytes = scale.Bytes(size)\n  return scale.createCodec<T>(\n    (value: T) => allBytes.enc(codec.enc(value)),\n    (data) => codec.dec(allBytes.dec(data)),\n  )\n}\n", "import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport type { EnumVar, MetadataLookup } from \"./lookups\"\nimport { getLookupCodecBuilder } from \"./lookup-codec-builder\"\n\nexport const getDynamicBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        buildDefinition = getLookupCodecBuilder(\n          getLookupEntryDef,\n          scale.AccountId(prefixVal),\n        )\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    const storageWithFallback = (\n      len: number,\n      value: Codec<any>,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const keys = storagePallet!(...args)\n      const [, ...encodersWithHash] = args\n      return {\n        args: scale.Tuple(...encodersWithHash.map(([codec]) => codec)),\n        keys,\n        value,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? value.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        buildDefinition(storageEntry.type.value),\n        entry,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = buildDefinition(value)\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: scale.EncoderWithHash<unknown>[] = (() => {\n      if (hashes.length === 1) {\n        return [[buildDefinition(key), hashes[0]]]\n      }\n\n      const keyDef = getLookupEntryDef(key)\n\n      switch (keyDef.type) {\n        case \"array\":\n          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash])\n        case \"tuple\":\n          return keyDef.value.map((x, idx) => [\n            buildDefinition(x.id),\n            hashes[idx],\n          ])\n        default:\n          throw new Error(\"Invalid key type\")\n      }\n    })()\n\n    return storageWithFallback(hashes.length, val, entry, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    switch (entry.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildDefinition(entry.value.id)\n      case \"tuple\":\n        return scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      case \"struct\":\n        return scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n      case \"array\":\n        return scale.Vector(buildDefinition(entry.value.id), entry.len)\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildRuntimeCall,\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    ss58Prefix,\n  }\n}\n", "import type { StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport { h64 } from \"@polkadot-api/substrate-bindings\"\nimport {\n  LookupGraph,\n  buildLookupGraph,\n  getStronglyConnectedComponents,\n  getSubgraph,\n  mergeSCCsWithCommonNodes,\n} from \"./lookup-graph\"\nimport {\n  ArrayVar,\n  LookupEntry,\n  MetadataLookup,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n  VoidVar,\n} from \"./lookups\"\n\nconst textEncoder = new TextEncoder()\nconst encodeText = textEncoder.encode.bind(textEncoder)\n\nconst getChecksum = (values: Array<bigint>) => {\n  const res = new Uint8Array(values.length * 8)\n  const dv = new DataView(res.buffer)\n\n  for (let i = 0; i < values.length; i++) dv.setBigUint64(i * 8, values[i])\n\n  return h64(res)\n}\nconst getStringChecksum = (values: Array<string>) =>\n  getChecksum(values.map((v) => h64(encodeText(v))))\n\ntype Shape =\n  | \"primitive\"\n  | \"void\"\n  | \"vector\"\n  | \"tuple\"\n  | \"struct\"\n  | \"option\"\n  | \"result\"\n  | \"enum\"\nconst shapeIds: Record<Shape, bigint> = {\n  primitive: 0n,\n  vector: 1n,\n  tuple: 2n,\n  struct: 3n,\n  option: 4n,\n  result: 5n,\n  enum: 6n,\n  void: 7n,\n}\n\ntype RuntimePrimitives =\n  | \"undefined\"\n  | \"number\"\n  | \"string\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"bitSequence\"\n  | \"byteSequence\"\n  | \"accountId32\"\n  | \"accountId20\"\n\nconst runtimePrimitiveIds: Record<RuntimePrimitives, bigint> = {\n  undefined: 0n,\n  number: 1n,\n  string: 2n,\n  bigint: 3n,\n  boolean: 4n,\n  bitSequence: 5n, // {bitsLen: number, bytes: Uint8Array}\n  byteSequence: 6n, // Binary\n  accountId32: 7n, // SS58String\n  accountId20: 8n, // EthAccount\n}\n\nconst metadataPrimitiveIds: Record<MetadataPrimitives, bigint> = {\n  bool: runtimePrimitiveIds.boolean,\n  char: runtimePrimitiveIds.string,\n  str: runtimePrimitiveIds.string,\n  u8: runtimePrimitiveIds.number,\n  u16: runtimePrimitiveIds.number,\n  u32: runtimePrimitiveIds.number,\n  u64: runtimePrimitiveIds.bigint,\n  u128: runtimePrimitiveIds.bigint,\n  u256: runtimePrimitiveIds.bigint,\n  i8: runtimePrimitiveIds.number,\n  i16: runtimePrimitiveIds.number,\n  i32: runtimePrimitiveIds.number,\n  i64: runtimePrimitiveIds.bigint,\n  i128: runtimePrimitiveIds.bigint,\n  i256: runtimePrimitiveIds.bigint,\n}\n\nconst structLikeBuilder = <T>(\n  shapeId: bigint,\n  input: StringRecord<T>,\n  innerChecksum: (value: T) => bigint,\n) => {\n  const sortedEntries = Object.entries(input).sort(([a], [b]) =>\n    a.localeCompare(b),\n  )\n  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key))\n  const valuesChecksum = getChecksum(\n    sortedEntries.map(([, entry]) => innerChecksum(entry)),\n  )\n\n  return getChecksum([shapeId, keysChecksum, valuesChecksum])\n}\n\nconst _buildChecksum = (\n  input: LookupEntry,\n  buildNextChecksum: (entry: LookupEntry) => bigint,\n): bigint => {\n  if (input.type === \"primitive\")\n    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]])\n\n  if (input.type === \"void\") return getChecksum([shapeIds.void])\n\n  if (input.type === \"compact\")\n    return getChecksum([\n      shapeIds.primitive,\n      runtimePrimitiveIds[input.isBig ? \"bigint\" : \"number\"],\n    ])\n\n  if (input.type === \"bitSequence\")\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence])\n\n  if (input.type === \"AccountId32\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId32])\n  }\n\n  if (input.type === \"AccountId20\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId20])\n  }\n\n  const buildVector = (entry: LookupEntry, length?: number) => {\n    const innerChecksum = buildNextChecksum(entry)\n    return getChecksum(\n      length !== undefined\n        ? [shapeIds.vector, innerChecksum, BigInt(length)]\n        : [shapeIds.vector, innerChecksum],\n    )\n  }\n\n  if (input.type === \"array\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([\n        shapeIds.primitive,\n        runtimePrimitiveIds.byteSequence,\n        BigInt(input.len),\n      ])\n    }\n    return buildVector(innerValue, input.len)\n  }\n\n  if (input.type === \"sequence\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence])\n    }\n    return buildVector(innerValue)\n  }\n\n  const buildTuple = (entries: LookupEntry[]) =>\n    getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)])\n\n  const buildStruct = (entries: StringRecord<LookupEntry>) =>\n    structLikeBuilder(shapeIds.struct, entries, buildNextChecksum)\n\n  if (input.type === \"tuple\") return buildTuple(input.value)\n\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\")\n    return getChecksum([shapeIds.option, buildNextChecksum(input.value)])\n\n  if (input.type === \"result\")\n    return getChecksum([\n      shapeIds.result,\n      buildNextChecksum(input.value.ok),\n      buildNextChecksum(input.value.ko),\n    ])\n\n  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {\n    if (entry.type === \"lookupEntry\") return buildNextChecksum(entry.value)\n    switch (entry.type) {\n      case \"void\":\n        return getChecksum([shapeIds.void])\n      case \"tuple\":\n        return buildTuple(entry.value)\n      case \"struct\":\n        return buildStruct(entry.value)\n      case \"array\":\n        return buildVector(entry.value, entry.len)\n    }\n  })\n}\n\nconst sortCyclicGroups = (groups: Array<Set<number>>, graph: LookupGraph) => {\n  const getReachableNodes = (group: Set<number>) => {\n    const result = new Set<number>()\n    const toVisit = Array.from(group)\n    while (toVisit.length) {\n      const id = toVisit.pop()!\n      if (result.has(id)) continue\n      result.add(id)\n\n      graph.get(id)?.refs.forEach((id) => toVisit.push(id))\n    }\n\n    return Array.from(result)\n  }\n\n  const result: Array<Set<number>> = new Array()\n\n  function dependentsFirst(group: Set<number>) {\n    if (result.includes(group)) return\n    const dependents = groups.filter(\n      (candidate) =>\n        candidate !== group &&\n        getReachableNodes(group).some((node) => candidate.has(node)),\n    )\n    dependents.forEach((group) => dependentsFirst(group))\n    if (result.includes(group)) return\n    result.push(group)\n  }\n\n  groups.forEach((group) => dependentsFirst(group))\n  return result\n}\n\nfunction iterateChecksums(\n  group: Set<number>,\n  iterations: number,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) {\n  // Keep the values that are getting changed on each iteration in a separate\n  // cache, because two nodes referencing the same one should read the same\n  // previous iteration checksum for that node.\n  const groupReadCache = new Map([...group].map((id) => [id, 0n]))\n  const groupWriteCache = new Map<number, bigint>()\n\n  const recursiveBuildChecksum = (\n    entry: LookupEntry,\n    // The first call has to skip the cache, otherwise it would return the\n    // previous iteration result.\n    skipCache = true,\n  ): bigint => {\n    if (!skipCache && (groupReadCache.has(entry.id) || cache.has(entry.id))) {\n      return groupReadCache.get(entry.id) ?? cache.get(entry.id)!\n    }\n    const result = _buildChecksum(entry, (nextEntry) =>\n      recursiveBuildChecksum(nextEntry, false),\n    )\n    if (group.has(entry.id)) {\n      groupWriteCache.set(entry.id, result)\n    } else {\n      cache.set(entry.id, result)\n    }\n    return result\n  }\n\n  for (let i = 0; i < iterations; i++) {\n    group.forEach((id) => recursiveBuildChecksum(graph.get(id)!.entry))\n\n    group.forEach((id) => groupReadCache.set(id, groupWriteCache.get(id)!))\n  }\n\n  return groupReadCache\n}\n\nfunction getMirroredNodes(\n  cyclicGroups: Array<Set<number>>,\n  graph: LookupGraph,\n) {\n  const maxSize = cyclicGroups.reduce(\n    (acc, group) => Math.max(acc, group.size),\n    0,\n  )\n  const allEntries = new Set([...graph.values()].map((v) => v.entry.id))\n\n  const resultingChecksums = iterateChecksums(\n    allEntries,\n    maxSize,\n    // Cache won't be used, since it's using the internal one for every node.\n    new Map(),\n    graph,\n  )\n\n  const checksumToNodes = new Map<bigint, number[]>()\n  for (const id of allEntries) {\n    const checksum = resultingChecksums.get(id)\n    if (checksum == undefined) throw new Error(\"Unreachable\")\n    if (!checksumToNodes.has(checksum)) {\n      checksumToNodes.set(checksum, [])\n    }\n    checksumToNodes.get(checksum)!.push(id)\n  }\n\n  const checksumsWithDuplicates = [...checksumToNodes.entries()].filter(\n    ([, nodes]) => nodes.length > 1,\n  )\n\n  const duplicatesMap: Record<number, number[]> = {}\n  checksumsWithDuplicates.forEach(([, nodes]) => {\n    nodes.forEach((n) => (duplicatesMap[n] = nodes))\n  })\n\n  return duplicatesMap\n}\n\nconst buildChecksum = (\n  entry: LookupEntry,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) => {\n  if (cache.has(entry.id)) return cache.get(entry.id)!\n\n  const subGraph = getSubgraph(entry.id, graph)\n\n  const cycles = getStronglyConnectedComponents(subGraph).filter(\n    // SCCs can be of length=1, but for those we're only interested with those that are circular with themselves\n    (group) => group.size > 1 || isSelfCircular(group, subGraph),\n  )\n  const cyclicGroups = mergeSCCsWithCommonNodes(cycles).filter((group) => {\n    // Exclude groups that were previously calculated\n    return !cache.has(group.values().next().value!)\n  })\n  const mirrored = getMirroredNodes(cyclicGroups, subGraph)\n  const sortedCyclicGroups = sortCyclicGroups(cyclicGroups, subGraph)\n\n  sortedCyclicGroups.forEach((group) => {\n    if (cache.has(group.values().next().value!)) {\n      // exclude mirrored groups\n      return\n    }\n\n    const result = iterateChecksums(group, group.size, cache, graph)\n    group.forEach((id) => {\n      const checksum = result.get(id)!\n      if (id in mirrored) {\n        mirrored[id].forEach((id) => cache.set(id, checksum))\n      } else {\n        cache.set(id, checksum)\n      }\n    })\n  })\n\n  const getChecksum = (entry: LookupEntry) => {\n    if (cache.has(entry.id)) return cache.get(entry.id)!\n    return _buildChecksum(entry, getChecksum)\n  }\n\n  return getChecksum(entry)\n}\n\nconst isSelfCircular = (group: Set<number>, graph: LookupGraph) => {\n  if (group.size !== 1) return false\n  const [id] = group\n\n  return graph.get(id)!.refs.has(id)\n}\n\nexport const getChecksumBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  const graph = buildLookupGraph(getLookupEntryDef, metadata.lookup.length)\n\n  const cache = new Map<number, bigint>()\n\n  const buildDefinition = (id: number): bigint =>\n    buildChecksum(getLookupEntryDef(id), cache, graph)\n\n  const buildStorage = (pallet: string, entry: string): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .storage!.items.find((s) => s.name === entry)!\n\n      if (storageEntry.type.tag === \"plain\")\n        return buildDefinition(storageEntry.type.value)\n\n      const { key, value } = storageEntry.type.value\n      const val = buildDefinition(value)\n      const returnKey = buildDefinition(key)\n      return getChecksum([val, returnKey])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string): bigint | null => {\n    try {\n      const entry = metadata.apis\n        .find((x) => x.name === api)\n        ?.methods.find((x) => x.name === method)\n      if (!entry) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        entry.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        entry.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(entry.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildComposite = (\n    input: TupleVar | StructVar | VoidVar | ArrayVar,\n  ): bigint => {\n    if (input.type === \"void\") return getChecksum([0n])\n\n    if (input.type === \"tuple\") {\n      const values = Object.values(input.value).map((entry) =>\n        buildDefinition(entry.id),\n      )\n\n      return getChecksum([shapeIds.tuple, ...values])\n    }\n\n    if (input.type === \"array\") {\n      return getChecksum([\n        shapeIds.vector,\n        buildDefinition(input.value.id),\n        BigInt(input.len),\n      ])\n    }\n\n    // Otherwise struct\n    return structLikeBuilder(shapeIds.struct, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildNamedTuple = (input: StructVar): bigint => {\n    return structLikeBuilder(shapeIds.tuple, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const variantShapeId = {\n    errors: 1n,\n    events: 2n,\n    calls: 3n,\n  }\n  const buildVariant =\n    (variantType: \"errors\" | \"events\" | \"calls\") =>\n    (pallet: string, name: string): bigint | null => {\n      try {\n        const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n        const enumLookup = getLookupEntryDef(\n          palletEntry[variantType]! as number,\n        )\n        buildDefinition(enumLookup.id)\n\n        if (enumLookup.type !== \"enum\") throw null\n        const entry = enumLookup.value[name]\n        const valueChecksum =\n          entry.type === \"lookupEntry\"\n            ? buildDefinition(entry.value.id)\n            : buildComposite(entry)\n        return getChecksum([variantShapeId[variantType], valueChecksum])\n      } catch (_) {\n        return null\n      }\n    }\n\n  const buildConstant = (\n    pallet: string,\n    constantName: string,\n  ): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .constants!.find((s) => s.name === constantName)!\n\n      return buildDefinition(storageEntry.type)\n    } catch (_) {\n      return null\n    }\n  }\n\n  const toStringEnhancer =\n    <Args extends Array<any>>(\n      fn: (...args: Args) => bigint | null,\n    ): ((...args: Args) => string | null) =>\n    (...args) =>\n      fn(...args)?.toString(32) ?? null\n\n  return {\n    buildDefinition: toStringEnhancer(buildDefinition),\n    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),\n    buildStorage: toStringEnhancer(buildStorage),\n    buildCall: toStringEnhancer(buildVariant(\"calls\")),\n    buildEvent: toStringEnhancer(buildVariant(\"events\")),\n    buildError: toStringEnhancer(buildVariant(\"errors\")),\n    buildConstant: toStringEnhancer(buildConstant),\n    buildComposite: toStringEnhancer(buildComposite),\n    buildNamedTuple: toStringEnhancer(buildNamedTuple),\n    getAllGeneratedChecksums: () =>\n      Array.from(cache.values()).map((v) => v.toString(32)),\n  }\n}\n", "import {\n  getDynamicBuilder,\n  getLookupFn,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  AccountId,\n  Binary,\n  Bytes,\n  Codec,\n  Decoder,\n  metadata as metadataCodec,\n  Option,\n  SS58String,\n  u32,\n  V14,\n  V15,\n  Vector,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport {\n  catchError,\n  EMPTY,\n  map,\n  mergeMap,\n  Observable,\n  of,\n  shareReplay,\n  timer,\n} from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<Binary>\n}\n\nexport interface RuntimeContext {\n  metadataRaw: Uint8Array\n  lookup: MetadataLookup\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  assetId: number | null\n}\n\nexport interface Runtime {\n  at: string\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst v15Args = toHex(u32.enc(15))\nconst opaqueBytes = Bytes()\nconst optionalOpaqueBytes = Option(opaqueBytes)\nconst u32ListDecoder = Vector(u32).dec\n\nexport const getRuntimeCreator = (\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n) => {\n  const getMetadata$ = (\n    getHash: () => string | null,\n  ): Observable<{ metadataRaw: Uint8Array; metadata: V14 | V15 }> => {\n    const recoverCall$ = (method: string, args: string): Observable<string> => {\n      const hash = getHash()\n      return hash\n        ? call$(hash, method, args).pipe(\n            catchError((e) => {\n              if (e instanceof BlockNotPinnedError)\n                return recoverCall$(method, args)\n              if (e instanceof OperationInaccessibleError)\n                return timer(750).pipe(\n                  mergeMap(() => recoverCall$(method, args)),\n                )\n              throw e\n            }),\n          )\n        : EMPTY\n    }\n\n    const versions = recoverCall$(\"Metadata_metadata_versions\", \"\").pipe(\n      map(u32ListDecoder),\n    )\n\n    const v14 = recoverCall$(\"Metadata_metadata\", \"\").pipe(\n      map((x) => {\n        const metadataRaw = opaqueBytes.dec(x)!\n        const metadata = metadataCodec.dec(metadataRaw)\n        return { metadata: metadata.metadata.value as V14, metadataRaw }\n      }),\n    )\n\n    const v15 = recoverCall$(\"Metadata_metadata_at_version\", v15Args).pipe(\n      map((x) => {\n        const metadataRaw = optionalOpaqueBytes.dec(x)!\n        const metadata = metadataCodec.dec(metadataRaw)\n        return { metadata: metadata.metadata.value as V15, metadataRaw }\n      }),\n    )\n\n    return versions.pipe(\n      catchError(() => of([14])),\n      mergeMap((v) => (v.includes(15) ? v15 : v14)),\n    )\n  }\n\n  return (getHash: () => string | null): Runtime => {\n    const initialHash = getHash()!\n    const usages = new Set<string>([initialHash])\n\n    const runtimeContext$: Observable<RuntimeContext> = getMetadata$(\n      getHash,\n    ).pipe(\n      map(({ metadata, metadataRaw }) => {\n        const lookup = getLookupFn(metadata)\n        const dynamicBuilder = getDynamicBuilder(lookup)\n        const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n        const assetPayment = metadata.extrinsic.signedExtensions.find(\n          (x) => x.identifier === \"ChargeAssetTxPayment\",\n        )\n\n        let assetId: null | number = null\n        if (assetPayment) {\n          const assetTxPayment = lookup(assetPayment.type)\n          if (assetTxPayment.type === \"struct\") {\n            const optionalAssetId = assetTxPayment.value.asset_id\n            if (optionalAssetId.type === \"option\")\n              assetId = optionalAssetId.value.id\n          }\n        }\n\n        return {\n          assetId,\n          metadataRaw,\n          lookup,\n          dynamicBuilder,\n          events: {\n            key: events.keys.enc(),\n            dec: events.value.dec as any,\n          },\n          accountId: AccountId(dynamicBuilder.ss58Prefix),\n        }\n      }),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: initialHash,\n      runtime: runtimeContext$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe({\n      error() {},\n    })\n\n    return result\n  }\n}\n", "import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n", "import { shareLatest } from \"@/utils\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  Observable,\n  Subject,\n  exhaustMap,\n  filter,\n  map,\n  merge,\n  scan,\n  timer,\n} from \"rxjs\"\nimport { withStopRecovery } from \"../enhancers\"\nimport type { FollowEvent } from \"./follow\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  unpinnable: boolean\n  refCount: number\n  recovering: boolean\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\ninterface CleanupEvent {\n  type: \"cleanup\"\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n  recovering: boolean\n}\n\nconst createRuntimeGetter = (pinned: PinnedBlocks, startAt: HexString) => {\n  return () => {\n    const runtime = pinned.runtimes[startAt]\n    if (!runtime) return pinned.blocks.has(startAt) ? startAt : null\n    const winner = [...runtime.usages].at(-1)\n    return winner ?? null\n  }\n}\n\nconst deleteBlock = (blocks: PinnedBlocks[\"blocks\"], blockHash: string) => {\n  blocks.get(blocks.get(blockHash)!.parent)?.children.delete(blockHash)\n  blocks.delete(blockHash)\n}\n\nconst deleteBlocks = (blocks: PinnedBlocks, toDelete: string[]) => {\n  toDelete.forEach((hash) => {\n    deleteBlock(blocks.blocks, hash)\n  })\n\n  Object.entries(blocks.runtimes)\n    .map(([key, value]) => ({\n      key,\n      usages: value.deleteBlocks(toDelete),\n    }))\n    .filter((x) => x.usages === 0)\n    .map((x) => x.key)\n    .forEach((unusedRuntime) => {\n      delete blocks.runtimes[unusedRuntime]\n    })\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEvent>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  blockUsage$: Subject<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n  deleteFromCache: (block: string) => void,\n) => {\n  const cleanup$ = new Subject<void>()\n  const cleanupEvt$ = cleanup$.pipe(\n    exhaustMap(() => timer(0)),\n    map(\n      (): CleanupEvent => ({\n        type: \"cleanup\" as const,\n      }),\n    ),\n  )\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    cleanupEvt$,\n    follow$,\n  ).pipe(\n    scan((acc, event) => {\n      const unpinAndDelete = (toUnpin: string[]) => {\n        deleteBlocks(acc, toUnpin)\n        onUnpin(toUnpin)\n      }\n\n      switch (event.type) {\n        case \"initialized\":\n          if (acc.recovering) {\n            const isConnected = event.finalizedBlockHashes.some((hash) =>\n              acc.blocks.has(hash),\n            )\n            if (!isConnected) {\n              acc = getInitialPinnedBlocks()\n            }\n          }\n\n          const [finalizedHash] = event.finalizedBlockHashes.slice(-1)\n          acc.finalized = acc.best = finalizedHash\n\n          const lastIdx = event.finalizedBlockHashes.length - 1\n          event.finalizedBlockHashes.forEach((hash, i) => {\n            const preexistingBlock = acc.blocks.get(hash)\n            if (preexistingBlock) {\n              preexistingBlock.recovering = false\n              preexistingBlock.unpinnable = i !== lastIdx\n            } else {\n              acc.blocks.set(hash, {\n                hash: hash,\n                parent:\n                  i === 0\n                    ? event.parentHash\n                    : event.finalizedBlockHashes[i - 1],\n                children: new Set(\n                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]],\n                ),\n                unpinnable: i !== lastIdx,\n                runtime: hash,\n                refCount: 0,\n                number: event.number + i,\n                recovering: false,\n              })\n            }\n          })\n\n          const finalizedRuntime = Object.values(acc.runtimes).find((runtime) =>\n            runtime.usages.has(finalizedHash),\n          )\n\n          acc.finalizedRuntime =\n            finalizedRuntime ??\n            (acc.runtimes[finalizedHash] = getRuntime(\n              createRuntimeGetter(acc, finalizedHash),\n            ))\n\n          return acc\n\n        case \"stop-error\":\n          for (const block of acc.blocks.values()) {\n            block.recovering = true\n          }\n          acc.recovering = true\n\n          return acc\n\n        case \"newBlock\": {\n          const { parentBlockHash: parent, blockHash: hash } = event\n          if (acc.blocks.has(hash)) {\n            acc.blocks.get(hash)!.recovering = false\n          } else {\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              unpinnable: false,\n              refCount: 0,\n              recovering: false,\n            }\n            acc.blocks.set(hash, block)\n            if (event.newRuntime) {\n              // getRuntime calls getHash immediately\n              // it assumes pinnedBlocks.runtimes[hash] is empty and pinnedBlocks.blocks.has(hash)\n              acc.runtimes[hash] = getRuntime(createRuntimeGetter(acc, hash))\n            }\n            acc.runtimes[block.runtime].addBlock(hash)\n          }\n\n          return acc\n        }\n\n        case \"bestBlockChanged\": {\n          if (acc.recovering) {\n            for (const [hash, block] of acc.blocks) {\n              if (block.recovering) {\n                deleteBlock(acc.blocks, hash)\n                deleteFromCache(hash)\n              }\n            }\n            acc.recovering = false\n          }\n          acc.best = event.bestBlockHash\n          return acc\n        }\n\n        case \"finalized\": {\n          acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n          const { blocks } = acc\n\n          // This logic is only needed because of a bug on some pretty old versions\n          // of the polkadot-sdk node. However, fixing it with an enhancer\n          // was a huge PITA. Therefore, it's more pragmatic to address it here\n          if (blocks.get(acc.best)!.number < blocks.get(acc.finalized)!.number)\n            acc.best = acc.finalized\n\n          acc.finalizedRuntime =\n            acc.runtimes[blocks.get(acc.finalized)!.runtime]\n\n          event.prunedBlockHashes.forEach((hash) => {\n            const block = acc.blocks.get(hash)\n            if (block) {\n              block.unpinnable = true\n            }\n          })\n\n          let current = blocks.get(blocks.get(acc.finalized)!.parent)\n          while (current && !current.unpinnable) {\n            current.unpinnable = true\n            current = blocks.get(current.parent)\n          }\n\n          cleanup$.next()\n\n          return acc\n        }\n        case \"cleanup\": {\n          const toUnpin = [...acc.blocks.values()]\n            .filter(({ unpinnable, refCount }) => unpinnable && !refCount)\n            .map(({ hash }) => hash)\n\n          unpinAndDelete(toUnpin)\n          return acc\n        }\n        case \"blockUsage\": {\n          if (!acc.blocks.has(event.value.hash)) return acc\n\n          const block = acc.blocks.get(event.value.hash)!\n          block.refCount += event.value.type === \"hold\" ? 1 : -1\n          if (block.refCount === 0 && !block.recovering && block.unpinnable) {\n            const toUnpin = [block.hash]\n            unpinAndDelete(toUnpin)\n          }\n          return acc\n        }\n      }\n    }, getInitialPinnedBlocks()),\n    filter((x) => !!x.finalizedRuntime.runtime),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntime = getRuntimeCreator(\n    withStopRecovery(pinnedBlocks$, call$, \"pinned-blocks\"),\n  )\n  return pinnedBlocks$\n}\n\nconst getInitialPinnedBlocks = (): PinnedBlocks => ({\n  best: \"\",\n  finalized: \"\",\n  runtimes: {},\n  blocks: new Map(),\n  finalizedRuntime: {} as Runtime,\n  recovering: false,\n})\n", "import {\n  Observable,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { HexString, ResultPayload } from \"@polkadot-api/substrate-bindings\"\n\nexport type AnalyzedBlock = {\n  hash: HexString\n  found:\n    | {\n        type: true\n        index: number\n        events: any\n      }\n    | {\n        type: false\n        validity: ResultPayload<any, any> | null // null means that the block was already present when the tx was broadcasted\n      }\n}\n\nexport const getTrackTx = (\n  blocks$: Observable<PinnedBlocks>,\n  getBody: (block: string) => Observable<string[]>, // Returns an observable that should emit just once and complete\n  getIsValid: (\n    block: string,\n    tx: string,\n  ) => Observable<ResultPayload<any, any>>, // Returns an observable that should emit just once and complete\n  getEvents: (block: string) => Observable<any>, // Returns an observable that should emit just once and complete\n) => {\n  const whileBlockPresent = <TT>(\n    hash: string,\n  ): (<T = TT>(base: Observable<T>) => Observable<T>) =>\n    takeUntil(blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))))\n\n  const analyzeBlock = (\n    hash: string,\n    tx: string,\n    alreadyPresent: boolean,\n  ): Observable<AnalyzedBlock> => {\n    if (alreadyPresent)\n      return of({ hash, found: { type: false, validity: null } })\n\n    const whilePresent = whileBlockPresent(hash)\n    return getBody(hash).pipe(\n      mergeMap((txs) => {\n        const index = txs.indexOf(tx)\n        return index > -1\n          ? whilePresent(getEvents(hash)).pipe(\n              map((events) => ({\n                hash,\n                found: {\n                  type: true as true,\n                  index,\n                  events,\n                },\n              })),\n            )\n          : getIsValid(hash, tx).pipe(\n              map((validity) => ({\n                hash,\n                found: { type: false as false, validity },\n              })),\n            )\n      }),\n      whilePresent,\n    )\n  }\n\n  const findInBranch = (\n    hash: string,\n    tx: string,\n    alreadyPresent: Set<string>,\n  ): Observable<AnalyzedBlock> =>\n    analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(\n      mergeMap((analyzed) => {\n        const { found } = analyzed\n        return found.type || found.validity?.success === false\n          ? of(analyzed)\n          : blocks$.pipe(\n              whileBlockPresent(hash),\n              mergeMap((x) => x.blocks.get(hash)!.children),\n              distinct(),\n              mergeMap((hash) => findInBranch(hash, tx, alreadyPresent)),\n            )\n      }),\n    )\n\n  return (tx: string): Observable<AnalyzedBlock> =>\n    blocks$.pipe(\n      take(1),\n      mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys()))),\n    )\n}\n", "import { Observable, map, withLatestFrom } from \"rxjs\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  _void,\n  createDecoder,\n  Decoder,\n  ResultPayload,\n  u8,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { RuntimeContext } from \"./streams\"\n\nconst external = new Uint8Array([2])\n\nconst getValidateTxArgs = (tx: string, hash: string) =>\n  toHex(mergeUint8(external, fromHex(tx), fromHex(hash)))\n\nconst TaggedTransactionQueue = \"TaggedTransactionQueue\"\nconst validateTransaction = \"validate_transaction\"\n\nconst [, defaultInvalidTxDecoder] = Variant({\n  InvalidTransaction: Variant({\n    Call: _void,\n    Payment: _void,\n    Future: _void,\n    Stale: _void,\n    BadProof: _void,\n    AncientBirthBlock: _void,\n    ExhaustsResources: _void,\n    Custom: u8,\n    BadMandatory: _void,\n    MandatoryValidation: _void,\n    BadSigner: _void,\n  }),\n  UnknownTransaction: Variant({\n    CannotLookup: _void,\n    NoUnsignedValidator: _void,\n    Custom: u8,\n  }),\n})\nconst defaultValidateTxDecoder: Decoder<ResultPayload<undefined, any>> =\n  createDecoder((input) => {\n    const firstByte = u8.dec(input)\n    if (firstByte > 1)\n      throw new Error(\"Unable to decode validateTransaction result\")\n\n    if (!firstByte) return { success: true, value: undefined }\n    let value: any\n    try {\n      value = defaultInvalidTxDecoder(input)\n    } catch (_) {\n      value = {\n        type: \"UnknownInvalidTx\",\n      }\n    }\n    return { success: false, value }\n  })\n\nexport const getValidateTx =\n  (\n    call$: (\n      hash: string | null,\n      fnName: string,\n      parameters: string,\n    ) => Observable<string>,\n    getRuntimeContext: (hash: string) => Observable<RuntimeContext>,\n  ) =>\n  (blockHash: string, tx: string): Observable<ResultPayload<any, any>> => {\n    const decoder$ = getRuntimeContext(blockHash).pipe(\n      map((ctx) => {\n        try {\n          return ctx.dynamicBuilder.buildRuntimeCall(\n            TaggedTransactionQueue,\n            validateTransaction,\n          ).value[1] as Decoder<ResultPayload<any, any>>\n        } catch (_) {\n          return defaultValidateTxDecoder\n        }\n      }),\n    )\n    return call$(\n      blockHash,\n      `${TaggedTransactionQueue}_${validateTransaction}`,\n      getValidateTxArgs(tx, blockHash),\n    ).pipe(\n      withLatestFrom(decoder$),\n      map(([result, decoder]) => decoder(result)),\n    )\n  }\n", "import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n", "import { Observable } from \"rxjs\"\n\nexport const delayUnsubscription =\n  (ms?: number) =>\n  <T>(source: Observable<T>): Observable<T> =>\n    new Observable((observer) => {\n      const subscription = source.subscribe({\n        next(v) {\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n      const unsubscribe = () => subscription.unsubscribe()\n      return () => {\n        if (ms != null) setTimeout(unsubscribe, ms)\n        else Promise.resolve().then(unsubscribe)\n      }\n    })\n", "import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n\n        let isCompleted = false\n        let subscription = inner$.subscribe({\n          next(x: O) {\n            if (observerIdx === idx) {\n              observer.next(x)\n            } else {\n              results.get(idx)!.push(x)\n            }\n          },\n          complete() {\n            isCompleted = true\n            innerSubscriptions.delete(idx)\n            if (idx === observerIdx) {\n              observerIdx++\n              while (results.has(observerIdx)) {\n                results.get(observerIdx)!.forEach((x) => observer.next(x))\n                results.delete(observerIdx)\n                if (innerSubscriptions.has(observerIdx)) {\n                  break\n                }\n                observerIdx++\n              }\n            }\n            nextSubscription()\n          },\n          error(e: any) {\n            observer.error(e)\n          },\n        })\n\n        if (!isCompleted) innerSubscriptions.set(idx, subscription)\n      }\n\n      topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n", "import { concatMapEager, delayUnsubscription, shareLatest } from \"@/utils\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  MonoTypeOperatorFunction,\n  Observable,\n  ReplaySubject,\n  Subject,\n  defer,\n  distinctUntilChanged,\n  filter,\n  map,\n  merge,\n  mergeAll,\n  mergeMap,\n  noop,\n  of,\n  scan,\n  share,\n  shareReplay,\n  switchMap,\n  take,\n  tap,\n} from \"rxjs\"\n\nimport { withDefaultValue } from \"@/utils\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withLazyFollower,\n  withStopRecovery,\n} from \"./enhancers\"\nimport { BlockNotPinnedError } from \"./errors\"\nimport { getNewBlocks$ } from \"./new-blocks\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport type {\n  BlockUsageEvent,\n  PinnedBlock,\n  PinnedBlocks,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport { getTrackTx } from \"./track-tx\"\nimport { getValidateTx } from \"./validate-tx\"\n\nexport type {\n  FollowEventWithRuntime,\n  PinnedBlock,\n  PinnedBlocks,\n  RuntimeContext,\n  SystemEvent,\n}\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (chainHead: ChainHead) => {\n  const { getFollower, startFollow, follow$, getHeader } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const holdBlock = (hash: string) => {\n    blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n    return () => {\n      setTimeout(() => {\n        blockUsage$.next({\n          type: \"blockUsage\",\n          value: { type: \"release\", hash },\n        })\n      }, 0)\n    }\n  }\n\n  const usingBlock: <T>(blockHash: string) => MonoTypeOperatorFunction<T> =\n    (blockHash: string) => (base) =>\n      new Observable((observer) => {\n        const release = holdBlock(blockHash)\n        const subscription = base.subscribe(observer)\n        subscription.add(release)\n        return subscription\n      })\n\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      fn(hash, ...args).pipe(usingBlock(hash))\n\n  const withInMemory =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n      label: string,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        let isPresent = false\n        pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {\n          isPresent = blocks.blocks.has(hash)\n        })\n\n        return isPresent\n          ? fn(hash, ...args).subscribe(observer)\n          : observer.error(new BlockNotPinnedError(hash, label))\n      })\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n    label: string,\n  ) =>\n    withInMemory(\n      withRefcount(\n        withStopRecovery(\n          pinnedBlocks$,\n          withRecoveryFn(fromAbortControllerFn(fn)),\n          `stop-${label}`,\n        ),\n      ),\n      label,\n    )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\")))),\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n    (block) => {\n      cache.delete(block)\n    },\n  )\n\n  const getRuntimeContext$ = withRefcount((hash: string) =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(\n        (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n      ),\n    ),\n  )\n\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const hashCache = cache.get(hash) ?? new Map()\n    const cached = hashCache.get(key)\n    if (cached) return cached\n\n    cache.set(hash, hashCache)\n\n    let connector: ReplaySubject<T>\n    const result = stream.pipe(\n      share({\n        connector: () => (connector = new ReplaySubject()),\n      }),\n      tap({\n        complete() {\n          hashCache.set(key, connector)\n        },\n      }),\n      delayUnsubscription(),\n    )\n    hashCache.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    filter((x) => !x.recovering),\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    scan((acc, value) => {\n      let current = value.blocks.get(value.finalized)!\n      const result = [current]\n\n      const latest = acc.at(-1)\n      if (!latest) return result\n\n      while (current.number > latest.number + 1) {\n        current = value.blocks.get(current.parent)!\n        if (!current) break\n        result.unshift(current)\n      }\n      return result\n    }, [] as PinnedBlock[]),\n    mergeAll(),\n    map(toBlockInfo),\n    shareLatest,\n  )\n\n  const best$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.best === b.best),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    filter((x) => !x.recovering),\n    distinctUntilChanged(\n      (prev, current) =>\n        prev.finalized === current.finalized && prev.best === current.best,\n    ),\n    scan((acc, pinned) => {\n      const getBlockInfo = (hash: string) =>\n        acc.get(hash) || toBlockInfo(pinned.blocks.get(hash)!)\n\n      const best = getBlockInfo(pinned.best)\n      const finalized = getBlockInfo(pinned.finalized)\n\n      const len = best.number - finalized.number + 1\n      const result = new Array<BlockInfo>(len)\n      for (let i = 0, hash = best.hash; i < len; i++) {\n        result[i] = getBlockInfo(hash)\n        hash = result[i].parent\n      }\n\n      return new Map(result.map((b) => [b.hash, b]))\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.lookup.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((b) => b.hash)),\n    best$.pipe(map((b) => b.hash)),\n    usingBlock,\n  )\n\n  const _body$ = withOptionalHash$(commonEnhancer(lazyFollower(\"body\"), \"body\"))\n  const body$ = (hash: string) => upsertCachedStream(hash, \"body\", _body$(hash))\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"), \"storage\")\n\n  const storage$ = withOptionalHash$(\n    <\n      Type extends StorageItemInput[\"type\"],\n      M extends\n        | undefined\n        | ((data: StorageResult<Type>, ctx: RuntimeContext) => any),\n    >(\n      hash: string,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: M,\n    ): Observable<\n      undefined extends M\n        ? StorageResult<Type>\n        : { raw: StorageResult<Type>; mapped: ReturnType<NonNullable<M>> }\n    > =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n        mergeMap((ctx) => {\n          const key = keyMapper(ctx)\n          const unMapped$ = upsertCachedStream(\n            hash,\n            `storage-${type}-${key}-${childTrie ?? \"\"}`,\n            _storage$(hash, type, key, childTrie),\n          )\n\n          return mapper\n            ? upsertCachedStream(\n                hash,\n                `storage-${type}-${key}-${childTrie ?? \"\"}-dec`,\n                unMapped$.pipe(\n                  map((raw) => ({ raw, mapped: mapper(raw, ctx) })),\n                ),\n              )\n            : unMapped$\n        }),\n      ) as Observable<\n        undefined extends M\n          ? StorageResult<Type>\n          : { raw: StorageResult<Type>; mapped: ReturnType<NonNullable<M>> }\n      >,\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOptionalHash$(\n    withStopRecovery(\n      pinnedBlocks$,\n      (hash: string, queries: Array<StorageItemInput>, childTrie?: string) =>\n        recoveralStorage$(hash, queries, childTrie ?? null, false),\n      `storageQueries`,\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withStopRecovery(\n      pinnedBlocks$,\n      (hash: string) => defer(() => getHeader(hash)),\n      \"header\",\n    ),\n  )\n\n  const eventsAt$ = (hash: string | null) =>\n    storage$(\n      hash,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    ).pipe(map((x) => x.mapped))\n\n  const __call$ = commonEnhancer(lazyFollower(\"call\"), \"call\")\n  const call$ = withOptionalHash$((hash: string, fn: string, args: string) =>\n    upsertCachedStream(hash, `call-${fn}-${args}`, __call$(hash, fn, args)),\n  )\n\n  const validateTx$ = getValidateTx(call$, getRuntimeContext$)\n\n  const innerBody$ = (hash: string) =>\n    upsertCachedStream(hash, \"body\", _body$(hash))\n\n  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$)\n  const trackTxWithoutEvents$ = getTrackTx(\n    pinnedBlocks$,\n    innerBody$,\n    validateTx$,\n    () => of(),\n  )\n\n  const genesis$ = runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    mergeMap((runtime) => {\n      const { enc } = runtime.dynamicBuilder.buildStorage(\n        \"System\",\n        \"BlockHash\",\n      ).keys\n      // const genesis$ =\n      // there are chains (e.g. kilt) that use u64 as block number\n      // u64 is encoded as bigint\n      // using dynamic builder for safety\n      let key: string\n      try {\n        // for u32\n        key = enc(0)\n      } catch {\n        // for u64\n        key = enc(0n)\n      }\n\n      return storage$(null, \"value\", () => key, null) as Observable<HexString>\n    }),\n    shareReplay(1),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe({\n    error() {},\n  })\n\n  let unfollow = noop\n  let started: boolean | null = false\n  let nSubscribers: number = 0\n  const start = (_nSubscribers: number) => {\n    nSubscribers += _nSubscribers\n    started = true\n\n    unfollow = startFollow()\n  }\n\n  return [\n    {\n      follow$,\n      finalized$,\n      best$,\n      bestBlocks$,\n      newBlocks$: getNewBlocks$(pinnedBlocks$),\n      runtime$,\n      metadata$,\n      genesis$,\n\n      header$,\n      body$,\n      call$,\n      storage$,\n      storageQueries$,\n      eventsAt$,\n\n      holdBlock,\n      trackTx$,\n      trackTxWithoutEvents$,\n      validateTx$,\n      pinnedBlocks$,\n      withRuntime,\n      getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n      unfollow: () => {\n        if (started == null) return\n        nSubscribers--\n        if (started && !nSubscribers) {\n          started = null\n          unfollow()\n          unfollow = noop\n        }\n      },\n    },\n    start,\n  ] as const\n}\n\nexport type ChainHead$ = ReturnType<typeof getChainHead$>[0]\n", "import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<never>((observer) =>\n      baseTransaction(transaction, (e) => {\n        observer.error(e)\n      }),\n    )\n", "import type {\n  SubstrateClient,\n  UnsubscribeFn,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\nimport { ChainHead$, getChainHead$ } from \"./chainHead\"\nimport getBroadcastTx$ from \"./tx\"\n\nexport interface ObservableClient {\n  chainHead$: (nSubscribers?: number) => ChainHead$\n  broadcastTx$: (transaction: string) => Observable<never>\n  destroy: UnsubscribeFn\n}\n\nconst clientCache = new Map<\n  SubstrateClient,\n  { client: ObservableClient; refCount: number }\n>()\n\nexport const getObservableClient = (\n  substrateClient: SubstrateClient,\n): ObservableClient => {\n  const cached = clientCache.get(substrateClient)\n  if (cached) {\n    cached.refCount++\n    return cached.client\n  }\n\n  const destroy = () => {\n    const cached = clientCache.get(substrateClient)\n    if (!cached || cached.refCount <= 1) {\n      clientCache.delete(substrateClient)\n      substrateClient.destroy()\n    } else {\n      cached.refCount--\n    }\n  }\n\n  let cachedChainhead:\n    | readonly [ChainHead$, (nSubscribers: number) => void]\n    | null = null\n  let currentSubscribers = 0\n  let expectedSubscribers: null | number = null\n\n  const client: ObservableClient = {\n    chainHead$: (_expectedSubscribers) => {\n      currentSubscribers++\n      expectedSubscribers ||= _expectedSubscribers || 1\n      cachedChainhead ||= getChainHead$(substrateClient.chainHead)\n      const [result, start] = cachedChainhead\n      if (expectedSubscribers === currentSubscribers) {\n        const copiedCurrentSubscribers = currentSubscribers\n        currentSubscribers = 0\n        expectedSubscribers = null\n        cachedChainhead = null\n        start(copiedCurrentSubscribers)\n      }\n      return result\n    },\n    broadcastTx$: getBroadcastTx$(substrateClient.transaction),\n    destroy,\n  }\n\n  clientCache.set(substrateClient, { client, refCount: 1 })\n  return client\n}\n", "import { Observable, distinctUntilChanged, map, takeWhile } from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isBestOrFinalizedBlock = (\n  blocks$: Observable<PinnedBlocks>,\n  blockHash: string,\n) =>\n  blocks$.pipe(\n    takeWhile((b) => b.blocks.has(blockHash)),\n    distinctUntilChanged(\n      (a, b) => a.finalized === b.finalized && a.best === b.best,\n    ),\n    map((pinned): \"best\" | \"finalized\" | null => {\n      if (\n        pinned.blocks.get(blockHash)!.number >\n        pinned.blocks.get(pinned.best)!.number\n      )\n        return null\n\n      const { number } = pinned.blocks.get(blockHash)!\n      let current = pinned.blocks.get(pinned.best)!\n      let isFinalized = pinned.finalized === current.hash\n      while (current.number > number) {\n        current = pinned.blocks.get(current.parent)!\n        isFinalized = isFinalized || pinned.finalized === current.hash\n      }\n      if (isFinalized) return \"finalized\"\n      return current.hash === blockHash ? \"best\" : null\n    }),\n    distinctUntilChanged(),\n    takeWhile((x) => x !== \"finalized\", true),\n  )\n", "import { MetadataLookup } from \"@polkadot-api/metadata-builders\"\nimport {\n  CompatibilityCache,\n  CompatibilityLevel,\n  EntryPoint,\n  EntryPointCodec,\n  TypedefCodec,\n  TypedefNode,\n  entryPointsAreCompatible,\n  mapLookupToTypedef,\n  valueIsCompatibleWithDest,\n} from \"@polkadot-api/metadata-compatibility\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { Tuple, Vector } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, combineLatest, filter, firstValueFrom, map } from \"rxjs\"\nimport { ChainDefinition } from \"./descriptors\"\n\nexport class RuntimeToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _runtime(value: D) {}\n}\n\nexport class CompatibilityToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _compatibility(value: D) {}\n}\n\ninterface RuntimeTokenApi {\n  runtime: () => RuntimeContext\n}\ninterface CompatibilityTokenApi extends RuntimeTokenApi {\n  typedefNodes: TypedefNode[]\n  getPalletEntryPoint: (\n    opType: OpType,\n    pallet: string,\n    name: string,\n  ) => EntryPoint\n  getApiEntryPoint: (name: string, method: string) => EntryPoint\n}\nconst compatibilityTokenApi = new WeakMap<\n  CompatibilityToken,\n  CompatibilityTokenApi\n>()\nconst runtimeTokenApi = new WeakMap<RuntimeToken, RuntimeTokenApi>()\nexport const getCompatibilityApi = (\n  token: RuntimeToken | CompatibilityToken,\n): RuntimeTokenApi | CompatibilityTokenApi =>\n  token instanceof RuntimeToken\n    ? runtimeTokenApi.get(token)!\n    : compatibilityTokenApi.get(token)!\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Const = \"constants\",\n}\n\nconst EntryPointsCodec = Vector(EntryPointCodec)\nconst TypedefsCodec = Vector(TypedefCodec)\nconst TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec)\n\nexport const createCompatibilityToken = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ChainHead$,\n): Promise<CompatibilityToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = Promise.all([\n    chainDefinition.metadataTypes.then(TypesCodec.dec),\n    chainDefinition.descriptors,\n    awaitedRuntime,\n  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {\n    const token = new (CompatibilityToken as any)()\n    compatibilityTokenApi.set(token, {\n      runtime,\n      getPalletEntryPoint(opType, pallet, name) {\n        const idx = descriptors[opType]?.[pallet]?.[name]\n        if (idx == null)\n          throw new Error(\n            `Descriptor for ${opType} ${pallet}.${name} does not exist`,\n          )\n        return entryPoints[idx]\n      },\n      getApiEntryPoint(name, method) {\n        const idx = descriptors.apis?.[name]?.[method]\n        if (idx == null)\n          throw new Error(`Descriptor for API ${name}.${method} does not exist`)\n        return entryPoints[idx]\n      },\n      typedefNodes,\n    })\n\n    return token\n  })\n\n  return promise\n}\n\nexport const createRuntimeToken = <D>(\n  chainHead: ChainHead$,\n): Promise<RuntimeToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = awaitedRuntime.then((runtime) => {\n    const token = new (RuntimeToken as any)()\n    runtimeTokenApi.set(token, {\n      runtime,\n    })\n    return token\n  })\n\n  return promise\n}\n\n// metadataRaw -> cache\nconst metadataCache = new WeakMap<\n  Uint8Array,\n  {\n    compat: CompatibilityCache\n    lookup: MetadataLookup\n    typeNodes: (TypedefNode | null)[]\n  }\n>()\nconst getMetadataCache = (ctx: RuntimeContext) => {\n  if (!metadataCache.has(ctx.metadataRaw)) {\n    metadataCache.set(ctx.metadataRaw, {\n      compat: new Map(),\n      lookup: ctx.lookup,\n      typeNodes: [],\n    })\n  }\n  return metadataCache.get(ctx.metadataRaw)!\n}\nexport const compatibilityHelper = (\n  descriptors: Promise<RuntimeToken | CompatibilityToken>,\n  getDescriptorEntryPoint: (descriptorApi: CompatibilityTokenApi) => EntryPoint,\n  getRuntimeEntryPoint: (ctx: RuntimeContext) => EntryPoint | null,\n) => {\n  const getRuntimeTypedef = (ctx: RuntimeContext, id: number) => {\n    const cache = getMetadataCache(ctx)\n    return (cache.typeNodes[id] ||= mapLookupToTypedef(cache.lookup(id)))\n  }\n\n  function getCompatibilityLevels(\n    descriptors: CompatibilityToken | RuntimeToken,\n    /**\n     * The `Runtime` of runtimeWithDescriptors already has a RuntimeContext,\n     * which is the runtime of the finalized block.\n     * But on some cases, the user wants to perform an action on a specific\n     * block hash, which has a different RuntimeContext.\n     */\n    ctx?: RuntimeContext,\n  ) {\n    if (descriptors instanceof RuntimeToken) {\n      return {\n        args: CompatibilityLevel.Identical,\n        values: CompatibilityLevel.Identical,\n      }\n    }\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n    ctx ||= compatibilityApi.runtime()\n    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi)\n    const runtimeEntryPoint = getRuntimeEntryPoint(ctx)\n    if (runtimeEntryPoint == null)\n      return {\n        args: CompatibilityLevel.Incompatible,\n        values: CompatibilityLevel.Incompatible,\n      }\n    const descriptorNodes = compatibilityApi.typedefNodes\n\n    const cache = getMetadataCache(ctx)\n\n    return entryPointsAreCompatible(\n      descriptorEntryPoint,\n      (id) => descriptorNodes[id],\n      runtimeEntryPoint,\n      (id) => getRuntimeTypedef(ctx, id),\n      cache.compat,\n    )\n  }\n\n  const getCompatibilityLevel = withOptionalToken(descriptors, (runtime) =>\n    minCompatLevel(getCompatibilityLevels(runtime)),\n  )\n  const isCompatible = withOptionalToken(\n    descriptors,\n    (threshold: CompatibilityLevel, runtime) =>\n      getCompatibilityLevel(runtime) >= threshold,\n  )\n\n  const compatibleRuntime$ = (chainHead: ChainHead$, hash: string | null) =>\n    combineLatest([descriptors, chainHead.getRuntimeContext$(hash)])\n\n  const withCompatibleRuntime =\n    <T>(chainHead: ChainHead$, mapper: (x: T) => string) =>\n    (\n      source$: Observable<T>,\n    ): Observable<[T, CompatibilityToken | RuntimeToken, RuntimeContext]> =>\n      combineLatest([\n        source$.pipe(chainHead.withRuntime(mapper)),\n        descriptors,\n      ]).pipe(map(([[x, ctx], descriptors]) => [x, descriptors, ctx]))\n\n  const argsAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    args: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const levels = getCompatibilityLevels(descriptors, ctx)\n    if (levels.args === CompatibilityLevel.Incompatible) return false\n    if (levels.args > CompatibilityLevel.Partial) return true\n    // Although technically args could still be compatible, if the output will be incompatible we might as well just return false to skip sending the request.\n    if (levels.values === CompatibilityLevel.Incompatible) return false\n\n    const entryPoint = getRuntimeEntryPoint(ctx)\n    if (entryPoint == null) return false\n\n    return valueIsCompatibleWithDest(\n      entryPoint.args,\n      (id) => getRuntimeTypedef(ctx, id),\n      args,\n    )\n  }\n  const valuesAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    values: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const level = getCompatibilityLevels(descriptors, ctx).values\n    if (level === CompatibilityLevel.Incompatible) return false\n    if (level > CompatibilityLevel.Partial) return true\n\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n\n    const entryPoint = getDescriptorEntryPoint(compatibilityApi)\n\n    return valueIsCompatibleWithDest(\n      entryPoint.values,\n      (id) => compatibilityApi.typedefNodes[id],\n      values,\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors,\n    withCompatibleRuntime,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n    getRuntimeTypedef,\n  }\n}\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n\nexport const minCompatLevel = (levels: {\n  args: CompatibilityLevel\n  values: CompatibilityLevel\n}) => Math.min(levels.args, levels.values)\n\nconst withOptionalToken =\n  <T, D, A extends [...any[], CompatibilityToken | RuntimeToken]>(\n    compatibilityToken: Promise<CompatibilityToken<D> | RuntimeToken<D>>,\n    fn: (...args: A) => T,\n  ): WithOptionalRuntime<T, D, A extends [...infer R, any] ? R : []> =>\n  (...args: any): any => {\n    const lastElement = args.at(-1)\n    if (\n      lastElement instanceof CompatibilityToken ||\n      lastElement instanceof RuntimeToken\n    ) {\n      return fn(...args)\n    }\n    return compatibilityToken.then((token) => (fn as any)(...args, token))\n  }\n\nexport type WithOptionalRuntime<T, D, A extends any[]> = {\n  /**\n   * Returns the result after waiting for the runtime to load.\n   */\n  (...args: A): Promise<T>\n  /**\n   * Returns the result synchronously with the loaded runtime.\n   */\n  (...args: [...A, runtime: CompatibilityToken<D> | RuntimeToken<D>]): T\n}\n\nexport interface CompatibilityFunctions<D> {\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   */\n  getCompatibilityLevel(): Promise<CompatibilityLevel>\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   *\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  getCompatibilityLevel(\n    compatibilityToken: CompatibilityToken<D>,\n  ): CompatibilityLevel\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold  CompatibilityLevel threshold to use, inclusive.\n   */\n  isCompatible(threshold: CompatibilityLevel): Promise<boolean>\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold           CompatibilityLevel threshold to use,\n   *                            inclusive.\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  isCompatible(\n    threshold: CompatibilityLevel,\n    compatibilityToken: CompatibilityToken<D>,\n  ): boolean\n}\n", "import { RuntimeContext } from \"@polkadot-api/observable-client\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"./compatibility\"\n\nexport type ConstantEntry<Unsafe, D, T> = Unsafe extends true\n  ? {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (runtimeToken: RuntimeToken): T\n    }\n  : {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (compatibilityToken: CompatibilityToken): T\n    } & CompatibilityFunctions<D>\n\nexport const createConstantEntry = <D, T>(\n  palletName: string,\n  name: string,\n  {\n    valuesAreCompatible,\n    descriptors,\n    isCompatible,\n    getCompatibilityLevel,\n  }: CompatibilityHelper,\n): ConstantEntry<any, D, T> => {\n  const cachedResults = new WeakMap<RuntimeContext, T>()\n  const getValueWithContext = (ctx: RuntimeContext) => {\n    if (cachedResults.has(ctx)) {\n      return cachedResults.get(ctx)!\n    }\n\n    const pallet = ctx.lookup.metadata.pallets.find(\n      (p) => p.name === palletName,\n    )\n    const constant = pallet?.constants.find((c) => c.name === name)\n    if (constant == null)\n      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`)\n    const result = ctx.dynamicBuilder\n      .buildConstant(palletName, name)\n      .dec(constant.value)\n    cachedResults.set(ctx, result)\n    return result\n  }\n\n  const fn = (token?: CompatibilityToken | RuntimeToken): any => {\n    if (token) {\n      const ctx = getCompatibilityApi(token).runtime()\n      const value = getValueWithContext(ctx)\n      if (!valuesAreCompatible(token, ctx, value))\n        throw new Error(\n          `Incompatible runtime entry Constant(${palletName}.${name})`,\n        )\n      return value\n    }\n    return descriptors.then(fn)\n  }\n\n  return Object.assign(fn, { isCompatible, getCompatibilityLevel })\n}\n", "import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n", "import { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { concatMapEager, shareLatest } from \"./utils\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<Unsafe, D, T> = {\n  /**\n   * Multicast and stateful Observable watching for new events (matching the\n   * event kind chosen) in the latest known `finalized` block.\n   *\n   * @param filter  Optional filter function to only emit events complying\n   *                with the function.\n   */\n  watch: EvWatch<T>\n  /**\n   * Fetch (Promise-based) all events (matching the event kind chosen) available\n   * in the latest known `finalized` block.\n   */\n  pull: EvPull<T>\n  /**\n   * Filter a bunch of `SystemEvent` and return the decoded `payload` of every\n   * of them.\n   *\n   * @param collection  Array of `SystemEvent` to filter.\n   */\n  filter: EvFilter<T>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <D, T>(\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    withCompatibleRuntime,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): EvClient<any, D, T> => {\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n  const shared$ = chainHead.finalized$.pipe(\n    withCompatibleRuntime(chainHead, (x) => x.hash),\n    map(([block, runtime, ctx]) => {\n      const eventsIdx = ctx.lookup.metadata.pallets.find(\n        (p) => p.name === pallet,\n      )?.events\n      if (\n        eventsIdx == null ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.tag !== \"variant\" ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.value.find(\n          (ev) => ev.name === name,\n        ) == null\n      )\n        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`)\n\n      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError()\n      return [block, runtime, ctx] as const\n    }),\n    concatMapEager(([block, runtime, ctx]) =>\n      chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))\n              throw compatibilityError()\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter, getCompatibilityLevel, isCompatible }\n}\n", "import { AbortError } from \"@polkadot-api/utils\"\nimport { Observable, Subscription, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let subscription: Subscription | null = null\n    let isDone = false\n\n    const onAbort = signal\n      ? () => {\n          subscription?.unsubscribe()\n          reject(new AbortError())\n        }\n      : noop\n\n    subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n        subscription?.unsubscribe()\n        isDone = true\n      },\n      error: (e) => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(e)\n        isDone = true\n      },\n      complete: () => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(new Error(\"Observable completed without emitting\"))\n        isDone = true\n      },\n    })\n\n    // the observable could have emitted synchronously\n    if (!isDone) signal?.addEventListener(\"abort\", onAbort)\n  })\n}\n", "export const isOptionalArg = (lastArg: unknown) =>\n  typeof lastArg === \"object\" &&\n  lastArg !== null &&\n  Object.entries(lastArg).every(\n    ([k, v]) =>\n      (k === \"at\" && (v === undefined || typeof v === \"string\")) ||\n      (k === \"signal\" && (v === undefined || v instanceof AbortSignal)),\n  )\n", "import { firstValueFromWithSignal, isOptionalArg } from \"@/utils\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport type RuntimeCall<Unsafe, D, Args extends Array<any>, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the runtime call.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport const createRuntimeCallEntry = (\n  api: string,\n  method: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): RuntimeCall<any, any, any, any> => {\n  const callName = `${api}_${method}`\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at).pipe(\n      mergeMap(([runtime, ctx]) => {\n        let codecs\n        try {\n          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        } catch {\n          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`)\n        }\n        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError()\n        return chainHead.call$(at, callName, toHex(codecs.args.enc(args))).pipe(\n          map(codecs.value.dec),\n          map((value) => {\n            if (!valuesAreCompatible(runtime, ctx, value))\n              throw compatibilityError()\n            return value\n          }),\n        )\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { getCompatibilityLevel, isCompatible })\n}\n", "import { Observable, Subscription } from \"rxjs\"\n\nconst EMPTY_VALUE = Symbol(\"EMPTY_VALUE\")\ntype EMPTY_VALUE = typeof EMPTY_VALUE\n\nexport const lossLessExhaustMap =\n  <I, O>(mapper: (x: I, idx: number) => Observable<O>) =>\n  (source$: Observable<I>): Observable<O> =>\n    new Observable((observer) => {\n      let idx = 0\n      let innerSubscription: Subscription | null = null\n      let queuedValue: I | EMPTY_VALUE = EMPTY_VALUE\n      let isOutterDone = false\n\n      const setInnerSubscription = () => {\n        const observable = mapper(queuedValue as I, idx++)\n        queuedValue = EMPTY_VALUE\n        innerSubscription = observable.subscribe({\n          next(vv) {\n            observer.next(vv)\n          },\n          error(ee) {\n            observer.error(ee)\n          },\n          complete() {\n            if (queuedValue !== EMPTY_VALUE) setInnerSubscription()\n            else {\n              innerSubscription = null\n              if (isOutterDone) observer.complete()\n            }\n          },\n        })\n      }\n\n      const subscription = source$.subscribe({\n        next(v) {\n          queuedValue = v\n          if (!innerSubscription) setInnerSubscription()\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (!innerSubscription) observer.complete()\n          isOutterDone = true\n        },\n      })\n\n      return () => {\n        innerSubscription?.unsubscribe()\n        subscription.unsubscribe()\n      }\n    })\n", "import {\n  firstValueFromWithSignal,\n  isOptionalArg,\n  lossLessExhaustMap,\n} from \"@/utils\"\nimport { CompatibilityLevel } from \"@polkadot-api/metadata-compatibility\"\nimport {\n  BlockInfo,\n  BlockNotPinnedError,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport { FixedSizeBinary } from \"@polkadot-api/substrate-bindings\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  OperatorFunction,\n  combineLatestWith,\n  distinctUntilChanged,\n  filter,\n  from,\n  identity,\n  map,\n  mergeMap,\n  pipe,\n  shareReplay,\n  take,\n} from \"rxjs\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  minCompatLevel,\n} from \"./compatibility\"\nimport { createWatchEntries } from \"./watch-entries\"\n\ntype CallOptions = Partial<{\n  /**\n   * `at` could be a blockHash, `best`, or `finalized` (default)\n   */\n  at: string\n  /**\n   * `signal` allows you to abort an ongoing Promise. See [MDN\n   * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for\n   * more information\n   */\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype WithWatchOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: { at: \"best\" },\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : ArrayPossibleParents<A>\n\n// Fixed-size arrays values can't be extracted one-by-one, so that's a specific case\ntype ArrayPossibleParents<\n  A extends Array<any>,\n  Count extends Array<any> = [],\n  R = [],\n> = A extends Array<infer T> & { length: infer L }\n  ? number extends L\n    ? Array<T> // Case variable-size array it's an unknown amount of entries\n    : L extends Count[\"length\"]\n      ? R\n      : ArrayPossibleParents<A, [...Count, T], R | Count>\n  : never\n\ntype StorageEntryWithoutKeys<Unsafe, D, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: CallOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntryWithKeys<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  Payload,\n  ArgsOut extends Array<any>,\n> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: ArgsOut; value: NonNullable<Payload> }>>\n  /**\n   * Watch changes (Observable-based) for the storage entries with a subset of\n   * `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set whether to watch against the\n   *              `best` block.\n   *              By default watches changes against the finalized block.\n   *              When watching changes against the \"best\" block, this API\n   *              gratiously handles the re-orgs and provides the deltas\n   *              based on the latest emission.\n   *              The observed value contains the following properties:\n   *              - `block`: the block in where the `deltas` took place -\n   *              `deltas`: `null` indicates that nothing has changed from\n   *              the latest emission.\n   *              If the value is not `null` then the `deleted` and `upsrted`\n   *              properties indicate the entries that have changed.\n   *              - `entries`: it's an immutable data-structure with the\n   *              latest entries.\n   * @example\n   *\n   *   typedApi.query.Staking.Nominators.watchEntries()\n   *   typedApi.query.Staking.Nominators.watchEntries({ at: \"best\" })\n   *\n   */\n  watchEntries: (\n    ...args: WithWatchOptions<PossibleParents<Args>>\n  ) => Observable<{\n    block: BlockInfo\n    deltas: null | {\n      deleted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n      upserted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n    }\n    entries: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n  }>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntry<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  ArgsOut extends Array<any>,\n  Payload,\n> = Args extends []\n  ? StorageEntryWithoutKeys<Unsafe, D, Payload>\n  : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst toMapped = map(<T>(x: { mapped: T }) => x.mapped)\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  getWatchEntries: ReturnType<typeof createWatchEntries>,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors: descriptorsPromise,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): StorageEntry<any, any, any, any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const isBlockHash = pallet === \"System\" && name === \"BlockHash\"\n  const sysNumberMapper$ = chainHead.runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    map(({ dynamicBuilder }) =>\n      typeof dynamicBuilder\n        .buildStorage(\"System\", \"Number\")\n        .value.dec(new Uint8Array(32)) === \"bigint\"\n        ? BigInt\n        : identity,\n    ),\n    shareReplay(),\n  )\n  const bigIntOrNumber: OperatorFunction<number, number | bigint> = pipe(\n    combineLatestWith(sysNumberMapper$),\n    map(([input, mapper]) => mapper(input)),\n  )\n\n  const incompatibleError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const getCodec = (ctx: RuntimeContext) => {\n    try {\n      return ctx.dynamicBuilder.buildStorage(pallet, name)\n    } catch (e: any) {\n      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`)\n    }\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const isBest = target === \"best\"\n    const actualArgs =\n      isBest || target === \"finalized\" ? args.slice(0, -1) : args\n\n    return chainHead[isBest ? \"best$\" : \"finalized$\"].pipe(\n      lossLessExhaustMap(() =>\n        getRawValue$(...actualArgs, isBest ? { at: \"best\" } : {}),\n      ),\n      distinctUntilChanged((a, b) => a.raw === b.raw),\n      toMapped,\n    )\n  }\n\n  const getRawValue$ = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    if (isSystemNumber)\n      return chainHead.pinnedBlocks$.pipe(\n        map((blocks) => {\n          const hash =\n            at === \"finalized\" || !at\n              ? blocks.finalized\n              : at === \"best\"\n                ? blocks.best\n                : at\n          const block = blocks.blocks.get(hash)\n          if (!block) {\n            throw new BlockNotPinnedError(hash, \"System.Number\")\n          }\n          return block.number\n        }),\n        distinctUntilChanged(),\n        bigIntOrNumber,\n        map((mapped) => ({ raw: mapped, mapped })),\n      )\n\n    if (isBlockHash && Number(args[0]) === 0) {\n      return chainHead.genesis$.pipe(\n        map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) })),\n      ) as Observable<any>\n    }\n\n    return from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"value\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            const actualArgs =\n              args.length === codecs.len ? args : args.slice(0, -1)\n            if (args !== actualArgs && !isLastArgOptional)\n              throw invalidArgs(args)\n            if (!argsAreCompatible(descriptors, ctx, actualArgs))\n              throw incompatibleError()\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (data, ctx) => {\n            const codecs = getCodec(ctx)\n            const value =\n              data === null ? codecs.fallback : codecs.value.dec(data)\n            if (!valuesAreCompatible(descriptors, ctx, value))\n              throw incompatibleError()\n            return value\n          },\n        ),\n      ),\n    )\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal }: CallOptions = isLastArgOptional ? lastArg : {}\n\n    return firstValueFromWithSignal(\n      getRawValue$(...args).pipe(toMapped),\n      signal,\n    )\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const descriptors = await descriptorsPromise\n    const result$ = chainHead\n      .storage$(\n        at,\n        \"descendantsValues\",\n        (ctx) => {\n          const codecs = getCodec(ctx)\n          // TODO partial compatibility check for args that become optional\n          if (\n            minCompatLevel(getCompatibilityLevels(descriptors, ctx)) ===\n            CompatibilityLevel.Incompatible\n          )\n            throw incompatibleError()\n\n          if (args.length > codecs.len) throw invalidArgs(args)\n          const actualArgs =\n            args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n          if (args.length === codecs.len && actualArgs === args)\n            throw invalidArgs(args)\n          return codecs.keys.enc(...actualArgs)\n        },\n        null,\n        (values, ctx) => {\n          const codecs = getCodec(ctx)\n          const decodedValues = values.map(({ key, value }) => ({\n            keyArgs: codecs.keys.dec(key),\n            value: codecs.value.dec(value),\n          }))\n          if (\n            decodedValues.some(\n              ({ value }) => !valuesAreCompatible(descriptors, ctx, value),\n            )\n          )\n            throw incompatibleError()\n          return decodedValues\n        },\n      )\n      .pipe(toMapped)\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  const watchEntries: any = (...args: Array<any>) => {\n    const lastArg = args.at(-1)\n    const isLastArgOptional = isOptionalArg(lastArg)\n\n    return getWatchEntries(\n      pallet,\n      name,\n      isLastArgOptional ? args.slice(0, -1) : args,\n      isLastArgOptional && lastArg.at === \"best\",\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getValue,\n    getValues,\n    getEntries,\n    watchValue,\n    watchEntries,\n  }\n}\n", "import {\n  type V14,\n  type V15,\n  compact,\n  enhanceEncoder,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\nimport { getLookupFn, LookupEntry } from \"@polkadot-api/metadata-builders\"\n\nconst versionCodec = enhanceEncoder(\n  u8.enc,\n  (value: { signed: boolean; version: number }) =>\n    (+!!value.signed << 7) | value.version,\n)\n\nconst enum SignerType {\n  Polkadot,\n  Ethereum,\n}\nconst unkownSignerType = () => new Error(\"Unkown signer\")\nconst getSignerType = (metadata: V14 | V15): [SignerType, [] | [number]] => {\n  const { extrinsic } = metadata\n  const getLookup = getLookupFn(metadata)\n  let address: LookupEntry\n  let signature: LookupEntry\n  if (\"address\" in extrinsic) {\n    address = getLookup(extrinsic.address)\n    signature = getLookup(extrinsic.signature)\n  } else {\n    const extProps = Object.fromEntries(\n      metadata.lookup[extrinsic.type].params\n        .filter((x) => x.type != null)\n        .map((x) => [x.name, getLookup(x.type!)]),\n    )\n    address = extProps[\"Address\"]\n    signature = extProps[\"Signature\"]\n    if (!address || !signature) throw unkownSignerType()\n  }\n\n  if (\n    address.type === \"AccountId20\" &&\n    signature.type === \"array\" &&\n    signature.len === 65 &&\n    signature.value.type === \"primitive\" &&\n    signature.value.value === \"u8\"\n  )\n    return [SignerType.Ethereum, []]\n\n  if (\n    signature.type !== \"enum\" ||\n    [\"Ecdsa\", \"Ed25519\", \"Sr25519\"].some((x) => !(x in signature.value))\n  )\n    throw unkownSignerType()\n\n  if (address.type === \"enum\") {\n    const id = address.value[\"Id\"]\n    if (id.type === \"lookupEntry\" && id.value.type === \"AccountId32\")\n      return [SignerType.Polkadot, [id.idx]]\n  } else if (address.type === \"AccountId32\") return [SignerType.Polkadot, []]\n  throw unkownSignerType()\n}\n\nconst signingTypeId: Record<\"Ecdsa\" | \"Ed25519\" | \"Sr25519\", number> = {\n  Ed25519: 0,\n  Sr25519: 1,\n  Ecdsa: 2,\n}\n\nexport const createV4Tx = (\n  metadata: V14 | V15,\n  publicKey: Uint8Array,\n  signed: Uint8Array,\n  extra: Uint8Array[],\n  callData: Uint8Array,\n  signingType?: \"Ecdsa\" | \"Ed25519\" | \"Sr25519\",\n) => {\n  const [signerType, addressPrefix] = getSignerType(metadata)\n  const preResult = mergeUint8(\n    versionCodec({ signed: true, version: 4 }),\n    // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`\n    signerType === SignerType.Ethereum\n      ? publicKey\n      : new Uint8Array([...addressPrefix, ...publicKey]),\n    signerType === SignerType.Ethereum || !signingType\n      ? signed\n      : new Uint8Array([signingTypeId[signingType], ...signed]),\n    ...extra,\n    callData,\n  )\n  return mergeUint8(compact.enc(preResult.length), preResult)\n}\n", "import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\n\nconst [preBytes, postBytes] = [\"<Bytes>\", \"</Bytes>\"].map((str) =>\n  Binary.fromText(str).asBytes(),\n)\n\nexport const getSignBytes =\n  (sign: (x: Uint8Array) => Uint8Array | Promise<Uint8Array>) =>\n  async (data: Uint8Array): Promise<Uint8Array> => {\n    let isPadded = true\n    let i: number\n\n    for (i = 0; isPadded && i < preBytes.length; i++)\n      isPadded = preBytes[i] === data[i]\n    isPadded = isPadded && i === preBytes.length\n\n    const postDataStart = data.length - postBytes.length\n    for (i = 0; isPadded && i < postBytes.length; i++)\n      isPadded = postBytes[i] === data[postDataStart + i]\n    isPadded = isPadded && i === postBytes.length\n\n    return sign(isPadded ? data : mergeUint8(preBytes, data, postBytes))\n  }\n", "import { mergeUint8 } from \"@polkadot-api/utils\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getSignBytes, createV4Tx } from \"@polkadot-api/signers-common\"\nimport {\n  Blake2256,\n  decAnyMetadata,\n  V14,\n  V15,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport function getPolkadotSigner(\n  publicKey: Uint8Array,\n  signingType: \"Ecdsa\" | \"Ed25519\" | \"Sr25519\",\n  sign: (input: Uint8Array) => Promise<Uint8Array> | Uint8Array,\n): PolkadotSigner {\n  const signTx = async (\n    callData: Uint8Array,\n    signedExtensions: Record<\n      string,\n      {\n        identifier: string\n        value: Uint8Array\n        additionalSigned: Uint8Array\n      }\n    >,\n    metadata: Uint8Array,\n    _: number,\n    hasher = Blake2256,\n  ) => {\n    let decMeta: V14 | V15\n    try {\n      const tmpMeta = decAnyMetadata(metadata)\n      if (tmpMeta.metadata.tag !== \"v14\" && tmpMeta.metadata.tag !== \"v15\")\n        throw null\n      decMeta = tmpMeta.metadata.value\n    } catch (_) {\n      throw new Error(\"Unsupported metadata version\")\n    }\n    const extra: Array<Uint8Array> = []\n    const additionalSigned: Array<Uint8Array> = []\n    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {\n      const signedExtension = signedExtensions[identifier]\n      if (!signedExtension)\n        throw new Error(`Missing ${identifier} signed extension`)\n      extra.push(signedExtension.value)\n      additionalSigned.push(signedExtension.additionalSigned)\n    })\n\n    const toSign = mergeUint8(callData, ...extra, ...additionalSigned)\n    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign)\n    return createV4Tx(decMeta, publicKey, signed, extra, callData, signingType)\n  }\n\n  return {\n    publicKey,\n    signTx,\n    signBytes: getSignBytes(sign),\n  }\n}\n", "import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\n\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\nexport const getSystemVersionStruct = (\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n): Record<string, any> => {\n  const constant = lookupFn.metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"Version\")!\n\n  const systemVersion = lookupFn(constant.type)\n  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec\n\n  if (systemVersion.type !== \"struct\") throw new Error(\"not a struct\")\n  return systemVersionDec(constant.value)\n}\n", "import { Bytes, enhanceEncoder, u16 } from \"@polkadot-api/substrate-bindings\"\n\nfunction trailingZeroes(n: number) {\n  let i = 0\n  while (!(n & 1)) {\n    i++\n    n >>= 1\n  }\n  return i\n}\n\nexport const mortal = enhanceEncoder(\n  Bytes(2)[0],\n  (value: { period: number; phase: number }) => {\n    const factor = Math.max(value.period >> 12, 1)\n    const left = Math.min(Math.max(trailingZeroes(value.period) - 1, 1), 15)\n    const right = (value.phase / factor) << 4\n    return u16[0](left | right)\n  },\n)\n", "import {\n  Bytes,\n  compact,\n  Option,\n  Struct,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const [ChargeAssetTxPaymentEnc] = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n})\n", "import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport { Encoder } from \"@polkadot-api/substrate-bindings\"\nimport { OfflineTxExtensions } from \"../types\"\nimport { fromHex, mapObject } from \"@polkadot-api/utils\"\nimport { getSystemVersionStruct } from \"./system-version\"\nimport { mortal } from \"./mortal-enc\"\nimport { ChargeAssetTxPaymentEnc } from \"./charge-asset-tx-enc\"\n\nconst empty = new Uint8Array()\nconst zero = Uint8Array.from([0])\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\n\nconst value = (value: Uint8Array) => ({\n  value,\n  additionalSigned: empty,\n})\nconst additionalSigned = (additionalSigned: Uint8Array) => ({\n  value: empty,\n  additionalSigned,\n})\nconst both = (value: Uint8Array, additionalSigned: Uint8Array) => ({\n  value,\n  additionalSigned,\n})\n\nexport const getSignExtensionsCreator = (\n  genesis: Uint8Array,\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n) => {\n  const signedExtensionsEncoders: Record<string, [Encoder<any>, Encoder<any>]> =\n    {}\n  lookupFn.metadata.extrinsic.signedExtensions.forEach(\n    ({ identifier, type, additionalSigned }) => {\n      signedExtensionsEncoders[identifier] = [type, additionalSigned].map(\n        (x) => dynamicBuilder.buildDefinition(x)[0],\n      ) as [Encoder<any>, Encoder<any>]\n    },\n  )\n\n  return <Asset>({\n    mortality,\n    tip = 0n,\n    nonce,\n    customSignedExtensions = {},\n    ...rest\n  }: OfflineTxExtensions<Asset>): Record<\n    string,\n    { identifier: string; value: Uint8Array; additionalSigned: Uint8Array }\n  > => {\n    const invalidKeys: string[] = []\n    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder)\n    const getFromCustomEntry = (key: string) => {\n      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key]\n      const customEntry = customSignedExtensions[key] as any\n      try {\n        return mapObject(\n          {\n            value: valueEnc,\n            additionalSigned: additionalEnc,\n          },\n          (encoder, key) => {\n            const input = customEntry?.[key]\n            // if the encoder is _void, then the input value is ignored, so no harm in passing `undefined`\n            // only an `Option` encoder will accept `undefined` as an input without crashing\n            return input instanceof Uint8Array ? input : encoder(input)\n          },\n        )\n      } catch {\n        // this means that a non optional custom signed-extension has not received its value\n        invalidKeys.push(key)\n        return null\n      }\n    }\n\n    const result = mapObject(\n      signedExtensionsEncoders,\n      ([valueEnc, additionalEnc], key) => {\n        if (customSignedExtensions[key]) return getFromCustomEntry(key)\n\n        switch (key) {\n          case \"CheckNonce\":\n            return value(valueEnc(nonce))\n\n          case \"CheckMortality\":\n            return mortality.mortal\n              ? both(\n                  mortal({\n                    period: mortality.period,\n                    phase: mortality.startAtBlock.height % mortality.period,\n                  }),\n                  fromHex(mortality.startAtBlock.hash),\n                )\n              : both(zero, genesis)\n\n          case \"ChargeTransactionPayment\":\n            return value(valueEnc(tip))\n\n          case \"ChargeAssetTxPayment\":\n            return value(\n              ChargeAssetTxPaymentEnc({\n                tip,\n                asset: (rest as any).asset,\n              }),\n            )\n\n          case \"CheckGenesis\":\n            return additionalSigned(genesis)\n\n          case \"CheckMetadataHash\":\n            return both(zero, zero)\n\n          case \"CheckSpecVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"spec_version\"]),\n            )\n\n          case \"CheckTxVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"transaction_version\"]),\n            )\n\n          default:\n            return getFromCustomEntry(key)\n        }\n      },\n    )\n\n    invalidKeys.forEach((key) => {\n      delete result[key]\n    })\n    return mapObject(result, (x, identifier) => ({ ...x, identifier })) as any\n  }\n}\n", "import { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { HexString, u16, u32, u64, u8 } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  filter,\n  map,\n  mergeMap,\n  of,\n  scan,\n  startWith,\n  switchMap,\n  take,\n} from \"rxjs\"\nimport { getSignExtensionsCreator } from \"./signed-extensions\"\nimport { CustomSignedExtensionValues } from \"./types\"\n\ntype HintedSignedExtensions = Partial<{\n  tip: bigint\n  mortality: { mortal: false } | { mortal: true; period: number }\n  asset: Uint8Array\n  nonce: number\n}>\n\nconst NONCE_RUNTIME_CALL = \"AccountNonceApi_account_nonce\"\nconst lenToDecoder = {\n  1: u8.dec,\n  2: u16.dec,\n  4: u32.dec,\n  8: u64.dec,\n}\n\nconst getNonceAtBlock$ = (\n  call$: ChainHead$[\"call$\"],\n  from: HexString,\n  at: string,\n) =>\n  call$(at, NONCE_RUNTIME_CALL, from).pipe(\n    map((result) => {\n      const bytes = fromHex(result)\n      const decoder = lenToDecoder[bytes.length as 2 | 4 | 8]\n      if (!decoder)\n        throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`)\n      return decoder(bytes)\n    }),\n  )\n\nexport const createTx: (\n  chainHead: ChainHead$,\n  signer: PolkadotSigner,\n  callData: Uint8Array,\n  atBlock: BlockInfo,\n  customSignExt: Record<string, CustomSignedExtensionValues>,\n  hinted?: HintedSignedExtensions,\n) => Observable<Uint8Array> = (\n  chainHead,\n  signer,\n  callData,\n  atBlock,\n  customSignedExtensions,\n  hinted = {},\n) =>\n  combineLatest([\n    hinted.nonce\n      ? of(hinted.nonce)\n      : getNonce$(chainHead, toHex(signer.publicKey)),\n    chainHead.getRuntimeContext$(atBlock.hash),\n    chainHead.genesis$,\n  ]).pipe(\n    take(1),\n    mergeMap(([nonce, ctx, genesis]) => {\n      const signExtCreator = getSignExtensionsCreator(\n        fromHex(genesis),\n        ctx.lookup,\n        ctx.dynamicBuilder,\n      )\n\n      const mortality: HintedSignedExtensions[\"mortality\"] =\n        hinted.mortality ?? { period: 64, mortal: true }\n\n      const signExtensions = signExtCreator({\n        nonce: nonce as number,\n        tip: hinted.tip ?? 0n,\n        mortality: mortality.mortal\n          ? {\n              mortal: true,\n              period: mortality.period,\n              startAtBlock: {\n                height: atBlock.number,\n                hash: atBlock.hash,\n              },\n            }\n          : { mortal: false },\n        customSignedExtensions,\n      })\n\n      return signer.signTx(\n        callData,\n        signExtensions,\n        ctx.metadataRaw,\n        atBlock.number,\n      )\n    }),\n  )\n\nconst getNonce$ = (chainHead: ChainHead$, from: HexString) => {\n  const followHead$ = (head: string) =>\n    chainHead.newBlocks$.pipe(\n      scan((acc, block) => (block.parent === acc ? block.hash : acc), head),\n      startWith(head),\n      distinctUntilChanged(),\n    )\n  const followNonce$ = (head: string) =>\n    followHead$(head).pipe(\n      take(2),\n      switchMap((hash) => getNonceAtBlock$(chainHead.call$, from, hash)),\n    )\n  const getHeadsNonce$ = (heads: string[]) =>\n    combineLatest(\n      heads.map((head) =>\n        followNonce$(head).pipe(\n          map((value) => ({\n            success: true as const,\n            value,\n          })),\n          catchError((err) =>\n            of({\n              success: false as const,\n              value: err,\n            }),\n          ),\n        ),\n      ),\n    ).pipe(take(1))\n\n  return chainHead.pinnedBlocks$.pipe(\n    filter((v) => !v.recovering && v.blocks.size > 0),\n    take(1),\n    map(({ blocks, best }) => {\n      // Grab only the heads: those blocks above the best that don't have children and are not getting pruned\n      const bestBlock = blocks.get(best)!\n      return [...blocks.values()]\n        .filter(\n          (v) =>\n            !v.unpinnable &&\n            v.children.size === 0 &&\n            v.number >= bestBlock.number,\n        )\n        .map((v) => v.hash)\n    }),\n    switchMap(getHeadsNonce$),\n    map((result) => {\n      const winner = result.reduce(\n        (acc: bigint | number | null, v) =>\n          v.success ? (v.value >= (acc ?? 0) ? v.value : acc) : acc,\n        null,\n      )\n\n      if (winner == null) {\n        // We must have at least one error\n        throw result[0].value\n      }\n      return winner\n    }),\n  )\n}\n", "import { Observable } from \"rxjs\"\n\nlet NOTIN = {}\nexport const continueWith =\n  <I, O>(\n    mapper: (input: I) => Observable<O>,\n  ): ((source: Observable<I>) => Observable<I | O>) =>\n  (source) =>\n    new Observable((observer) => {\n      let latestValue: I = NOTIN as I\n      let subscription = source.subscribe({\n        next(v) {\n          observer.next((latestValue = v))\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (latestValue === NOTIN) observer.complete()\n          else subscription = mapper(latestValue).subscribe(observer)\n        },\n      })\n\n      return () => {\n        subscription.unsubscribe()\n      }\n    })\n", "import {\n  Binary,\n  Blake2256,\n  HexString,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  concat,\n  distinctUntilChanged,\n  filter,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n} from \"rxjs\"\nimport {\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\n// TODO: make it dynamic based on the tx-function of the client\nconst hashFromTx = (tx: HexString) => toHex(Blake2256(fromHex(tx)))\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        found: true\n        hash: string\n        number: number\n        index: number\n        events: any\n      }\n    | { found: false; validity: ResultPayload<any, any> | null }\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          found: true\n          hash: string\n          number: number\n          index: number\n          events: any\n        }\n      | { found: false; validity: ResultPayload<any, any> | null }\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n      let analyzedNumber = pinnedBlocks.blocks.get(current)!.number\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n        analyzedNumber--\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        analyzedNumber <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (found && latestState?.found && latestState.hash === analyzed.hash) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = analyzed.found.type\n          ? {\n              found: found as true,\n              hash: analyzed.hash,\n              number: analyzedNumber,\n              index: analyzed.found.index,\n              events: analyzed.found.events,\n            }\n          : {\n              found: found as false,\n              validity: analyzed.found.validity,\n            }),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (analyzed.found.validity?.success === false)\n          observer.error(new InvalidTxError(analyzed.found.validity.value))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => ({ ...x.event, topics: x.topics }))\n\n  const lastEvent = events[events.length - 1]\n  if (\n    lastEvent.type === \"System\" &&\n    lastEvent.value.type === \"ExtrinsicFailed\"\n  ) {\n    return {\n      ok: false,\n      events,\n      dispatchError: lastEvent.value.value.dispatch_error,\n    }\n  }\n\n  return { ok: true, events }\n}\n\n/*\ntype TransactionValidityError = Enum<{\n  Invalid: Enum<{\n    Call: undefined\n    Payment: undefined\n    Future: undefined\n    Stale: undefined\n    BadProof: undefined\n    AncientBirthBlock: undefined\n    ExhaustsResources: undefined\n    Custom: number\n    BadMandatory: undefined\n    MandatoryValidation: undefined\n    BadSigner: undefined\n  }>\n  Unknown: Enum<{\n    CannotLookup: undefined\n    NoUnsignedValidator: undefined\n    Custom: number\n  }>\n}>\n*/\n\nexport class InvalidTxError extends Error {\n  error: any // likely to be a `TransactionValidityError`\n  constructor(e: any) {\n    super(\n      JSON.stringify(\n        e,\n        (_, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value instanceof Binary ? value.asHex() : value\n        },\n        2,\n      ),\n    )\n    this.name = \"InvalidTxError\"\n    this.error = e\n  }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  at?: HexString,\n  emitSign = false,\n): Observable<TxEvent> => {\n  const txHash = hashFromTx(tx)\n  const getTxEvent = <\n    Type extends TxEvent[\"type\"],\n    Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n  >(\n    type: Type,\n    rest: Rest,\n  ): TxEvent & { type: Type } =>\n    ({\n      type,\n      txHash,\n      ...rest,\n    }) as any\n\n  const at$ = chainHead.pinnedBlocks$.pipe(\n    take(1),\n    map((blocks) => {\n      const block = blocks.blocks.get(at!)\n      return block ? block.hash : blocks.finalized\n    }),\n  )\n\n  const validate$: Observable<never> = at$.pipe(\n    mergeMap((at) =>\n      chainHead.validateTx$(at, tx).pipe(\n        filter((x) => !x.success),\n        map((x) => {\n          throw new InvalidTxError(x.value)\n        }),\n      ),\n    ),\n  )\n\n  const track$ = new Observable<AnalyzedBlock>((observer) => {\n    const subscription = chainHead.trackTx$(tx).subscribe(observer)\n    subscription.add(\n      broadcastTx$(tx).subscribe({\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n    return subscription\n  })\n\n  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(\n    map((x) => {\n      if (!x.found)\n        return getTxEvent(\"txBestBlocksState\", {\n          found: false,\n          isValid: x.validity?.success !== false,\n        })\n\n      return getTxEvent(\"txBestBlocksState\", {\n        found: true,\n        block: {\n          index: x.index,\n          number: x.number,\n          hash: x.hash,\n        },\n        ...getTxSuccessFromSystemEvents(x.events, x.index),\n      })\n    }),\n  )\n\n  return concat(\n    emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n    validate$,\n    of(getTxEvent(\"broadcasted\", {})),\n    bestBlockState$.pipe(\n      continueWith(({ found, type, ...rest }) =>\n        found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n      ),\n    ),\n  )\n}\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n", "import type { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getPolkadotSigner } from \"@polkadot-api/signer\"\nimport {\n  _void,\n  AccountId,\n  Binary,\n  compactBn,\n  Decoder,\n  Enum,\n  Struct,\n  u128,\n  u32,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  combineLatest,\n  firstValueFrom,\n  map,\n  mergeMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport { PlainDescriptor } from \"@/descriptors\"\nimport {\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"../compatibility\"\nimport { createTx } from \"./create-tx\"\nimport { InvalidTxError, submit, submit$ } from \"./submit-fns\"\nimport {\n  PaymentInfo,\n  TxCall,\n  TxEntry,\n  TxObservable,\n  TxOptions,\n  TxPromise,\n  TxSignFn,\n} from \"./types\"\nimport {\n  isCompatible,\n  mapLookupToTypedef,\n} from \"@polkadot-api/metadata-compatibility\"\n\nexport { submit, submit$, InvalidTxError }\n\nconst accountIdEnc = AccountId().enc\nconst fakeSignature = new Uint8Array(64)\nconst fakeSignatureEth = new Uint8Array(65)\nconst getFakeSignature = (isEth: boolean) => () =>\n  isEth ? fakeSignatureEth : fakeSignature\n\nconst [, queryInfoDecFallback] = Struct({\n  weight: Struct({\n    ref_time: compactBn,\n    proof_size: compactBn,\n  }),\n  class: Variant({\n    Normal: _void,\n    Operational: _void,\n    Mandatory: _void,\n  }),\n  partial_fee: u128,\n})\n\nexport const createTxEntry = <\n  D,\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends PlainDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  chainHead: ChainHead$,\n  broadcast: (tx: string) => Observable<never>,\n  {\n    isCompatible: isCompatibleHelper,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    getRuntimeTypedef,\n  }: CompatibilityHelper,\n  checkCompatibility: boolean,\n): TxEntry<D, Arg, Pallet, Name, Asset> => {\n  const fn = (arg?: Arg): any => {\n    const getCallDataWithContext = (\n      runtime: CompatibilityToken | RuntimeToken,\n      arg: any,\n      txOptions: Partial<{ asset: any }> = {},\n    ) => {\n      const ctx = getCompatibilityApi(runtime).runtime()\n      const { dynamicBuilder, assetId, lookup } = ctx\n      let codecs\n      try {\n        codecs = dynamicBuilder.buildCall(pallet, name)\n      } catch {\n        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`)\n      }\n      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg))\n        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n      let returnOptions = txOptions\n      if (txOptions.asset) {\n        if (\n          assetId == null ||\n          !isCompatible(\n            txOptions.asset,\n            mapLookupToTypedef(lookup(assetId)),\n            (id) => getRuntimeTypedef(ctx, id),\n          )\n        )\n          throw new Error(`Incompatible runtime asset`)\n        returnOptions = {\n          ...txOptions,\n          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset),\n        }\n      }\n\n      const { location, codec } = codecs\n      return {\n        callData: Binary.fromBytes(\n          mergeUint8(new Uint8Array(location), codec.enc(arg)),\n        ),\n        options: returnOptions,\n      }\n    }\n\n    const getCallData$ = (arg: any, options: Partial<{ asset: any }> = {}) =>\n      compatibleRuntime$(chainHead, null).pipe(\n        map(([runtime]) => getCallDataWithContext(runtime, arg, options)),\n      )\n\n    const getEncodedData: TxCall = (\n      token?: CompatibilityToken | RuntimeToken,\n    ): any => {\n      if (!token)\n        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n      return getCallDataWithContext(token, arg).callData\n    }\n\n    const sign$ = (\n      from: PolkadotSigner,\n      { ..._options }: Omit<TxOptions<{}>, \"at\">,\n      atBlock: BlockInfo,\n    ) =>\n      getCallData$(arg, _options).pipe(\n        mergeMap(({ callData, options }) =>\n          createTx(\n            chainHead,\n            from,\n            callData.asBytes(),\n            atBlock,\n            _options.customSignedExtensions || {},\n            options,\n          ),\n        ),\n      )\n\n    const _sign = (\n      from: PolkadotSigner,\n      { at, ..._options }: TxOptions<{}> = {},\n    ) => {\n      return (\n        !at || at === \"finalized\"\n          ? chainHead.finalized$\n          : at === \"best\"\n            ? chainHead.best$\n            : chainHead.bestBlocks$.pipe(\n                map((x) => x.find((b) => b.hash === at)),\n              )\n      ).pipe(\n        take(1),\n        mergeMap((atBlock) =>\n          atBlock\n            ? sign$(from, _options, atBlock).pipe(\n                map((signed) => ({\n                  tx: toHex(signed),\n                  block: atBlock,\n                })),\n              )\n            : throwError(() => new Error(`Uknown block ${at}`)),\n        ),\n      )\n    }\n\n    const sign: TxSignFn<Asset> = (from, options) =>\n      firstValueFrom(_sign(from, options)).then((x) => x.tx)\n\n    const signAndSubmit: TxPromise<Asset> = (from, _options) =>\n      firstValueFrom(_sign(from, _options)).then(({ tx, block }) =>\n        submit(chainHead, broadcast, tx, block.hash),\n      )\n\n    const signSubmitAndWatch: TxObservable<Asset> = (from, _options) =>\n      _sign(from, _options).pipe(\n        mergeMap(({ tx, block }) =>\n          submit$(chainHead, broadcast, tx, block.hash, true),\n        ),\n      )\n\n    const getPaymentInfo = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => {\n      if (typeof from === \"string\")\n        from = from.startsWith(\"0x\") ? fromHex(from) : accountIdEnc(from)\n      const isEth = from.length === 20\n      const fakeSigner = getPolkadotSigner(\n        from,\n        isEth ? \"Ecdsa\" : \"Sr25519\",\n        getFakeSignature(isEth),\n      )\n      const encoded = fromHex(await sign(fakeSigner, _options))\n      const args = toHex(mergeUint8(encoded, u32.enc(encoded.length)))\n\n      const decoder$: Observable<Decoder<PaymentInfo>> = chainHead\n        .getRuntimeContext$(null)\n        .pipe(\n          map((ctx) => {\n            try {\n              return ctx.dynamicBuilder.buildRuntimeCall(\n                \"TransactionPaymentApi\",\n                \"query_info\",\n              ).value[1]\n            } catch {\n              return queryInfoDecFallback\n            }\n          }),\n        )\n\n      const call$ = chainHead.call$(\n        null,\n        \"TransactionPaymentApi_query_info\",\n        args,\n      )\n\n      return firstValueFrom(\n        combineLatest([call$, decoder$]).pipe(\n          map(([result, decoder]) => decoder(result)),\n        ),\n      )\n    }\n\n    const getEstimatedFees = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => (await getPaymentInfo(from, _options)).partial_fee\n\n    return {\n      getPaymentInfo,\n      getEstimatedFees,\n      decodedCall: {\n        type: pallet,\n        value: Enum(name, arg as any),\n      },\n      getEncodedData,\n      sign,\n      signSubmitAndWatch,\n      signAndSubmit,\n    }\n  }\n\n  return Object.assign(fn, {\n    getCompatibilityLevel,\n    isCompatible: isCompatibleHelper,\n  })\n}\n", "import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies.\n *\n * @returns\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n", "import type { SUSPENSE as iSUSPENSE } from \"./index.d\"\nexport const SUSPENSE: iSUSPENSE = Symbol(\"SUSPENSE\") as any\nexport type SUSPENSE = iSUSPENSE\n", "import type { StatePromise as IStatePromise } from \"./index.d\"\n\nexport class StatePromise<T> extends Promise<T> implements IStatePromise<T> {\n  constructor(cb: (res: (value: T) => void, rej: any) => void) {\n    super(cb)\n  }\n}\n", "import type {\n  NoSubscribersError as INoSubscribersError,\n  EmptyObservableError as IEmptyObservableError,\n} from \"./index.d\"\n\nexport class NoSubscribersError extends Error implements INoSubscribersError {\n  constructor() {\n    super()\n    this.name = \"NoSubscribersError\"\n  }\n}\n\nexport class EmptyObservableError\n  extends Error\n  implements IEmptyObservableError\n{\n  constructor() {\n    super()\n    this.name = \"EmptyObservableError\"\n  }\n}\n", "export const EMPTY_VALUE: any = {}\n", "import { Observable } from \"rxjs\"\nimport StateObservable from \"../internal/state-observable\"\n\nfunction cloneProps<T>(\n  internal: StateObservable<T>,\n  external: StateObservable<T>,\n) {\n  external.getValue = internal.getValue\n  external.getRefCount = internal.getRefCount\n  external.pipeState = internal.pipeState\n  if ((internal as any).getDefaultValue) {\n    ;(external as any).getDefaultValue = (internal as any).getDefaultValue\n  }\n}\n\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n) {\n  const cache = new NestedMap<A, StateObservable<O>>()\n  const getDefaultValue = (\n    typeof defaultValue === \"function\" ? defaultValue : () => defaultValue\n  ) as (...args: A) => O\n\n  const getSharedObservables$ = (input: A): StateObservable<O> => {\n    for (let i = input.length - 1; input[i] === undefined && i > -1; i--) {\n      input.splice(-1)\n    }\n    const keys = [input.length, ...input] as any as A\n    const cachedVal = cache.get(keys)\n\n    if (cachedVal !== undefined) {\n      return cachedVal\n    }\n\n    const sharedObservable$ = new StateObservable(\n      getObservable(...input),\n      getDefaultValue(...input),\n      () => {\n        cache.delete(keys)\n      },\n    )\n\n    const publicShared$ = new Observable<O>((subscriber) => {\n      const inCache = cache.get(keys)\n      let source$: StateObservable<O> = sharedObservable$\n\n      if (!inCache) {\n        cache.set(keys, result)\n      } else if (inCache !== publicShared$) {\n        source$ = inCache\n        cloneProps(source$, publicShared$)\n      }\n\n      return source$.subscribe(subscriber)\n    }) as StateObservable<O>\n    cloneProps(sharedObservable$, publicShared$)\n\n    const result: StateObservable<O> = publicShared$\n\n    cache.set(keys, result)\n    return result\n  }\n\n  return (...input: A) => getSharedObservables$(input)\n}\n\nclass NestedMap<K extends [], V extends Object> {\n  private root: Map<K, any>\n  constructor() {\n    this.root = new Map()\n  }\n\n  get(keys: K[]): V | undefined {\n    let current: any = this.root\n    for (let i = 0; i < keys.length; i++) {\n      current = current.get(keys[i])\n      if (!current) return undefined\n    }\n    return current\n  }\n\n  set(keys: K[], value: V): void {\n    let current: Map<K, any> = this.root\n    let i\n    for (i = 0; i < keys.length - 1; i++) {\n      let nextCurrent = current.get(keys[i])\n      if (!nextCurrent) {\n        nextCurrent = new Map<K, any>()\n        current.set(keys[i], nextCurrent)\n      }\n      current = nextCurrent\n    }\n    current.set(keys[i], value)\n  }\n\n  delete(keys: K[]): void {\n    const maps: Map<K, any>[] = [this.root]\n    let current: Map<K, any> = this.root\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      maps.push((current = current.get(keys[i])))\n    }\n\n    let mapIdx = maps.length - 1\n    maps[mapIdx].delete(keys[mapIdx])\n\n    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {\n      maps[mapIdx].delete(keys[mapIdx])\n    }\n  }\n}\n", "import {\n  noop,\n  Observable,\n  OperatorFunction,\n  Subject,\n  Subscriber,\n  Subscription,\n} from \"rxjs\"\nimport { EmptyObservableError, NoSubscribersError } from \"../errors\"\nimport { StatePromise } from \"../StatePromise\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport { EMPTY_VALUE } from \"./empty-value\"\n\nexport default class StateObservable<T> extends Observable<T> {\n  private subject: Subject<T> | null = null\n  private subscription: Subscriber<T> | null = null\n  private refCount = 0\n  private currentValue: T = EMPTY_VALUE\n  private promise: {\n    res: (value: Exclude<T, SUSPENSE>) => void\n    rej: (v: any) => void\n    p: StatePromise<Exclude<T, SUSPENSE>>\n  } | null = null\n\n  constructor(\n    source$: Observable<T>,\n    private defaultValue: T,\n    teardown = noop,\n  ) {\n    super((subscriber) => {\n      const subscriberWithoutComplete = new Subscriber({\n        next: subscriber.next.bind(subscriber),\n        error: subscriber.error.bind(subscriber),\n        complete: noop,\n      })\n\n      this.refCount++\n      let innerSub: Subscription\n\n      subscriber.add(() => {\n        this.refCount--\n        innerSub.unsubscribe()\n        if (this.refCount === 0) {\n          this.currentValue = EMPTY_VALUE\n          if (this.subscription) {\n            this.subscription.unsubscribe()\n          }\n          teardown()\n          this.subject?.complete()\n          this.subject = null\n          this.subscription = null\n          if (this.promise) {\n            this.promise.rej(new NoSubscribersError())\n            this.promise = null\n          }\n        }\n      })\n\n      if (!this.subject) {\n        this.subject = new Subject<T>()\n        innerSub = this.subject.subscribe(subscriberWithoutComplete)\n        this.subscription = null\n        this.subscription = new Subscriber<T>({\n          next: (value: T) => {\n            if (this.promise && (value as any) !== SUSPENSE) {\n              this.promise.res(value as any)\n              this.promise = null\n            }\n            this.subject!.next((this.currentValue = value))\n          },\n          error: (err: any) => {\n            this.subscription = null\n            const subject = this.subject\n            this.subject = null\n            this.currentValue = EMPTY_VALUE\n\n            const rej = this.promise?.rej\n            if (rej && err === SUSPENSE) {\n              this.promise!.rej = () => {\n                rej!(err)\n              }\n            }\n            subject!.error(err)\n            if (rej && this.promise) {\n              this.promise.rej = rej\n            }\n          },\n          complete: () => {\n            this.subscription = null\n            if (this.promise) {\n              this.promise.rej(new EmptyObservableError())\n              this.promise = null\n            }\n\n            if (this.currentValue !== EMPTY_VALUE)\n              return this.subject!.complete()\n\n            if (defaultValue === EMPTY_VALUE) {\n              const subject = this.subject\n              this.subject = null\n              return subject!.error(new EmptyObservableError())\n            }\n\n            this.subject!.next((this.currentValue = defaultValue))\n            this.subject!.complete()\n          },\n        })\n        source$.subscribe(this.subscription)\n        if (defaultValue !== EMPTY_VALUE && this.currentValue === EMPTY_VALUE) {\n          this.subject!.next((this.currentValue = defaultValue))\n        }\n      } else {\n        innerSub = this.subject.subscribe(subscriberWithoutComplete)\n        if (this.currentValue !== EMPTY_VALUE) {\n          subscriber.next(this.currentValue)\n        }\n      }\n    })\n\n    if (defaultValue === EMPTY_VALUE) {\n      // Remove the getDefaultValue property from this object, as it's not part of the interface\n      delete this.getDefaultValue\n    }\n  }\n\n  pipeState = (...ops: OperatorFunction<any, any>[]) => {\n    const result = (super.pipe as any)(...ops)\n    return result instanceof StateObservable\n      ? result\n      : new StateObservable(result, EMPTY_VALUE)\n  }\n\n  getRefCount = () => {\n    return this.refCount\n  }\n  getValue = (): Exclude<T, SUSPENSE> | StatePromise<Exclude<T, SUSPENSE>> => {\n    if (this.promise) return this.promise.p\n    if (\n      this.currentValue !== EMPTY_VALUE &&\n      (this.currentValue as any) !== SUSPENSE\n    )\n      return this.currentValue as any\n    if (this.defaultValue !== EMPTY_VALUE) return this.defaultValue as any\n    if (this.refCount === 0) throw new NoSubscribersError()\n\n    const promise = new StatePromise<Exclude<T, SUSPENSE>>((res, rej) => {\n      this.promise = { res, rej, p: null as any }\n    })\n    this.promise!.p = promise\n    return promise\n  }\n  getDefaultValue? = () => {\n    return this.defaultValue\n  }\n}\n", "import { Observable } from \"rxjs\"\nimport StateObservable from \"../internal/state-observable\"\n\nexport default function state<T>(observable: Observable<T>, defaultValue: T) {\n  return new StateObservable<T>(observable, defaultValue)\n}\n", "import type { state as IState } from \"../index.d\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport stateFactory from \"./stateFactory\"\nimport stateSingle from \"./stateSingle\"\n\nexport const state: typeof IState = (...args: any[]) =>\n  (typeof args[0] === \"function\" ? (stateFactory as any) : stateSingle)(\n    args[0],\n    args.length > 1 ? args[1] : EMPTY_VALUE,\n  )\n", "import { Observable } from \"rxjs\"\nimport type { withDefault as IWithDefault } from \"./index.d\"\nimport { state } from \"./state\"\n\nexport const withDefault: typeof IWithDefault =\n  <D>(defaultValue: D) =>\n  <T>(source$: Observable<T>) =>\n    state<D | T>(source$, defaultValue)\n", "import { Observable, Subscriber } from \"rxjs\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport { sinkSuspense as ISinkSuspense } from \"../index.d\"\n\ntype SubscriberWithInner<T> = Subscriber<T> & { inner: Subscriber<any> }\nexport const sinkSuspense: typeof ISinkSuspense = () => {\n  return <T>(source$: Observable<T>) => {\n    let waiting: SubscriberWithInner<any> | null = null\n\n    return new Observable((observer) => {\n      if (waiting) {\n        waiting.inner = observer\n        const outter = waiting!\n        return () => {\n          if (outter.inner === observer) outter.unsubscribe()\n        }\n      }\n\n      let outter = new Subscriber<T | SUSPENSE>({\n        next(value: T | SUSPENSE) {\n          if (value === SUSPENSE) {\n            waiting = outter\n            outter.inner.error(value)\n            waiting = null\n            if (outter.inner === observer) {\n              outter.unsubscribe()\n            }\n          } else {\n            outter.inner.next(value)\n          }\n        },\n        error(e: unknown) {\n          outter.inner.error(e)\n        },\n        complete() {\n          outter.inner.complete()\n        },\n      }) as SubscriberWithInner<T>\n\n      outter.inner = observer\n      source$.subscribe(outter)\n\n      return () => {\n        if (outter.inner === observer) outter.unsubscribe()\n      }\n    })\n  }\n}\n", "import { Observable, Subscriber } from \"rxjs\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport type { liftSuspense as ILiftSuspense } from \"../index.d\"\n\nexport const liftSuspense: typeof ILiftSuspense = () => {\n  return <T>(source$: Observable<T>): Observable<T | SUSPENSE> => {\n    return new Observable((observer) => {\n      let subscriber: Subscriber<any>\n\n      const setSubscriber = () => {\n        subscriber = new Subscriber<T>({\n          next(v: T) {\n            observer.next(v as any)\n          },\n          error(e: unknown) {\n            if (e === SUSPENSE) {\n              observer.next(e)\n              setSubscriber()\n            } else observer.error(e)\n          },\n          complete() {\n            observer.complete()\n          },\n        })\n        source$.subscribe(subscriber)\n      }\n\n      setSubscriber()\n\n      return () => {\n        subscriber.unsubscribe()\n      }\n    })\n  }\n}\n", "import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  PinnedBlocks,\n  BlockInfo,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport {\n  BlockNotPinnedError,\n  isBestOrFinalizedBlock,\n} from \"@polkadot-api/observable-client\"\nimport {\n  catchError,\n  combineLatest,\n  delay,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  take,\n  takeUntil,\n  throwError,\n  withLatestFrom,\n} from \"rxjs\"\nimport { selfDependent, lossLessExhaustMap } from \"@/utils\"\nimport { state } from \"@rx-state/core\"\n\ninterface StorageEntry {\n  key: HexString\n  value: HexString\n  dec: {\n    args: Array<any>\n    value: any\n  }\n}\n\ntype Deltas = {\n  upserted: Array<StorageEntry>\n  deleted: Array<StorageEntry>\n}\n\ninterface MemoryBlock {\n  prev: HexString | null\n  block: BlockInfo\n  rootHash: string\n  entries: Array<StorageEntry>\n  deltas: Deltas | null\n}\n\ntype MemoryBlocks = {\n  blocks: Record<HexString, MemoryBlock>\n  finalized: HexString\n}\n\nconst getDiff = (\n  _prev: Array<StorageEntry>,\n  _current: Array<StorageEntry>,\n  patch: (input: StorageEntry) => StorageEntry,\n): Pick<MemoryBlock, \"entries\" | \"deltas\"> => {\n  const current = new Map(_current.map((x) => [x.key, x]))\n  const prev = new Map(_prev.map((x) => [x.key, x]))\n\n  const upserted: Map<string, StorageEntry> = new Map()\n  const deleted: Array<StorageEntry> = []\n\n  _current.forEach((value) => {\n    const { key } = value\n    const prevVal = prev.get(key)\n    if (!prevVal || prevVal.value !== value.value)\n      upserted.set(key, patch(value))\n  })\n\n  _prev.forEach((x) => {\n    if (!current.has(x.key)) deleted.push(x)\n  })\n\n  return {\n    deltas: {\n      deleted,\n      upserted: [...upserted.values()],\n    },\n    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key)!),\n  }\n}\n\nconst findPrevious = (\n  start: HexString,\n  state: MemoryBlocks[\"blocks\"],\n  pinned: PinnedBlocks,\n  includeStart = false,\n) => {\n  try {\n    let target = includeStart ? start : pinned.blocks.get(start)!.parent\n    while (target && !state[target]) target = pinned.blocks.get(target)!.parent!\n\n    if (!target) return null\n    return state[target]\n  } catch {\n    return null\n  }\n}\n\nconst getPatcherFromRuntime =\n  (pallet: string, entry: string) => (runtime: RuntimeContext) => {\n    const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry)\n    return (x: StorageEntry) => {\n      x.dec = {\n        value: value.dec(x.value),\n        args: keys.dec(x.key),\n      }\n      return x\n    }\n  }\n\nexport const createWatchEntries = (\n  blocks$: Observable<PinnedBlocks>,\n  storage: ChainHead$[\"storage$\"],\n  withRuntime: ChainHead$[\"withRuntime\"],\n) => {\n  const getMemoryBlocks$ = state(\n    (pallet: string, entry: string, storageKey: string) => {\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n      const getNextMemoryBlock$ = (\n        prev: MemoryBlock | null,\n        block: BlockInfo,\n      ): Observable<MemoryBlock> => {\n        const isNotCanonical$ = isBestOrFinalizedBlock(\n          blocks$,\n          block.hash,\n        ).pipe(\n          filter((x) => !x),\n          take(1),\n        )\n\n        return storage(\n          block.hash,\n          \"closestDescendantMerkleValue\",\n          () => storageKey,\n        ).pipe(\n          mergeMap((rootHash) => {\n            if (rootHash === prev?.rootHash)\n              return of({\n                ...prev,\n                block,\n                deltas: null,\n                prev: prev.block.hash,\n              })\n\n            return storage(\n              block.hash,\n              \"descendantsValues\",\n              () => storageKey,\n            ).pipe(\n              withRuntime(() => block.hash),\n              map(\n                ([entries, runtimeCtx]) =>\n                  [entries, getPatcher(runtimeCtx)] as const,\n              ),\n              map(\n                ([entries, patcher]): MemoryBlock => ({\n                  prev: prev && prev.block.hash,\n                  rootHash: rootHash!,\n                  block,\n                  ...getDiff(\n                    prev?.entries ?? [],\n                    entries as StorageEntry[],\n                    patcher,\n                  ),\n                }),\n              ),\n            )\n          }),\n          takeUntil(isNotCanonical$),\n          catchError((e) =>\n            e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e),\n          ),\n        )\n      }\n\n      const initial$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.finalized === b.finalized),\n        lossLessExhaustMap(({ blocks, finalized }) =>\n          getNextMemoryBlock$(null, blocks.get(finalized)!),\n        ),\n        take(1),\n        map(\n          (x): MemoryBlocks => ({\n            blocks: { [x.block.hash]: x },\n            finalized: x.block.hash,\n          }),\n        ),\n      )\n\n      const [_memoryBlocks$, connectMemoryBlocks] =\n        selfDependent<MemoryBlocks>()\n      const updates$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.best === b.best),\n        withLatestFrom(_memoryBlocks$),\n        lossLessExhaustMap(([pinned, memoryBlocks]) => {\n          const { best } = pinned\n          const { blocks } = memoryBlocks\n          let target = !blocks[best] ? best : null\n          if (!target) return EMPTY\n\n          const previous = findPrevious(target, blocks, pinned)\n          if (previous)\n            return getNextMemoryBlock$(\n              previous,\n              pinned.blocks.get(target)!,\n            ).pipe(\n              map((x) => {\n                blocks[target!] = x\n                return memoryBlocks\n              }),\n            )\n\n          // This means that there has been a stop event that the pinned-blocks\n          // couldn't recover from. Therefore, we must \"start over\"\n          target = pinned.finalized\n          return getNextMemoryBlock$(\n            blocks[memoryBlocks.finalized],\n            pinned.blocks.get(target)!,\n          ).pipe(\n            map((x) => {\n              x.prev = null\n              return {\n                blocks: { [target]: x },\n                finalized: target,\n              }\n            }),\n          )\n        }),\n      )\n\n      return merge(initial$, updates$).pipe(connectMemoryBlocks())\n    },\n  )\n\n  const getBestOrFinalized =\n    (isFinalized: boolean) =>\n    (pallet: string, entry: string, storageKey: string) => {\n      const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey)\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n\n      const prop = isFinalized ? \"finalized\" : \"best\"\n\n      return combineLatest([\n        memoryBlocks$.pipe(delay(0)),\n        blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop])),\n      ]).pipe(\n        map(([state, blocks]) =>\n          findPrevious(blocks[prop], state.blocks, blocks, true),\n        ),\n        filter(Boolean),\n        distinctUntilChanged(),\n        startWith(null),\n        pairwise(),\n        withLatestFrom(memoryBlocks$),\n        withRuntime(([[, _latest]]) => _latest!.block.hash),\n        map(\n          ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) =>\n            [\n              prevUpdate,\n              latest!,\n              memoryBlocks,\n              getPatcher(runtimeCtx),\n            ] as const,\n        ),\n        mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {\n          if (!prevUpdate) return [latest]\n\n          let ancestor: MemoryBlock | null = latest\n          const updates: Array<MemoryBlock> = []\n          while (ancestor && ancestor.block.number > prevUpdate.block.number) {\n            updates.unshift(ancestor)\n            ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null\n          }\n\n          if (isFinalized) {\n            memoryBlocks.finalized = latest.block.hash\n            if (updates.length) {\n              const { blocks } = memoryBlocks\n              Object.keys(blocks).forEach((key) => {\n                if (blocks[key].block.number < updates[0].block.number)\n                  delete blocks[key]\n              })\n            }\n          }\n\n          if (prevUpdate === ancestor) return updates\n\n          // It's a re-org\n          return [\n            {\n              ...latest,\n              ...(prevUpdate.rootHash === latest.rootHash\n                ? {\n                    entries: prevUpdate.entries,\n                    deltas: null,\n                  }\n                : getDiff(prevUpdate.entries, latest.entries, patcher)),\n            },\n          ]\n        }),\n      )\n    }\n\n  const getFinalized$ = state(getBestOrFinalized(true))\n  const getBest$ = state(getBestOrFinalized(false))\n\n  return (pallet: string, entry: string, args: Array<any>, atBest: boolean) => {\n    const fn = atBest ? getBest$ : getFinalized$\n    const storageKey$ = blocks$.pipe(\n      take(1),\n      mergeMap(\n        (b) =>\n          b.runtimes[b.blocks.get(b[atBest ? \"best\" : \"finalized\"])!.runtime]\n            .runtime,\n      ),\n      map((runtime) =>\n        runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args),\n      ),\n    )\n    return storageKey$.pipe(\n      take(1),\n      mergeMap((storageKey) => fn(pallet, entry, storageKey)),\n      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {\n        const actualDeltas =\n          idx > 0 ? deltas : { deleted: [], upserted: entries }\n\n        return {\n          block: { hash, number, parent },\n          entries: entries.map(toDec),\n          deltas: actualDeltas && {\n            deleted: actualDeltas.deleted.map(toDec),\n            upserted: actualDeltas.upserted.map(toDec),\n          },\n        }\n      }),\n    )\n  }\n}\n\nconst toDec = <T>(x: { dec: T }): T => x.dec\n", "import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport {\n  enumValueEntryPointNode,\n  runtimeCallEntryPoint,\n  singleValueEntryPoint,\n  storageEntryPoint,\n  voidEntryPointNode,\n} from \"@polkadot-api/metadata-compatibility\"\nimport {\n  ChainHead$,\n  RuntimeContext,\n  getObservableClient,\n} from \"@polkadot-api/observable-client\"\nimport { Binary } from \"@polkadot-api/substrate-bindings\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  catchError,\n  defer,\n  firstValueFrom,\n  map,\n  shareReplay,\n} from \"rxjs\"\nimport {\n  CompatibilityToken,\n  OpType,\n  RuntimeToken,\n  compatibilityHelper,\n  createCompatibilityToken,\n  createRuntimeToken,\n  getCompatibilityApi,\n} from \"./compatibility\"\nimport { createConstantEntry } from \"./constants\"\nimport { ChainDefinition } from \"./descriptors\"\nimport { createEventEntry } from \"./event\"\nimport { createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry } from \"./storage\"\nimport { createTxEntry, submit, submit$ } from \"./tx\"\nimport type { AnyApi, PolkadotClient } from \"./types\"\nimport { createWatchEntries } from \"./watch-entries\"\n\nconst createApi = <Unsafe extends true | false, D>(\n  compatibilityToken: Promise<CompatibilityToken | RuntimeToken>,\n  chainHead: ChainHead$,\n  broadcast$: (tx: string) => Observable<never>,\n): AnyApi<Unsafe, D> => {\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const getPallet = (ctx: RuntimeContext, name: string) =>\n    ctx.lookup.metadata.pallets.find((p) => p.name === name)\n\n  const getWatchEntries = createWatchEntries(\n    chainHead.pinnedBlocks$,\n    chainHead.storage$,\n    chainHead.withRuntime,\n  )\n  const query = createProxyPath((pallet, name) =>\n    createStorageEntry(\n      pallet,\n      name,\n      chainHead,\n      getWatchEntries,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getPalletEntryPoint(OpType.Storage, pallet, name),\n        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.storage?.items.find(\n            (s) => s.name === name,\n          )\n          return item == null ? null : storageEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const getEnumEntry = (\n    ctx: RuntimeContext,\n    side: \"args\" | \"values\",\n    id: number | undefined,\n    name: string,\n  ) => {\n    if (id == null) return null\n    const entry = ctx.lookup(id)\n    if (entry.type !== \"enum\") throw new Error(\"Expected enum\")\n\n    if (entry.value[name] == null) return null\n    const node = enumValueEntryPointNode(entry.value[name])\n    return {\n      args: side === \"args\" ? node : voidEntryPointNode,\n      values: side === \"args\" ? voidEntryPointNode : node,\n    }\n  }\n  const tx = createProxyPath((pallet, name) =>\n    createTxEntry(\n      pallet,\n      name,\n      chainHead,\n      broadcast$,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getPalletEntryPoint(OpType.Tx, pallet, name),\n        (ctx) => getEnumEntry(ctx, \"args\", getPallet(ctx, pallet)?.calls, name),\n      ),\n      true,\n    ),\n  )\n\n  const event = createProxyPath((pallet, name) =>\n    createEventEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getPalletEntryPoint(OpType.Event, pallet, name),\n        (ctx) =>\n          getEnumEntry(ctx, \"values\", getPallet(ctx, pallet)?.events, name),\n      ),\n    ),\n  )\n\n  const constants = createProxyPath((pallet, name) =>\n    createConstantEntry(\n      pallet,\n      name,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getPalletEntryPoint(OpType.Const, pallet, name),\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.constants.find(\n            (c) => c.name === name,\n          )?.type\n          return item == null ? null : singleValueEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const apis = createProxyPath((api, method) =>\n    createRuntimeCallEntry(\n      api,\n      method,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getApiEntryPoint(api, method),\n        (ctx) =>\n          runtimeCallEntryPoint(\n            ctx.lookup.metadata.apis\n              .find((a) => a.name === api)!\n              .methods.find((m) => m.name === method)!,\n          ),\n      ),\n    ),\n  )\n\n  const _callDataTx = (\n    callData: Binary,\n    token: CompatibilityToken | RuntimeToken,\n  ) => {\n    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime()\n    try {\n      const decoded = dynamicBuilder\n        .buildDefinition(lookup.call!)\n        .dec(callData.asBytes())\n      const pallet = decoded.type\n      const call = decoded.value.type\n      const args = decoded.value.value\n\n      return createTxEntry(\n        pallet,\n        call,\n        chainHead,\n        broadcast$,\n        compatibilityHelper(\n          compatibilityToken,\n          (r) => r.getPalletEntryPoint(OpType.Tx, pallet, call),\n          (ctx) =>\n            getEnumEntry(ctx, \"args\", getPallet(ctx, pallet)?.calls, call),\n        ),\n        false,\n      )(args)\n    } catch {\n      throw new Error(\"createTx: invalid call data\")\n    }\n  }\n\n  return {\n    query,\n    txFromCallData: (\n      callData: Binary,\n      token?: CompatibilityToken | RuntimeToken,\n    ) =>\n      token\n        ? _callDataTx(callData, token)\n        : compatibilityToken.then((t) => _callDataTx(callData, t)),\n    tx,\n    event,\n    apis,\n    constants,\n  } as any\n}\n\n/**\n * This is the top-level export for `polkadot-api`.\n *\n * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC\n *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),\n *                  which must support the `chainHead`, `transaction` and\n *                  `chainSpec` groups.\n * @example\n *\n *   import { createClient } from \"polkadot-api\"\n *   import { getSmProvider } from \"polkadot-api/sm-provider\"\n *   import { chainSpec } from \"polkadot-api/chains/polkadot\"\n *   import { start } from \"polkadot-api/smoldot\"\n *\n *   const smoldot = start()\n *   const chain = await smoldot.addChain({ chainSpec })\n *\n *   // Connect to the polkadot relay chain.\n *   const client = createClient(getSmProvider(chain))\n *\n */\nexport function createClient(provider: JsonRpcProvider): PolkadotClient {\n  const rawClient: SubstrateClient = createRawClient(provider)\n  const client = getObservableClient(rawClient)\n  const { getChainSpecData } = rawClient\n\n  const { genesis$, ..._chainHead } = client.chainHead$()\n  const chainHead: ChainHead$ = {\n    ..._chainHead,\n    genesis$: defer(getChainSpecData).pipe(\n      map(({ genesisHash }) => genesisHash),\n      catchError(() => genesis$),\n      shareReplay(1),\n    ),\n  }\n\n  const _request: <Reply = any, Params extends Array<any> = any[]>(\n    method: string,\n    params: Params,\n  ) => Promise<Reply> = rawClient.request\n\n  let runtimeToken: Promise<RuntimeToken>\n  const compatibilityToken = new WeakMap<\n    ChainDefinition,\n    Promise<CompatibilityToken<any>>\n  >()\n  const getChainToken = (chainDefinition: ChainDefinition) => {\n    const result =\n      compatibilityToken.get(chainDefinition) ||\n      createCompatibilityToken(chainDefinition, chainHead)\n    compatibilityToken.set(chainDefinition, result)\n    return result\n  }\n  const getRuntimeToken = <D>(): Promise<RuntimeToken<D>> =>\n    (runtimeToken ??= createRuntimeToken(chainHead))\n  const { broadcastTx$ } = client\n  return {\n    getChainSpecData,\n\n    blocks$: chainHead.newBlocks$,\n\n    finalizedBlock$: chainHead.finalized$,\n    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),\n\n    bestBlocks$: chainHead.bestBlocks$,\n    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),\n\n    watchBlockBody: chainHead.body$,\n    getBlockBody: (hash: string) => firstValueFrom(chainHead.body$(hash)),\n\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n\n    submit: (...args) => submit(chainHead, broadcastTx$, ...args),\n    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),\n\n    getTypedApi: <D extends ChainDefinition>(chainDefinition: D) => {\n      const token = getChainToken(chainDefinition)\n      return Object.assign(\n        createApi<false, D>(token, chainHead, broadcastTx$),\n        { compatibilityToken: token },\n      )\n    },\n\n    getUnsafeApi: <D>() => {\n      const token = getRuntimeToken()\n      return Object.assign(createApi<true, D>(token, chainHead, broadcastTx$), {\n        runtimeToken: token,\n      })\n    },\n\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n\n    _request,\n  }\n}\n", "import { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\nimport { ChainDefinition, PlainDescriptor } from \"./descriptors\"\nimport { OfflineTxEntry } from \"./tx\"\nimport {\n  Binary,\n  Enum,\n  metadata as metadataCodec,\n  V14,\n  V15,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { OfflineApi } from \"./types\"\nimport { getSignExtensionsCreator } from \"./tx/signed-extensions\"\n\nconst createOfflineTxEntry = <\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends PlainDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  metadataRaw: Uint8Array,\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>,\n  signExtensionCreator: ReturnType<typeof getSignExtensionsCreator>,\n): OfflineTxEntry<Arg, Pallet, Name, Asset> => {\n  let codecs\n  try {\n    codecs = dynamicBuilder.buildCall(pallet, name)\n  } catch {\n    throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`)\n  }\n  const { location, codec } = codecs\n  const locationBytes = new Uint8Array(location)\n\n  return (arg: Arg) => {\n    const encodedData = Binary.fromBytes(\n      mergeUint8(locationBytes, codec.enc(arg)),\n    )\n\n    return {\n      encodedData,\n      decodedCall: Enum(pallet, Enum(name, arg as any) as any),\n      sign: async (from, extensions) =>\n        toHex(\n          await from.signTx(\n            encodedData.asBytes(),\n            signExtensionCreator(extensions),\n            metadataRaw,\n            extensions.mortality.mortal\n              ? extensions.mortality.startAtBlock.height\n              : 0,\n          ),\n        ),\n    }\n  }\n}\n\n/**\n * Asynchronously create an instance of `OfflineApi`.\n * OfflineApi allows to create and sign transactions and access chain constants.\n *\n * @param chainDefinition  Pass descriptors from `@polkadot-api/descriptors`\n *                         generated by `papi` CLI.\n */\nexport const getOfflineApi: <D extends ChainDefinition>(\n  chainDefinition: D,\n) => Promise<OfflineApi<D>> = async ({ genesis: genesisHex, getMetadata }) => {\n  if (!genesisHex) throw new Error(\"Missing genesis hash\")\n  const genesis = fromHex(genesisHex)\n  const metadataRaw = await getMetadata()\n  const metadata = metadataCodec.dec(metadataRaw).metadata.value as V14 | V15\n  const lookupFn = getLookupFn(metadata)\n  const dynamicBuilder = getDynamicBuilder(lookupFn)\n  const signExtensionCreator = getSignExtensionsCreator(\n    genesis,\n    lookupFn,\n    dynamicBuilder,\n  )\n\n  const getPallet = (name: string) =>\n    metadata.pallets.find((p) => p.name === name)\n\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const constants = createProxyPath((pallet, name) => {\n    const constant = getPallet(pallet)?.constants.find((c) => c.name === name)\n    if (!constant)\n      throw new Error(`Runtime entry Constant(${pallet}.${name}) not found`)\n    return dynamicBuilder.buildConstant(pallet, name).dec(constant.value)\n  })\n\n  const tx = createProxyPath((pallet, name) =>\n    createOfflineTxEntry(\n      pallet,\n      name,\n      metadataRaw,\n      dynamicBuilder,\n      signExtensionCreator,\n    ),\n  )\n\n  return { constants, tx } as any\n}\n", "import { type ChainDefinition } from \"@/descriptors\"\nimport {\n  getDynamicBuilder,\n  getLookupFn,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport { decAnyMetadata, V14, V15 } from \"@polkadot-api/substrate-bindings\"\nimport { TypedCodecs } from \"./types\"\n\nexport const createConstantEntry = (\n  palletName: string,\n  name: string,\n  lookup: MetadataLookup,\n  { buildConstant }: ReturnType<typeof getDynamicBuilder>,\n) => {\n  const pallet = lookup.metadata.pallets.find((p) => p.name === palletName)\n  const constant = pallet?.constants.find((c) => c.name === name)\n  if (constant == null)\n    throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`)\n  return buildConstant(palletName, name)\n}\n\nconst withError =\n  <T>(\n    builder: (pallet: string, name: string) => T,\n    errName: string,\n  ): ((pallet: string, name: string) => T) =>\n  (pallet, name) => {\n    try {\n      return builder(pallet, name)\n    } catch {\n      throw new Error(`Runtime entry ${errName}(${pallet}.${name}) not found`)\n    }\n  }\n\n/**\n * It provides access the codecs of all possible on-chain interactions.\n *\n * @param descriptors  Pass descriptors from `@polkadot-api/descriptors`\n *                     generated by `papi` CLI.\n */\nexport const getTypedCodecs = async <D extends ChainDefinition>(\n  descriptors: D,\n): Promise<TypedCodecs<D>> => {\n  const metadata = decAnyMetadata(await descriptors.getMetadata()).metadata\n    .value as V14 | V15\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const lookup = getLookupFn(metadata)\n  const {\n    buildRuntimeCall,\n    buildStorage,\n    buildConstant,\n    buildCall,\n    buildEvent,\n  } = getDynamicBuilder(lookup)\n\n  return {\n    query: createProxyPath((...a) => {\n      const { value, args } = withError(buildStorage, \"Storage\")(...a)\n      return { value, args }\n    }),\n    tx: createProxyPath((...a) => withError(buildCall, \"Call\")(...a).codec),\n    event: createProxyPath(\n      (...args) => withError(buildEvent, \"Event\")(...args).codec,\n    ),\n    apis: createProxyPath(withError(buildRuntimeCall, \"Runtime API\")),\n    constants: createProxyPath(withError(buildConstant, \"Constant\")),\n  } as TypedCodecs<D>\n}\n"],
  "mappings": "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",
  "names": ["Enum", "Option", "Result", "Struct", "Tuple", "Vector", "u32", "u8", "buffer", "value", "u8", "u32", "noop", "enc", "HEX_MAP", "fromHex", "mapObject", "value", "mergeUint8", "noop", "textEncoder", "textDecoder", "__publicField", "mergeUint8", "fromHex", "value", "Bin", "u8", "str", "enc", "value", "fromHex", "dec", "textEncoder", "textDecoder", "str", "value", "value", "Enum", "enc", "OEnum", "dec", "value", "Enum", "mapObject", "keccak", "char", "fromHex", "Struct", "OStruct", "Tuple", "OTuple", "Vector", "OVector", "Result", "OResult", "Option", "OOption", "textEncoder", "textDecoder", "Struct", "Vector", "u32", "bitSequence", "u8", "u8", "value", "u8", "ty", "extrinsic", "u8", "ty", "u32", "mergeUint8", "arr", "v14", "v15", "last", "state", "take", "len32", "mergeUint8", "p", "temp", "mergeUint8", "textEncoder", "hashers", "mergeUint8", "dec", "fromHex", "opaqueBytes", "enc", "mergeUint8", "Vector", "Tuple", "Struct", "Option", "entry", "params", "value", "value", "destNode", "terminal", "__publicField", "CompatibilityLevel", "result", "originNode", "destNode", "value", "maxLevel", "lengthCheck", "value", "Struct", "entry", "noop", "noop", "noop", "fn", "noop", "noop", "noop", "params", "__publicField", "params", "subscriptionId", "params", "createClient", "createRawClient", "cached", "params", "__publicField", "value", "value", "chainHead", "value", "_void", "from", "withCache", "entry", "def", "params", "metadata", "def", "_void", "extrinsic", "_bytes", "inner", "Vector", "value", "Tuple", "Struct", "Option", "Result", "lookup", "metadata", "entry", "value", "Tuple", "hashers", "Struct", "mapObject", "Vector", "lookup", "_a", "textEncoder", "u32", "opaqueBytes", "Option", "Vector", "v14", "metadata", "metadataCodec", "v15", "lookup", "value", "refCount", "hash", "mergeUint8", "fromHex", "u8", "value", "chainHead", "value", "enc", "transaction", "clientCache", "cached", "value", "OpType", "Vector", "Tuple", "chainHead", "descriptors", "isCompatible", "isCompatible", "value", "shareLatest", "chainHead", "isCompatible", "shareLatest", "filter", "value", "chainHead", "isCompatible", "value", "chainHead", "isCompatible", "value", "u8", "value", "metadata", "extrinsic", "mergeUint8", "str", "mergeUint8", "metadata", "_", "additionalSigned", "mergeUint8", "value", "Struct", "Option", "empty", "value", "additionalSigned", "mapObject", "key", "fromHex", "u8", "u32", "from", "fromHex", "chainHead", "value", "fromHex", "value", "__publicField", "chainHead", "at", "transaction", "Struct", "chainHead", "arg", "lookup", "mergeUint8", "from", "fromHex", "u32", "Enum", "EMPTY_VALUE", "value", "__publicField", "external", "value", "state", "entry", "storage", "chainHead", "entry", "lookup", "createClient", "createRawClient", "mergeUint8", "Enum", "from", "fromHex", "metadata", "metadataCodec", "metadata", "lookup", "value"]
}
