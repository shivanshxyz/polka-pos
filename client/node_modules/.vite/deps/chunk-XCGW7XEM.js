// node_modules/.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/public-types.js
var AddChainError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AddChainError";
  }
};
var AlreadyDestroyedError = class extends Error {
  constructor() {
    super();
    this.name = "AlreadyDestroyedError";
  }
};
var JsonRpcDisabledError = class extends Error {
  constructor() {
    super();
    this.name = "JsonRpcDisabledError";
  }
};
var CrashError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var QueueFullError = class extends Error {
  constructor() {
    super("JSON-RPC requests queue is full");
  }
};

// node_modules/.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/internals/buffer.js
function utf8BytesToString(buffer, offset, length) {
  checkRange(buffer, offset, length);
  return new TextDecoder().decode(buffer.slice(offset, offset + length));
}
function readUInt8(buffer, offset) {
  checkRange(buffer, offset, 1);
  return buffer[offset];
}
function readUInt16BE(buffer, offset) {
  checkRange(buffer, offset, 2);
  return buffer[offset] << 8 | buffer[offset + 1];
}
function readUInt32LE(buffer, offset) {
  checkRange(buffer, offset, 4);
  return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16) + buffer[offset + 3] * 16777216;
}
function writeUInt8(buffer, offset, value) {
  checkRange(buffer, offset, 1);
  buffer[offset] = value & 255;
}
function writeUInt32LE(buffer, offset, value) {
  checkRange(buffer, offset, 4);
  buffer[offset + 3] = value >>> 24 & 255;
  buffer[offset + 2] = value >>> 16 & 255;
  buffer[offset + 1] = value >>> 8 & 255;
  buffer[offset] = value & 255;
}
function checkRange(buffer, offset, length) {
  if (!Number.isInteger(offset) || offset < 0)
    throw new RangeError();
  if (offset + length > buffer.length)
    throw new RangeError();
}

// node_modules/.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/internals/local-instance.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function startLocalInstance(config, wasmModule, eventCallback) {
  return __awaiter(this, void 0, void 0, function* () {
    const state = {
      instance: null,
      currentTask: null,
      bufferIndices: new Array(),
      advanceExecutionPromise: null,
      onShutdownExecutorOrWasmPanic: () => {
      }
    };
    const smoldotJsBindings = {
      // Must exit with an error. A human-readable message can be found in the WebAssembly
      // memory in the given buffer.
      panic: (ptr, len) => {
        const instance = state.instance;
        state.instance = null;
        ptr >>>= 0;
        len >>>= 0;
        const message = utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), ptr, len);
        eventCallback({ ty: "wasm-panic", message, currentTask: state.currentTask });
        state.onShutdownExecutorOrWasmPanic();
        state.onShutdownExecutorOrWasmPanic = () => {
        };
        throw new Error();
      },
      chain_initialized: (chainId, errorMsgPtr, errorMsgLen) => {
        const instance = state.instance;
        const mem = new Uint8Array(instance.exports.memory.buffer);
        errorMsgPtr >>>= 0;
        errorMsgLen >>>= 0;
        if (errorMsgPtr === 0) {
          eventCallback({ ty: "add-chain-result", chainId, success: true });
        } else {
          const errorMsg = utf8BytesToString(mem, errorMsgPtr, errorMsgLen);
          eventCallback({ ty: "add-chain-result", chainId, success: false, error: errorMsg });
        }
      },
      random_get: (ptr, len) => {
        const instance = state.instance;
        ptr >>>= 0;
        len >>>= 0;
        const baseBuffer = new Uint8Array(instance.exports.memory.buffer).subarray(ptr, ptr + len);
        for (let iter = 0; iter < len; iter += 65536) {
          config.getRandomValues(baseBuffer.subarray(iter, iter + 65536));
        }
      },
      unix_timestamp_us: () => {
        const value = Math.floor(Date.now());
        if (value < 0)
          throw new Error("UNIX timestamp inferior to 0");
        return BigInt(value) * BigInt(1e3);
      },
      monotonic_clock_us: () => {
        const nowMs = config.performanceNow();
        const nowMsInt = Math.floor(nowMs);
        const now = BigInt(nowMsInt) * BigInt(1e3) + BigInt(Math.floor((nowMs - nowMsInt) * 1e3));
        return now;
      },
      buffer_size: (bufferIndex) => {
        const buf = state.bufferIndices[bufferIndex];
        return buf.byteLength;
      },
      buffer_copy: (bufferIndex, targetPtr) => {
        const instance = state.instance;
        targetPtr = targetPtr >>> 0;
        const buf = state.bufferIndices[bufferIndex];
        new Uint8Array(instance.exports.memory.buffer).set(buf, targetPtr);
      },
      advance_execution_ready: () => {
        if (state.advanceExecutionPromise)
          state.advanceExecutionPromise();
        state.advanceExecutionPromise = null;
      },
      // Used by the Rust side to notify that a JSON-RPC response or subscription notification
      // is available in the queue of JSON-RPC responses.
      json_rpc_responses_non_empty: (chainId) => {
        eventCallback({ ty: "json-rpc-responses-non-empty", chainId });
      },
      // Used by the Rust side to emit a log entry.
      // See also the `max_log_level` parameter in the configuration.
      log: (level, targetPtr, targetLen, messagePtr, messageLen) => {
        const instance = state.instance;
        targetPtr >>>= 0;
        targetLen >>>= 0;
        messagePtr >>>= 0;
        messageLen >>>= 0;
        const mem = new Uint8Array(instance.exports.memory.buffer);
        let target = utf8BytesToString(mem, targetPtr, targetLen);
        let message = utf8BytesToString(mem, messagePtr, messageLen);
        eventCallback({ ty: "log", level, message, target });
      },
      // Must call `timer_finished` after the given number of milliseconds has elapsed.
      start_timer: (ms) => {
        const instance = state.instance;
        if (ms > 2147483647)
          ms = 2147483647;
        if (ms < 1 && typeof setImmediate === "function") {
          setImmediate(() => {
            if (!state.instance)
              return;
            try {
              instance.exports.timer_finished();
            } catch (_error) {
            }
          });
        } else {
          setTimeout(() => {
            if (!state.instance)
              return;
            try {
              instance.exports.timer_finished();
            } catch (_error) {
            }
          }, ms);
        }
      },
      // Must indicate whether the given connection type is supported.
      connection_type_supported: (ty) => {
        switch (ty) {
          case 0:
          case 1:
          case 2: {
            return config.forbidTcp ? 0 : 1;
          }
          case 4:
          case 5:
          case 6: {
            return config.forbidWs || config.forbidNonLocalWs ? 0 : 1;
          }
          case 7: {
            return config.forbidWs ? 0 : 1;
          }
          case 14: {
            return config.forbidWss ? 0 : 1;
          }
          case 16:
          case 17: {
            return config.forbidWebRtc ? 0 : 1;
          }
          default:
            throw new Error("Invalid connection type passed to `connection_type_supported`");
        }
      },
      // Must create a new connection object. This implementation stores the created object in
      // `connections`.
      connection_new: (connectionId, addrPtr, addrLen) => {
        const instance = state.instance;
        const mem = new Uint8Array(instance.exports.memory.buffer);
        addrPtr >>>= 0;
        addrLen >>>= 0;
        let address;
        switch (readUInt8(mem, addrPtr)) {
          case 0:
          case 1:
          case 2: {
            const port = readUInt16BE(mem, addrPtr + 1);
            const hostname = utf8BytesToString(mem, addrPtr + 3, addrLen - 3);
            address = { ty: "tcp", port, hostname };
            break;
          }
          case 4:
          case 6: {
            const port = readUInt16BE(mem, addrPtr + 1);
            const hostname = utf8BytesToString(mem, addrPtr + 3, addrLen - 3);
            address = { ty: "websocket", url: "ws://" + hostname + ":" + port };
            break;
          }
          case 5: {
            const port = readUInt16BE(mem, addrPtr + 1);
            const hostname = utf8BytesToString(mem, addrPtr + 3, addrLen - 3);
            address = { ty: "websocket", url: "ws://[" + hostname + "]:" + port };
            break;
          }
          case 14: {
            const port = readUInt16BE(mem, addrPtr + 1);
            const hostname = utf8BytesToString(mem, addrPtr + 3, addrLen - 3);
            address = { ty: "websocket", url: "wss://" + hostname + ":" + port };
            break;
          }
          case 16: {
            const targetPort = readUInt16BE(mem, addrPtr + 1);
            const remoteTlsCertificateSha256 = mem.slice(addrPtr + 3, addrPtr + 35);
            const targetIp = utf8BytesToString(mem, addrPtr + 35, addrLen - 35);
            address = { ty: "webrtc", ipVersion: "4", remoteTlsCertificateSha256, targetIp, targetPort };
            break;
          }
          case 17: {
            const targetPort = readUInt16BE(mem, addrPtr + 1);
            const remoteTlsCertificateSha256 = mem.slice(addrPtr + 3, addrPtr + 35);
            const targetIp = utf8BytesToString(mem, addrPtr + 35, addrLen - 35);
            address = { ty: "webrtc", ipVersion: "6", remoteTlsCertificateSha256, targetIp, targetPort };
            break;
          }
          default:
            throw new Error("Invalid encoded address passed to `connection_new`");
        }
        eventCallback({ ty: "new-connection", connectionId, address });
      },
      // Must close and destroy the connection object.
      reset_connection: (connectionId) => {
        eventCallback({ ty: "connection-reset", connectionId });
      },
      // Opens a new substream on a multi-stream connection.
      connection_stream_open: (connectionId) => {
        eventCallback({ ty: "connection-stream-open", connectionId });
      },
      // Closes a substream on a multi-stream connection.
      connection_stream_reset: (connectionId, streamId) => {
        eventCallback({ ty: "connection-stream-reset", connectionId, streamId });
      },
      // Must queue the data found in the WebAssembly memory at the given pointer. It is assumed
      // that this function is called only when the connection is in an open state.
      stream_send: (connectionId, streamId, ptr, len) => {
        const instance = state.instance;
        const mem = new Uint8Array(instance.exports.memory.buffer);
        ptr >>>= 0;
        len >>>= 0;
        const data = new Array();
        for (let i = 0; i < len; ++i) {
          const bufPtr = readUInt32LE(mem, ptr + 8 * i);
          const bufLen = readUInt32LE(mem, ptr + 8 * i + 4);
          data.push(mem.slice(bufPtr, bufPtr + bufLen));
        }
        eventCallback({ ty: "stream-send", connectionId, streamId, data });
      },
      stream_send_close: (connectionId, streamId) => {
        eventCallback({ ty: "stream-send-close", connectionId, streamId });
      },
      current_task_entered: (ptr, len) => {
        ptr >>>= 0;
        len >>>= 0;
        const taskName = utf8BytesToString(new Uint8Array(state.instance.exports.memory.buffer), ptr, len);
        state.currentTask = taskName;
      },
      current_task_exit: () => {
        state.currentTask = null;
      }
    };
    const result = yield WebAssembly.instantiate(wasmModule, {
      // The functions with the "smoldot" prefix are specific to smoldot.
      "smoldot": smoldotJsBindings
    });
    state.instance = result;
    state.instance.exports.init(config.maxLogLevel);
    const shutdownExecutorOrWasmPanicPromise = new Promise((resolve) => state.onShutdownExecutorOrWasmPanic = () => resolve("stop"));
    (() => __awaiter(this, void 0, void 0, function* () {
      const cpuRateLimit = config.cpuRateLimit;
      let missingSleep = 0;
      let now = config.performanceNow();
      while (true) {
        const whenReadyAgain = new Promise((resolve) => state.advanceExecutionPromise = () => resolve("ready"));
        if (!state.instance)
          break;
        state.instance.exports.advance_execution();
        const afterExec = config.performanceNow();
        const elapsed = afterExec - now;
        now = afterExec;
        const sleep = elapsed * (1 / cpuRateLimit - 1);
        missingSleep += sleep;
        if (missingSleep > 5) {
          if (missingSleep > 2147483646)
            missingSleep = 2147483646;
          const sleepFinished = new Promise((resolve) => setTimeout(() => resolve("timeout"), missingSleep));
          if ((yield Promise.race([sleepFinished, shutdownExecutorOrWasmPanicPromise])) === "stop")
            break;
        }
        if ((yield Promise.race([whenReadyAgain, shutdownExecutorOrWasmPanicPromise])) === "stop")
          break;
        const afterWait = config.performanceNow();
        missingSleep -= afterWait - now;
        if (missingSleep < -1e4)
          missingSleep = -1e4;
        now = afterWait;
      }
      if (!state.instance)
        return;
      eventCallback({ ty: "executor-shutdown" });
    }))();
    return {
      request: (request, chainId) => {
        if (!state.instance)
          return 1;
        state.bufferIndices[0] = new TextEncoder().encode(request);
        return state.instance.exports.json_rpc_send(0, chainId) >>> 0;
      },
      peekJsonRpcResponse: (chainId) => {
        if (!state.instance)
          return null;
        const responseInfo = state.instance.exports.json_rpc_responses_peek(chainId) >>> 0;
        const mem = new Uint8Array(state.instance.exports.memory.buffer);
        const ptr = readUInt32LE(mem, responseInfo) >>> 0;
        const len = readUInt32LE(mem, responseInfo + 4) >>> 0;
        if (len !== 0) {
          const message = utf8BytesToString(mem, ptr, len);
          state.instance.exports.json_rpc_responses_pop(chainId);
          return message;
        } else {
          return null;
        }
      },
      addChain: (chainSpec, databaseContent, potentialRelayChains, disableJsonRpc, jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions) => {
        if (!state.instance) {
          eventCallback({ ty: "add-chain-id-allocated", chainId: 0 });
          eventCallback({ ty: "add-chain-result", chainId: 0, success: false, error: "Smoldot has crashed" });
          return;
        }
        console.assert(disableJsonRpc || jsonRpcMaxPendingRequests != 0, "invalid jsonRpcMaxPendingRequests value passed to local-instance::addChain");
        state.bufferIndices[0] = new TextEncoder().encode(chainSpec);
        state.bufferIndices[1] = new TextEncoder().encode(databaseContent);
        const potentialRelayChainsEncoded = new Uint8Array(potentialRelayChains.length * 4);
        for (let idx = 0; idx < potentialRelayChains.length; ++idx) {
          writeUInt32LE(potentialRelayChainsEncoded, idx * 4, potentialRelayChains[idx]);
        }
        state.bufferIndices[2] = potentialRelayChainsEncoded;
        const chainId = state.instance.exports.add_chain(0, 1, disableJsonRpc ? 0 : jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions, 2);
        delete state.bufferIndices[0];
        delete state.bufferIndices[1];
        delete state.bufferIndices[2];
        eventCallback({ ty: "add-chain-id-allocated", chainId });
      },
      removeChain: (chainId) => {
        if (!state.instance)
          return;
        state.instance.exports.remove_chain(chainId);
      },
      shutdownExecutor: () => {
        if (!state.instance)
          return;
        const cb = state.onShutdownExecutorOrWasmPanic;
        state.onShutdownExecutorOrWasmPanic = () => {
        };
        cb();
      },
      connectionMultiStreamSetHandshakeInfo: (connectionId, info) => {
        if (!state.instance)
          return;
        const handshakeTy = new Uint8Array(1 + info.localTlsCertificateSha256.length);
        writeUInt8(handshakeTy, 0, 0);
        handshakeTy.set(info.localTlsCertificateSha256, 1);
        state.bufferIndices[0] = handshakeTy;
        state.instance.exports.connection_multi_stream_set_handshake_info(connectionId, 0);
        delete state.bufferIndices[0];
      },
      connectionReset: (connectionId, message) => {
        if (!state.instance)
          return;
        state.bufferIndices[0] = new TextEncoder().encode(message);
        state.instance.exports.connection_reset(connectionId, 0);
        delete state.bufferIndices[0];
      },
      streamWritableBytes: (connectionId, numExtra, streamId) => {
        if (!state.instance)
          return;
        state.instance.exports.stream_writable_bytes(connectionId, streamId || 0, numExtra);
      },
      streamMessage: (connectionId, message, streamId) => {
        if (!state.instance)
          return;
        state.bufferIndices[0] = message;
        state.instance.exports.stream_message(connectionId, streamId || 0, 0);
        delete state.bufferIndices[0];
      },
      streamOpened: (connectionId, streamId, direction) => {
        if (!state.instance)
          return;
        state.instance.exports.connection_stream_opened(connectionId, streamId, direction === "outbound" ? 1 : 0);
      },
      streamReset: (connectionId, streamId, message) => {
        if (!state.instance)
          return;
        state.bufferIndices[0] = new TextEncoder().encode(message);
        state.instance.exports.stream_reset(connectionId, streamId, 0);
        delete state.bufferIndices[0];
      }
    };
  });
}

// node_modules/.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/internals/remote-instance.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function connectToInstanceServer(config) {
  return __awaiter2(this, void 0, void 0, function* () {
    const { port1: portToServer, port2: serverToClient } = new MessageChannel();
    const initialPort = config.portToServer;
    const initialMessage = {
      wasmModule: yield config.wasmModule,
      serverToClient,
      maxLogLevel: config.maxLogLevel,
      cpuRateLimit: config.cpuRateLimit,
      forbidWs: config.forbidWs,
      forbidWss: config.forbidWss,
      forbidNonLocalWs: config.forbidNonLocalWs,
      forbidTcp: config.forbidTcp,
      forbidWebRtc: config.forbidWebRtc
    };
    initialPort.postMessage(initialMessage, [serverToClient]);
    const state = {
      jsonRpcResponses: /* @__PURE__ */ new Map(),
      connections: /* @__PURE__ */ new Map()
    };
    portToServer.onmessage = (messageEvent) => {
      const message = messageEvent.data;
      switch (message.ty) {
        case "wasm-panic":
        case "executor-shutdown": {
          portToServer.close();
          initialPort.close();
          break;
        }
        case "add-chain-result": {
          if (message.success) {
            state.jsonRpcResponses.set(message.chainId, new Array());
            const moreAccepted = { ty: "accept-more-json-rpc-answers", chainId: message.chainId };
            for (let i = 0; i < 10; ++i)
              portToServer.postMessage(moreAccepted);
          }
          break;
        }
        case "new-connection": {
          state.connections.set(message.connectionId, /* @__PURE__ */ new Set());
          break;
        }
        case "connection-reset": {
          if (!state.connections.has(message.connectionId))
            return;
          state.connections.delete(message.connectionId);
          break;
        }
        case "connection-stream-open": {
          if (!state.connections.has(message.connectionId))
            return;
          break;
        }
        case "connection-stream-reset": {
          if (!state.connections.has(message.connectionId))
            return;
          if (!state.connections.get(message.connectionId).has(message.streamId))
            return;
          break;
        }
        case "stream-send": {
          if (!state.connections.has(message.connectionId))
            return;
          if (message.streamId && !state.connections.get(message.connectionId).has(message.streamId))
            return;
          break;
        }
        case "stream-send-close": {
          if (!state.connections.has(message.connectionId))
            return;
          if (message.streamId && !state.connections.get(message.connectionId).has(message.streamId))
            return;
          break;
        }
        case "json-rpc-response": {
          const queue = state.jsonRpcResponses.get(message.chainId);
          if (queue) {
            queue.push(message.response);
            config.eventCallback({ ty: "json-rpc-responses-non-empty", chainId: message.chainId });
          }
          return;
        }
      }
      config.eventCallback(message);
    };
    return {
      addChain(chainSpec, databaseContent, potentialRelayChains, disableJsonRpc, jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions) {
        return __awaiter2(this, void 0, void 0, function* () {
          const msg = { ty: "add-chain", chainSpec, databaseContent, potentialRelayChains, disableJsonRpc, jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions };
          portToServer.postMessage(msg);
        });
      },
      removeChain(chainId) {
        state.jsonRpcResponses.delete(chainId);
        const msg = { ty: "remove-chain", chainId };
        portToServer.postMessage(msg);
      },
      request(request, chainId) {
        const msg = { ty: "request", chainId, request };
        portToServer.postMessage(msg);
        return 0;
      },
      peekJsonRpcResponse(chainId) {
        const item = state.jsonRpcResponses.get(chainId).shift();
        if (!item)
          return null;
        const msg = { ty: "accept-more-json-rpc-answers", chainId };
        portToServer.postMessage(msg);
        return item;
      },
      shutdownExecutor() {
        const msg = { ty: "shutdown" };
        portToServer.postMessage(msg);
      },
      connectionReset(connectionId, message) {
        state.connections.delete(connectionId);
        const msg = { ty: "connection-reset", connectionId, message };
        portToServer.postMessage(msg);
      },
      connectionMultiStreamSetHandshakeInfo(connectionId, info) {
        const msg = { ty: "connection-multistream-set-info", connectionId, info };
        portToServer.postMessage(msg);
      },
      streamMessage(connectionId, message, streamId) {
        const msg = { ty: "stream-message", connectionId, message, streamId };
        portToServer.postMessage(msg);
      },
      streamOpened(connectionId, streamId, direction) {
        state.connections.get(connectionId).add(streamId);
        const msg = { ty: "stream-opened", connectionId, streamId, direction };
        portToServer.postMessage(msg);
      },
      streamWritableBytes(connectionId, numExtra, streamId) {
        const msg = { ty: "stream-writable-bytes", connectionId, numExtra, streamId };
        portToServer.postMessage(msg);
      },
      streamReset(connectionId, streamId, message) {
        state.connections.get(connectionId).delete(streamId);
        const msg = { ty: "stream-reset", connectionId, streamId, message };
        portToServer.postMessage(msg);
      }
    };
  });
}

// node_modules/.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/internals/client.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function start(options, wasmModule, platformBindings) {
  const logCallback = options.logCallback || ((level, target, message) => {
    if (level <= 1) {
      console.error("[%s] %s", target, message);
    } else if (level == 2) {
      console.warn("[%s] %s", target, message);
    } else if (level == 3) {
      console.info("[%s] %s", target, message);
    } else if (level == 4) {
      console.debug("[%s] %s", target, message);
    } else {
      console.trace("[%s] %s", target, message);
    }
  });
  if (!(wasmModule instanceof Promise)) {
    wasmModule = Promise.resolve(wasmModule);
  }
  let cpuRateLimit = options.cpuRateLimit || 1;
  if (isNaN(cpuRateLimit))
    cpuRateLimit = 1;
  if (cpuRateLimit > 1)
    cpuRateLimit = 1;
  if (cpuRateLimit < 0)
    cpuRateLimit = 0;
  const state = {
    instance: { status: "not-created" },
    chainIds: /* @__PURE__ */ new WeakMap(),
    connections: /* @__PURE__ */ new Map(),
    addChainIdAllocations: [],
    addChainResults: /* @__PURE__ */ new Map(),
    onExecutorShutdownOrWasmPanic: () => {
    },
    chains: /* @__PURE__ */ new Map()
  };
  const eventCallback = (event) => {
    switch (event.ty) {
      case "wasm-panic": {
        console.error("Smoldot has panicked" + (event.currentTask ? " while executing task `" + event.currentTask + "`" : "") + ". This is a bug in smoldot. Please open an issue at https://github.com/smol-dot/smoldot/issues with the following message:\n" + event.message);
        state.instance = {
          status: "destroyed",
          error: new CrashError(event.message)
        };
        state.connections.forEach((connec) => connec.reset());
        state.connections.clear();
        for (const addChainResult of state.addChainIdAllocations) {
          addChainResult({ success: false, error: "Smoldot has crashed" });
        }
        state.addChainIdAllocations = [];
        state.addChainResults.forEach((addChainResult) => {
          addChainResult({ success: false, error: "Smoldot has crashed" });
        });
        state.addChainResults.clear();
        for (const chain of Array.from(state.chains.values())) {
          for (const callback of chain.jsonRpcResponsesPromises) {
            callback();
          }
          chain.jsonRpcResponsesPromises = [];
        }
        state.chains.clear();
        const cb = state.onExecutorShutdownOrWasmPanic;
        state.onExecutorShutdownOrWasmPanic = () => {
        };
        cb();
        break;
      }
      case "executor-shutdown": {
        const cb = state.onExecutorShutdownOrWasmPanic;
        state.onExecutorShutdownOrWasmPanic = () => {
        };
        cb();
        break;
      }
      case "log": {
        logCallback(event.level, event.target, event.message);
        break;
      }
      case "add-chain-id-allocated": {
        const callback = state.addChainIdAllocations.shift();
        state.addChainResults.set(event.chainId, callback);
        break;
      }
      case "add-chain-result": {
        state.addChainResults.get(event.chainId)(event);
        state.addChainResults.delete(event.chainId);
        break;
      }
      case "json-rpc-responses-non-empty": {
        const callbacks = state.chains.get(event.chainId).jsonRpcResponsesPromises;
        while (callbacks.length !== 0) {
          callbacks.shift()();
        }
        break;
      }
      case "new-connection": {
        const connectionId = event.connectionId;
        state.connections.set(connectionId, platformBindings.connect({
          address: event.address,
          onConnectionReset(message) {
            if (state.instance.status !== "ready")
              throw new Error();
            state.connections.delete(connectionId);
            state.instance.instance.connectionReset(connectionId, message);
          },
          onMessage(message, streamId) {
            if (state.instance.status !== "ready")
              throw new Error();
            state.instance.instance.streamMessage(connectionId, message, streamId);
          },
          onStreamOpened(streamId, direction) {
            if (state.instance.status !== "ready")
              throw new Error();
            state.instance.instance.streamOpened(connectionId, streamId, direction);
          },
          onMultistreamHandshakeInfo(info) {
            if (state.instance.status !== "ready")
              throw new Error();
            state.instance.instance.connectionMultiStreamSetHandshakeInfo(connectionId, info);
          },
          onWritableBytes(numExtra, streamId) {
            if (state.instance.status !== "ready")
              throw new Error();
            state.instance.instance.streamWritableBytes(connectionId, numExtra, streamId);
          },
          onStreamReset(streamId, message) {
            if (state.instance.status !== "ready")
              throw new Error();
            state.instance.instance.streamReset(connectionId, streamId, message);
          }
        }));
        break;
      }
      case "connection-reset": {
        const connection = state.connections.get(event.connectionId);
        connection.reset();
        state.connections.delete(event.connectionId);
        break;
      }
      case "connection-stream-open": {
        const connection = state.connections.get(event.connectionId);
        connection.openOutSubstream();
        break;
      }
      case "connection-stream-reset": {
        const connection = state.connections.get(event.connectionId);
        connection.reset(event.streamId);
        break;
      }
      case "stream-send": {
        const connection = state.connections.get(event.connectionId);
        connection.send(event.data, event.streamId);
        break;
      }
      case "stream-send-close": {
        const connection = state.connections.get(event.connectionId);
        connection.closeSend(event.streamId);
        break;
      }
    }
  };
  const portToWorker = options.portToWorker;
  if (!portToWorker) {
    state.instance = {
      status: "not-ready",
      whenReady: wasmModule.then((wasmModule2) => {
        return startLocalInstance({
          forbidTcp: options.forbidTcp || false,
          forbidWs: options.forbidWs || false,
          forbidNonLocalWs: options.forbidNonLocalWs || false,
          forbidWss: options.forbidWss || false,
          forbidWebRtc: options.forbidWebRtc || false,
          maxLogLevel: options.maxLogLevel || 3,
          cpuRateLimit,
          envVars: [],
          performanceNow: platformBindings.performanceNow,
          getRandomValues: platformBindings.getRandomValues
        }, wasmModule2.wasm, eventCallback);
      }).then((instance) => {
        if (state.instance.status === "destroyed")
          return;
        state.instance = {
          status: "ready",
          instance
        };
      })
    };
  } else {
    state.instance = {
      status: "not-ready",
      whenReady: connectToInstanceServer({
        wasmModule: wasmModule.then((b) => b.wasm),
        forbidTcp: options.forbidTcp || false,
        forbidWs: options.forbidWs || false,
        forbidNonLocalWs: options.forbidNonLocalWs || false,
        forbidWss: options.forbidWss || false,
        forbidWebRtc: options.forbidWebRtc || false,
        maxLogLevel: options.maxLogLevel || 3,
        cpuRateLimit,
        portToServer: portToWorker,
        eventCallback
      }).then((instance) => {
        if (state.instance.status === "destroyed")
          return;
        state.instance = {
          status: "ready",
          instance
        };
      })
    };
  }
  return {
    addChain: (options2) => __awaiter3(this, void 0, void 0, function* () {
      if (state.instance.status === "not-ready")
        yield state.instance.whenReady;
      if (state.instance.status === "destroyed")
        throw state.instance.error;
      if (state.instance.status === "not-created" || state.instance.status === "not-ready")
        throw new Error();
      if (!(typeof options2.chainSpec === "string"))
        throw new Error("Chain specification must be a string");
      let potentialRelayChainsIds = [];
      if (!!options2.potentialRelayChains) {
        for (const chain of options2.potentialRelayChains) {
          const id = state.chainIds.get(chain);
          if (id === void 0)
            continue;
          potentialRelayChainsIds.push(id);
        }
      }
      let jsonRpcMaxPendingRequests = options2.jsonRpcMaxPendingRequests === void 0 ? Infinity : options2.jsonRpcMaxPendingRequests;
      jsonRpcMaxPendingRequests = Math.floor(jsonRpcMaxPendingRequests);
      if (jsonRpcMaxPendingRequests <= 0 || isNaN(jsonRpcMaxPendingRequests)) {
        throw new AddChainError("Invalid value for `jsonRpcMaxPendingRequests`");
      }
      if (jsonRpcMaxPendingRequests > 4294967295) {
        jsonRpcMaxPendingRequests = 4294967295;
      }
      let jsonRpcMaxSubscriptions = options2.jsonRpcMaxSubscriptions === void 0 ? Infinity : options2.jsonRpcMaxSubscriptions;
      jsonRpcMaxSubscriptions = Math.floor(jsonRpcMaxSubscriptions);
      if (jsonRpcMaxSubscriptions < 0 || isNaN(jsonRpcMaxSubscriptions)) {
        throw new AddChainError("Invalid value for `jsonRpcMaxSubscriptions`");
      }
      if (jsonRpcMaxSubscriptions > 4294967295) {
        jsonRpcMaxSubscriptions = 4294967295;
      }
      if (options2.databaseContent !== void 0 && typeof options2.databaseContent !== "string")
        throw new AddChainError("`databaseContent` is not a string");
      const promise = new Promise((resolve) => state.addChainIdAllocations.push(resolve));
      state.instance.instance.addChain(options2.chainSpec, options2.databaseContent || "", potentialRelayChainsIds, !!options2.disableJsonRpc, jsonRpcMaxPendingRequests, jsonRpcMaxSubscriptions);
      const outcome = yield promise;
      if (!outcome.success)
        throw new AddChainError(outcome.error);
      const chainId = outcome.chainId;
      state.chains.set(chainId, {
        jsonRpcResponsesPromises: new Array()
      });
      const newChain = {
        sendJsonRpc: (request) => {
          if (state.instance.status === "destroyed")
            throw state.instance.error;
          if (state.instance.status !== "ready")
            throw new Error();
          if (!state.chains.has(chainId))
            throw new AlreadyDestroyedError();
          if (options2.disableJsonRpc)
            throw new JsonRpcDisabledError();
          const retVal = state.instance.instance.request(request, chainId);
          switch (retVal) {
            case 0:
              break;
            case 1:
              throw new QueueFullError();
            default:
              throw new Error("Internal error: unknown json_rpc_send error code: " + retVal);
          }
        },
        jsonRpcResponses: {
          next: () => __awaiter3(this, void 0, void 0, function* () {
            while (true) {
              if (!state.chains.has(chainId))
                return { done: true, value: void 0 };
              if (options2.disableJsonRpc)
                throw new JsonRpcDisabledError();
              if (state.instance.status === "destroyed")
                throw state.instance.error;
              if (state.instance.status !== "ready")
                throw new Error();
              const message = state.instance.instance.peekJsonRpcResponse(chainId);
              if (message)
                return { done: false, value: message };
              yield new Promise((resolve) => {
                state.chains.get(chainId).jsonRpcResponsesPromises.push(resolve);
              });
            }
          }),
          [Symbol.asyncIterator]() {
            return this;
          }
        },
        nextJsonRpcResponse: () => __awaiter3(this, void 0, void 0, function* () {
          const result = yield newChain.jsonRpcResponses.next();
          if (result.done) {
            throw new AlreadyDestroyedError();
          }
          return result.value;
        }),
        remove: () => {
          if (state.instance.status === "destroyed")
            throw state.instance.error;
          if (state.instance.status !== "ready")
            throw new Error();
          if (!state.chains.has(chainId))
            throw new AlreadyDestroyedError();
          console.assert(state.chainIds.has(newChain));
          state.chainIds.delete(newChain);
          for (const callback of state.chains.get(chainId).jsonRpcResponsesPromises) {
            callback();
          }
          state.chains.delete(chainId);
          state.instance.instance.removeChain(chainId);
        }
      };
      state.chainIds.set(newChain, chainId);
      return newChain;
    }),
    terminate: () => __awaiter3(this, void 0, void 0, function* () {
      if (state.instance.status === "not-ready")
        yield state.instance.whenReady;
      if (state.instance.status === "destroyed")
        throw state.instance.error;
      if (state.instance.status !== "ready")
        throw new Error();
      state.instance.instance.shutdownExecutor();
      yield new Promise((resolve) => state.onExecutorShutdownOrWasmPanic = resolve);
      if (state.instance.status === "ready")
        state.instance = { status: "destroyed", error: new AlreadyDestroyedError() };
      state.connections.forEach((connec) => connec.reset());
      state.connections.clear();
      for (const addChainResult of state.addChainIdAllocations) {
        addChainResult({ success: false, error: "Client.terminate() has been called" });
      }
      state.addChainIdAllocations = [];
      state.addChainResults.forEach((addChainResult) => {
        addChainResult({ success: false, error: "Client.terminate() has been called" });
      });
      state.addChainResults.clear();
      for (const chain of Array.from(state.chains.values())) {
        for (const callback of chain.jsonRpcResponsesPromises) {
          callback();
        }
        chain.jsonRpcResponsesPromises = [];
      }
      state.chains.clear();
    })
  };
}

// node_modules/.pnpm/smoldot@2.0.34/node_modules/smoldot/dist/mjs/no-auto-bytecode-browser.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function startWithBytecode(options) {
  options.forbidTcp = true;
  if (typeof isSecureContext === "boolean" && isSecureContext && typeof location !== void 0) {
    const loc = location.toString();
    if (loc.indexOf("localhost") !== -1 && loc.indexOf("127.0.0.1") !== -1 && loc.indexOf("::1") !== -1) {
      options.forbidNonLocalWs = true;
    }
  }
  return start(options, options.bytecode, {
    performanceNow: () => {
      return performance.now();
    },
    getRandomValues: (buffer) => {
      const crypto = globalThis.crypto;
      if (!crypto)
        throw new Error("randomness not available");
      if (buffer.buffer instanceof ArrayBuffer)
        crypto.getRandomValues(buffer);
      else {
        const tmpArray = new Uint8Array(buffer.length);
        crypto.getRandomValues(tmpArray);
        buffer.set(tmpArray);
      }
    },
    connect: (config) => {
      return connect(config);
    }
  });
}
function connect(config) {
  if (config.address.ty === "websocket") {
    let connection;
    try {
      connection = new WebSocket(config.address.url);
    } catch (error) {
      connection = error instanceof Error ? error.toString() : "Exception thrown by new WebSocket";
    }
    const bufferedAmountCheck = { quenedUnreportedBytes: 0, nextTimeout: 10 };
    const checkBufferedAmount = () => {
      if (!(connection instanceof WebSocket))
        return;
      if (connection.readyState != 1)
        return;
      const bufferedAmount = connection.bufferedAmount;
      let wasSent = bufferedAmountCheck.quenedUnreportedBytes - bufferedAmount;
      if (wasSent < 0)
        wasSent = 0;
      bufferedAmountCheck.quenedUnreportedBytes -= wasSent;
      if (bufferedAmountCheck.quenedUnreportedBytes != 0) {
        setTimeout(checkBufferedAmount, bufferedAmountCheck.nextTimeout);
        bufferedAmountCheck.nextTimeout *= 2;
        if (bufferedAmountCheck.nextTimeout > 500)
          bufferedAmountCheck.nextTimeout = 500;
      }
      if (wasSent != 0)
        config.onWritableBytes(wasSent);
    };
    if (connection instanceof WebSocket) {
      connection.binaryType = "arraybuffer";
      connection.onopen = () => {
        config.onWritableBytes(1024 * 1024);
      };
      connection.onclose = (event) => {
        const message = "Error code " + event.code + (!!event.reason ? ": " + event.reason : "");
        config.onConnectionReset(message);
      };
      connection.onmessage = (msg) => {
        config.onMessage(new Uint8Array(msg.data));
      };
    } else {
      setTimeout(() => {
        if (connection && !(connection instanceof WebSocket)) {
          config.onConnectionReset(connection);
          connection = null;
        }
      }, 1);
    }
    return {
      reset: () => {
        if (connection instanceof WebSocket) {
          connection.onopen = null;
          connection.onclose = null;
          connection.onmessage = null;
          connection.onerror = null;
          if (connection.readyState == WebSocket.OPEN)
            connection.close();
        }
        connection = null;
      },
      send: (data) => {
        if (bufferedAmountCheck.quenedUnreportedBytes == 0) {
          bufferedAmountCheck.nextTimeout = 10;
          setTimeout(checkBufferedAmount, 10);
        }
        for (const buffer of data) {
          bufferedAmountCheck.quenedUnreportedBytes += buffer.length;
        }
        connection.send(new Blob(data));
      },
      closeSend: () => {
        throw new Error("Wrong connection type");
      },
      openOutSubstream: () => {
        throw new Error("Wrong connection type");
      }
    };
  } else if (config.address.ty === "webrtc") {
    const { targetPort, ipVersion, targetIp, remoteTlsCertificateSha256 } = config.address;
    const state = {
      pc: void 0,
      dataChannels: /* @__PURE__ */ new Map(),
      nextStreamId: 0,
      isFirstOutSubstream: true
    };
    const killAllJs = () => {
      if (!state.pc) {
        console.assert(state.dataChannels.size === 0, "substreams exist while pc is undef");
        state.pc = null;
        return;
      }
      state.pc.onconnectionstatechange = null;
      state.pc.onnegotiationneeded = null;
      state.pc.ondatachannel = null;
      for (const channel of Array.from(state.dataChannels.values())) {
        channel.channel.onopen = null;
        channel.channel.onerror = null;
        channel.channel.onclose = null;
        channel.channel.onbufferedamountlow = null;
        channel.channel.onmessage = null;
      }
      state.dataChannels.clear();
      state.pc.close();
    };
    const addChannel = (dataChannel, direction) => {
      const streamId = state.nextStreamId;
      state.nextStreamId += 1;
      dataChannel.binaryType = "arraybuffer";
      let isOpen = { value: false };
      dataChannel.onopen = () => {
        console.assert(!isOpen.value, "substream opened twice");
        isOpen.value = true;
        config.onStreamOpened(streamId, direction);
        config.onWritableBytes(65536, streamId);
      };
      dataChannel.onerror = dataChannel.onclose = (event) => {
        const message = event instanceof RTCErrorEvent ? event.error.toString() : "RTCDataChannel closed";
        if (!isOpen.value) {
          killAllJs();
          config.onConnectionReset("data channel failed to open: " + message);
        } else {
          dataChannel.onopen = null;
          dataChannel.onerror = null;
          dataChannel.onclose = null;
          dataChannel.onbufferedamountlow = null;
          dataChannel.onmessage = null;
          state.dataChannels.delete(streamId);
          config.onStreamReset(streamId, message);
        }
      };
      dataChannel.onbufferedamountlow = () => {
        const channel = state.dataChannels.get(streamId);
        const val = channel.bufferedBytes;
        channel.bufferedBytes = 0;
        config.onWritableBytes(val, streamId);
      };
      dataChannel.onmessage = (m) => {
        config.onMessage(new Uint8Array(m.data), streamId);
      };
      state.dataChannels.set(streamId, { channel: dataChannel, bufferedBytes: 0 });
    };
    RTCPeerConnection.generateCertificate({ name: "ECDSA", namedCurve: "P-256", hash: "SHA-256" }).then((localCertificate) => __awaiter4(this, void 0, void 0, function* () {
      if (state.pc === null)
        return;
      if ((targetIp == "localhost" || targetIp == "127.0.0.1" || targetIp == "::1") && navigator.userAgent.indexOf("Firefox") !== -1) {
        killAllJs();
        config.onConnectionReset("Firefox can't connect to a localhost WebRTC server");
        return;
      }
      state.pc = new RTCPeerConnection({ certificates: [localCertificate] });
      let localTlsCertificateHex;
      if (localCertificate.getFingerprints) {
        for (const { algorithm, value } of localCertificate.getFingerprints()) {
          if (algorithm === "sha-256") {
            localTlsCertificateHex = value;
            break;
          }
        }
      } else {
        const localSdpOffer = yield state.pc.createOffer();
        const localSdpOfferFingerprintMatch = localSdpOffer.sdp.match(/a(\s*)=(\s*)fingerprint:(\s*)(sha|SHA)-256(\s*)(([a-fA-F0-9]{2}(:)*){32})/);
        if (localSdpOfferFingerprintMatch) {
          localTlsCertificateHex = localSdpOfferFingerprintMatch[6];
        }
      }
      if (localTlsCertificateHex === void 0) {
        config.onConnectionReset("Failed to obtain the browser certificate fingerprint");
        return;
      }
      let localTlsCertificateSha256 = new Uint8Array(32);
      localTlsCertificateSha256.set(localTlsCertificateHex.split(":").map((s) => parseInt(s, 16)), 0);
      state.pc.onconnectionstatechange = (_event) => {
        if (state.pc.connectionState == "closed" || state.pc.connectionState == "disconnected" || state.pc.connectionState == "failed") {
          killAllJs();
          config.onConnectionReset("WebRTC state transitioned to " + state.pc.connectionState);
        }
      };
      state.pc.onnegotiationneeded = (_event) => __awaiter4(this, void 0, void 0, function* () {
        var _a;
        let sdpOffer = (yield state.pc.createOffer()).sdp;
        if (sdpOffer.match(/^m=application(\s+)(\d+)(\s+)UDP\/DTLS\/SCTP(\s+)webrtc-datachannel$/m) === null) {
          console.error("Local offer doesn't contain UDP data channel. WebRTC connections will likely fail. Please report this issue.");
        }
        const browserGeneratedPwd = (_a = sdpOffer.match(/^a=ice-pwd:(.+)$/m)) === null || _a === void 0 ? void 0 : _a.at(1);
        if (browserGeneratedPwd === void 0) {
          console.error("Failed to set ufrag to pwd. WebRTC connections will likely fail. Please report this issue.");
        }
        const ufragPwd = "libp2p+webrtc+v1/" + browserGeneratedPwd;
        sdpOffer = sdpOffer.replace(/^a=ice-ufrag.*$/m, "a=ice-ufrag:" + ufragPwd);
        sdpOffer = sdpOffer.replace(/^a=ice-pwd.*$/m, "a=ice-pwd:" + ufragPwd);
        yield state.pc.setLocalDescription({ type: "offer", sdp: sdpOffer });
        const fingerprint = Array.from(remoteTlsCertificateSha256).map((n) => ("0" + n.toString(16)).slice(-2).toUpperCase()).join(":");
        const remoteSdp = (
          // Version of the SDP protocol. Always 0. (RFC8866)
          "v=0\no=- 0 0 IN IP" + ipVersion + " " + targetIp + "\ns=-\nt=0 0\na=ice-lite\nm=application " + String(targetPort) + " UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP" + ipVersion + " " + targetIp + "\na=mid:0\na=ice-options:ice2\na=ice-ufrag:" + ufragPwd + "\na=ice-pwd:" + ufragPwd + "\na=fingerprint:sha-256 " + fingerprint + "\na=setup:passive\na=sctp-port:5000\na=max-message-size:16384\na=candidate:1 1 UDP 1 " + targetIp + " " + String(targetPort) + " typ host\n"
        );
        yield state.pc.setRemoteDescription({ type: "answer", sdp: remoteSdp });
      });
      state.pc.ondatachannel = ({ channel }) => {
        addChannel(channel, "inbound");
      };
      config.onMultistreamHandshakeInfo({
        handshake: "webrtc",
        localTlsCertificateSha256
      });
    }));
    return {
      reset: (streamId) => {
        if (streamId === void 0) {
          killAllJs();
        } else {
          const channel = state.dataChannels.get(streamId);
          channel.channel.onopen = null;
          channel.channel.onerror = null;
          channel.channel.onclose = null;
          channel.channel.onbufferedamountlow = null;
          channel.channel.onmessage = null;
          channel.channel.close();
          state.dataChannels.delete(streamId);
        }
      },
      send: (data, streamId) => {
        const channel = state.dataChannels.get(streamId);
        for (const buffer of data) {
          channel.bufferedBytes += buffer.length;
        }
        channel.channel.send(new Blob(data));
      },
      closeSend: () => {
        throw new Error("Wrong connection type");
      },
      openOutSubstream: () => {
        const opts = state.isFirstOutSubstream ? { negotiated: true, id: 0 } : {};
        state.isFirstOutSubstream = false;
        addChannel(state.pc.createDataChannel("", opts), "outbound");
      }
    };
  } else {
    throw new Error();
  }
}

export {
  AddChainError,
  AlreadyDestroyedError,
  JsonRpcDisabledError,
  CrashError,
  startWithBytecode
};
//# sourceMappingURL=chunk-XCGW7XEM.js.map
